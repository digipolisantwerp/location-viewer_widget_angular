{"ast":null,"code":"import { Task } from './Task';\nimport { responseToFeatureCollection } from '../Util';\nexport var Find = Task.extend({\n  setters: {\n    // method name > param name\n    contains: 'contains',\n    text: 'searchText',\n    fields: 'searchFields',\n    // denote an array or single string\n    spatialReference: 'sr',\n    sr: 'sr',\n    layers: 'layers',\n    returnGeometry: 'returnGeometry',\n    maxAllowableOffset: 'maxAllowableOffset',\n    precision: 'geometryPrecision',\n    dynamicLayers: 'dynamicLayers',\n    returnZ: 'returnZ',\n    returnM: 'returnM',\n    gdbVersion: 'gdbVersion',\n    // skipped implementing this (for now) because the REST service implementation isnt consistent between operations\n    // 'transform': 'datumTransformations',\n    token: 'token'\n  },\n  path: 'find',\n  params: {\n    sr: 4326,\n    contains: true,\n    returnGeometry: true,\n    returnZ: true,\n    returnM: false\n  },\n  layerDefs: function (id, where) {\n    this.params.layerDefs = this.params.layerDefs ? this.params.layerDefs + ';' : '';\n    this.params.layerDefs += [id, where].join(':');\n    return this;\n  },\n  simplify: function (map, factor) {\n    var mapWidth = Math.abs(map.getBounds().getWest() - map.getBounds().getEast());\n    this.params.maxAllowableOffset = mapWidth / map.getSize().y * factor;\n    return this;\n  },\n  run: function (callback, context) {\n    return this.request(function (error, response) {\n      callback.call(context, error, response && responseToFeatureCollection(response), response);\n    }, context);\n  }\n});\nexport function find(options) {\n  return new Find(options);\n}\nexport default find;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}