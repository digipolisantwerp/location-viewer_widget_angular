{"ast":null,"code":"import { latLng, latLngBounds, LatLng, LatLngBounds, Util, DomUtil, GeoJSON } from 'leaflet';\nimport { request, warn } from './Request';\nimport { options } from './Options';\nimport { Support } from './Support';\nimport { geojsonToArcGIS as g2a, arcgisToGeoJSON as a2g } from '@terraformer/arcgis';\nvar BASE_LEAFLET_ATTRIBUTION_STRING = '<a href=\"http://leafletjs.com\" title=\"A JS library for interactive maps\">Leaflet</a>';\nvar POWERED_BY_ESRI_ATTRIBUTION_STRING = 'Powered by <a href=\"https://www.esri.com\">Esri</a>';\nexport function geojsonToArcGIS(geojson, idAttr) {\n  return g2a(geojson, idAttr);\n}\nexport function arcgisToGeoJSON(arcgis, idAttr) {\n  return a2g(arcgis, idAttr);\n}\n\n// convert an extent (ArcGIS) to LatLngBounds (Leaflet)\nexport function extentToBounds(extent) {\n  // \"NaN\" coordinates from ArcGIS Server indicate a null geometry\n  if (extent.xmin !== 'NaN' && extent.ymin !== 'NaN' && extent.xmax !== 'NaN' && extent.ymax !== 'NaN') {\n    var sw = latLng(extent.ymin, extent.xmin);\n    var ne = latLng(extent.ymax, extent.xmax);\n    return latLngBounds(sw, ne);\n  } else {\n    return null;\n  }\n}\n\n// convert an LatLngBounds (Leaflet) to extent (ArcGIS)\nexport function boundsToExtent(bounds) {\n  bounds = latLngBounds(bounds);\n  return {\n    xmin: bounds.getSouthWest().lng,\n    ymin: bounds.getSouthWest().lat,\n    xmax: bounds.getNorthEast().lng,\n    ymax: bounds.getNorthEast().lat,\n    spatialReference: {\n      wkid: 4326\n    }\n  };\n}\nvar knownFieldNames = /^(OBJECTID|FID|OID|ID)$/i;\n\n// Attempts to find the ID Field from response\nexport function _findIdAttributeFromResponse(response) {\n  var result;\n  if (response.objectIdFieldName) {\n    // Find Id Field directly\n    result = response.objectIdFieldName;\n  } else if (response.fields) {\n    // Find ID Field based on field type\n    for (var j = 0; j <= response.fields.length - 1; j++) {\n      if (response.fields[j].type === 'esriFieldTypeOID') {\n        result = response.fields[j].name;\n        break;\n      }\n    }\n    if (!result) {\n      // If no field was marked as being the esriFieldTypeOID try well known field names\n      for (j = 0; j <= response.fields.length - 1; j++) {\n        if (response.fields[j].name.match(knownFieldNames)) {\n          result = response.fields[j].name;\n          break;\n        }\n      }\n    }\n  }\n  return result;\n}\n\n// This is the 'last' resort, find the Id field from the specified feature\nexport function _findIdAttributeFromFeature(feature) {\n  for (var key in feature.attributes) {\n    if (key.match(knownFieldNames)) {\n      return key;\n    }\n  }\n}\nexport function responseToFeatureCollection(response, idAttribute) {\n  var objectIdField;\n  var features = response.features || response.results;\n  var count = features && features.length;\n  if (idAttribute) {\n    objectIdField = idAttribute;\n  } else {\n    objectIdField = _findIdAttributeFromResponse(response);\n  }\n  var featureCollection = {\n    type: 'FeatureCollection',\n    features: []\n  };\n  if (count) {\n    for (var i = features.length - 1; i >= 0; i--) {\n      var feature = arcgisToGeoJSON(features[i], objectIdField || _findIdAttributeFromFeature(features[i]));\n      featureCollection.features.push(feature);\n    }\n  }\n  return featureCollection;\n}\n\n// trim url whitespace and add a trailing slash if needed\nexport function cleanUrl(url) {\n  // trim leading and trailing spaces, but not spaces inside the url\n  url = Util.trim(url);\n\n  // add a trailing slash to the url if the user omitted it\n  if (url[url.length - 1] !== '/') {\n    url += '/';\n  }\n  return url;\n}\n\n/* Extract url params if any and store them in requestParams attribute.\r\n   Return the options params updated */\nexport function getUrlParams(options) {\n  if (options.url.indexOf('?') !== -1) {\n    options.requestParams = options.requestParams || {};\n    var queryString = options.url.substring(options.url.indexOf('?') + 1);\n    options.url = options.url.split('?')[0];\n    options.requestParams = JSON.parse('{\"' + decodeURI(queryString).replace(/\"/g, '\\\\\"').replace(/&/g, '\",\"').replace(/=/g, '\":\"') + '\"}');\n  }\n  options.url = cleanUrl(options.url.split('?')[0]);\n  return options;\n}\nexport function isArcgisOnline(url) {\n  /* hosted feature services support geojson as an output format\r\n  utility.arcgis.com services are proxied from a variety of ArcGIS Server vintages, and may not */\n  return /^(?!.*utility\\.arcgis\\.com).*\\.arcgis\\.com.*FeatureServer/i.test(url);\n}\nexport function geojsonTypeToArcGIS(geoJsonType) {\n  var arcgisGeometryType;\n  switch (geoJsonType) {\n    case 'Point':\n      arcgisGeometryType = 'esriGeometryPoint';\n      break;\n    case 'MultiPoint':\n      arcgisGeometryType = 'esriGeometryMultipoint';\n      break;\n    case 'LineString':\n      arcgisGeometryType = 'esriGeometryPolyline';\n      break;\n    case 'MultiLineString':\n      arcgisGeometryType = 'esriGeometryPolyline';\n      break;\n    case 'Polygon':\n      arcgisGeometryType = 'esriGeometryPolygon';\n      break;\n    case 'MultiPolygon':\n      arcgisGeometryType = 'esriGeometryPolygon';\n      break;\n  }\n  return arcgisGeometryType;\n}\nexport function calcAttributionWidth(map) {\n  // either crop at 55px or user defined buffer\n  return map.getSize().x - options.attributionWidthOffset + 'px';\n}\nexport function setEsriAttribution(map) {\n  if (!map.attributionControl) {\n    return;\n  }\n  if (!map.attributionControl._esriAttributionLayerCount) {\n    map.attributionControl._esriAttributionLayerCount = 0;\n  }\n  if (map.attributionControl._esriAttributionLayerCount === 0) {\n    // Dynamically creating the CSS rules, only run this once per page load:\n    if (!map.attributionControl._esriAttributionAddedOnce) {\n      var hoverAttributionStyle = document.createElement('style');\n      hoverAttributionStyle.type = 'text/css';\n      hoverAttributionStyle.innerHTML = '.esri-truncated-attribution:hover {' + 'white-space: normal;' + '}';\n      document.getElementsByTagName('head')[0].appendChild(hoverAttributionStyle);\n\n      // define a new css class in JS to trim attribution into a single line\n      var attributionStyle = document.createElement('style');\n      attributionStyle.type = 'text/css';\n      attributionStyle.innerHTML = '.esri-truncated-attribution {' + 'vertical-align: -3px;' + 'white-space: nowrap;' + 'overflow: hidden;' + 'text-overflow: ellipsis;' + 'display: inline-block;' + 'transition: 0s white-space;' + 'transition-delay: 1s;' + 'max-width: ' + calcAttributionWidth(map) + ';' + '}';\n      document.getElementsByTagName('head')[0].appendChild(attributionStyle);\n\n      // update the width used to truncate when the map itself is resized\n      map.on('resize', function (e) {\n        if (map.attributionControl) {\n          map.attributionControl._container.style.maxWidth = calcAttributionWidth(e.target);\n        }\n      });\n      map.attributionControl._esriAttributionAddedOnce = true;\n    }\n    map.attributionControl.setPrefix(BASE_LEAFLET_ATTRIBUTION_STRING + ' | ' + POWERED_BY_ESRI_ATTRIBUTION_STRING);\n    DomUtil.addClass(map.attributionControl._container, 'esri-truncated-attribution:hover');\n    DomUtil.addClass(map.attributionControl._container, 'esri-truncated-attribution');\n  }\n\n  // Track the number of esri-leaflet layers that are on the map so we can know when we can remove the attribution (below in removeEsriAttribution)\n  map.attributionControl._esriAttributionLayerCount = map.attributionControl._esriAttributionLayerCount + 1;\n}\nexport function removeEsriAttribution(map) {\n  if (!map.attributionControl) {\n    return;\n  }\n\n  // Only remove the attribution if we're about to remove the LAST esri-leaflet layer (_esriAttributionLayerCount)\n  if (map.attributionControl._esriAttributionLayerCount && map.attributionControl._esriAttributionLayerCount === 1) {\n    map.attributionControl.setPrefix(BASE_LEAFLET_ATTRIBUTION_STRING);\n    DomUtil.removeClass(map.attributionControl._container, 'esri-truncated-attribution:hover');\n    DomUtil.removeClass(map.attributionControl._container, 'esri-truncated-attribution');\n  }\n  map.attributionControl._esriAttributionLayerCount = map.attributionControl._esriAttributionLayerCount - 1;\n}\nexport function _setGeometry(geometry) {\n  var params = {\n    geometry: null,\n    geometryType: null\n  };\n\n  // convert bounds to extent and finish\n  if (geometry instanceof LatLngBounds) {\n    // set geometry + geometryType\n    params.geometry = boundsToExtent(geometry);\n    params.geometryType = 'esriGeometryEnvelope';\n    return params;\n  }\n\n  // convert L.Marker > L.LatLng\n  if (geometry.getLatLng) {\n    geometry = geometry.getLatLng();\n  }\n\n  // convert L.LatLng to a geojson point and continue;\n  if (geometry instanceof LatLng) {\n    geometry = {\n      type: 'Point',\n      coordinates: [geometry.lng, geometry.lat]\n    };\n  }\n\n  // handle L.GeoJSON, pull out the first geometry\n  if (geometry instanceof GeoJSON) {\n    // reassign geometry to the GeoJSON value  (we are assuming that only one feature is present)\n    geometry = geometry.getLayers()[0].feature.geometry;\n    params.geometry = geojsonToArcGIS(geometry);\n    params.geometryType = geojsonTypeToArcGIS(geometry.type);\n  }\n\n  // Handle L.Polyline and L.Polygon\n  if (geometry.toGeoJSON) {\n    geometry = geometry.toGeoJSON();\n  }\n\n  // handle GeoJSON feature by pulling out the geometry\n  if (geometry.type === 'Feature') {\n    // get the geometry of the geojson feature\n    geometry = geometry.geometry;\n  }\n\n  // confirm that our GeoJSON is a point, line or polygon\n  if (geometry.type === 'Point' || geometry.type === 'LineString' || geometry.type === 'Polygon' || geometry.type === 'MultiPolygon') {\n    params.geometry = geojsonToArcGIS(geometry);\n    params.geometryType = geojsonTypeToArcGIS(geometry.type);\n    return params;\n  }\n\n  // warn the user if we havn't found an appropriate object\n  warn('invalid geometry passed to spatial query. Should be L.LatLng, L.LatLngBounds, L.Marker or a GeoJSON Point, Line, Polygon or MultiPolygon object');\n}\nexport function _getAttributionData(url, map) {\n  if (Support.cors) {\n    request(url, {}, Util.bind(function (error, attributions) {\n      if (error) {\n        return;\n      }\n      map._esriAttributions = [];\n      for (var c = 0; c < attributions.contributors.length; c++) {\n        var contributor = attributions.contributors[c];\n        for (var i = 0; i < contributor.coverageAreas.length; i++) {\n          var coverageArea = contributor.coverageAreas[i];\n          var southWest = latLng(coverageArea.bbox[0], coverageArea.bbox[1]);\n          var northEast = latLng(coverageArea.bbox[2], coverageArea.bbox[3]);\n          map._esriAttributions.push({\n            attribution: contributor.attribution,\n            score: coverageArea.score,\n            bounds: latLngBounds(southWest, northEast),\n            minZoom: coverageArea.zoomMin,\n            maxZoom: coverageArea.zoomMax\n          });\n        }\n      }\n      map._esriAttributions.sort(function (a, b) {\n        return b.score - a.score;\n      });\n\n      // pass the same argument as the map's 'moveend' event\n      var obj = {\n        target: map\n      };\n      _updateMapAttribution(obj);\n    }, this));\n  }\n}\nexport function _updateMapAttribution(evt) {\n  var map = evt.target;\n  var oldAttributions = map._esriAttributions;\n  if (!map || !map.attributionControl) return;\n  var attributionElement = map.attributionControl._container.querySelector('.esri-dynamic-attribution');\n  if (attributionElement && oldAttributions) {\n    var newAttributions = '';\n    var bounds = map.getBounds();\n    var wrappedBounds = latLngBounds(bounds.getSouthWest().wrap(), bounds.getNorthEast().wrap());\n    var zoom = map.getZoom();\n    for (var i = 0; i < oldAttributions.length; i++) {\n      var attribution = oldAttributions[i];\n      var text = attribution.attribution;\n      if (!newAttributions.match(text) && attribution.bounds.intersects(wrappedBounds) && zoom >= attribution.minZoom && zoom <= attribution.maxZoom) {\n        newAttributions += ', ' + text;\n      }\n    }\n    newAttributions = newAttributions.substr(2);\n    attributionElement.innerHTML = newAttributions;\n    attributionElement.style.maxWidth = calcAttributionWidth(map);\n    map.fire('attributionupdated', {\n      attribution: newAttributions\n    });\n  }\n}\n\n// for backwards compatibility\nexport { warn };\nexport var EsriUtil = {\n  warn: warn,\n  cleanUrl: cleanUrl,\n  getUrlParams: getUrlParams,\n  isArcgisOnline: isArcgisOnline,\n  geojsonTypeToArcGIS: geojsonTypeToArcGIS,\n  responseToFeatureCollection: responseToFeatureCollection,\n  geojsonToArcGIS: geojsonToArcGIS,\n  arcgisToGeoJSON: arcgisToGeoJSON,\n  boundsToExtent: boundsToExtent,\n  extentToBounds: extentToBounds,\n  calcAttributionWidth: calcAttributionWidth,\n  setEsriAttribution: setEsriAttribution,\n  _setGeometry: _setGeometry,\n  _getAttributionData: _getAttributionData,\n  _updateMapAttribution: _updateMapAttribution,\n  _findIdAttributeFromFeature: _findIdAttributeFromFeature,\n  _findIdAttributeFromResponse: _findIdAttributeFromResponse\n};\nexport default EsriUtil;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}