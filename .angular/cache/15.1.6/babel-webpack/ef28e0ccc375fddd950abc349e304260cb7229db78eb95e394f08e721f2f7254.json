{"ast":null,"code":"import { GeometryTypes } from '../types/geometry-types.enum';\nimport { DrawingInfoType } from '../types/mapserver/layerinfo-response/layer-info.model';\nimport * as i0 from \"@angular/core\";\nexport let LayerService = /*#__PURE__*/(() => {\n  class LayerService {\n    constructor() {}\n    // get specific layer from info and legend\n    getLayerFromLayerInfo(layerInfo, legend) {\n      const layerLegend = legend.layers.find(x => x.layerId === layerInfo.id);\n      if (!layerLegend) {\n        throw new Error(`Could not retrieve legend info for layer with id: ${layerInfo.id}`);\n      }\n      const layer = {\n        id: layerInfo.id,\n        name: layerInfo.name,\n        visible: layerInfo.defaultVisibility,\n        layers: [],\n        legend: layerLegend.legend,\n        styleField: layerInfo.drawingInfo.renderer.field1,\n        geometryType: layerInfo.geometryType\n      };\n      if (layerInfo.geometryType !== GeometryTypes.esriGeometryPoint) {\n        switch (layerInfo.drawingInfo.renderer.type) {\n          case DrawingInfoType.UNIQUEVALUE:\n            layer.colors = layerInfo.drawingInfo.renderer.uniqueValueInfos.map(uniqueValue => {\n              return this.layerSymbolInfoToLayerColor(uniqueValue.symbol, layerInfo.geometryType, uniqueValue.value);\n            });\n            break;\n          case DrawingInfoType.SIMPLE:\n            const color = this.layerSymbolInfoToLayerColor(layerInfo.drawingInfo.renderer.symbol, layerInfo.geometryType, null);\n            layer.colors = [color];\n            break;\n          default:\n            break;\n        }\n      }\n      return layer;\n    }\n    // filter multiple layers by id\n    buildSupportingLayersFromInfoAndLegend(info, legend, layerIds, visible) {\n      // get selected layers from info\n      let selectedLayers = info.layers.filter(layer => layerIds.includes(layer.id));\n      let layers = [];\n      selectedLayers.forEach(selectedLayer => {\n        const layer = this.buildLayerFromInfoAndLegend(selectedLayer, legend.layers, visible);\n        layer.layers = this.buildChildLayer(layer.id, info.layers, legend.layers, visible);\n        layers.push(layer);\n      });\n      layers = this.buildLayerTree(layers, info.layers, legend, visible);\n      return layers;\n    }\n    /* Fetch visible layerids of layer object */\n    getVisibleLayerIds(layers) {\n      let visibleLayerIds = [];\n      layers.filter(x => x.visible).forEach(layer => {\n        // Only return id if there are no sublayers, otherwise if parent id is returned, all sub layers will be shown\n        if (layer.layers.length === 0) {\n          visibleLayerIds.push(layer.id);\n        } else {\n          visibleLayerIds = [...visibleLayerIds, ...this.getVisibleLayerIds(layer.layers)];\n        }\n      });\n      return visibleLayerIds;\n    }\n    /* Convert layerSymbonInfo (ARCGIS) to layercolor object */\n    layerSymbolInfoToLayerColor(symbolInfo, geometryType, uniqueValue) {\n      let fillColor = '';\n      let color = '';\n      let fill = false;\n      let weight = 1;\n      switch (geometryType) {\n        case GeometryTypes.esriGeometryPolyline:\n          color = this.RGBToHex(symbolInfo.color[0], symbolInfo.color[1], symbolInfo.color[2]);\n          weight = symbolInfo.width;\n          break;\n        case GeometryTypes.esriGeometryPolygon:\n          if (symbolInfo.color) {\n            fillColor = this.RGBToHex(symbolInfo.color[0], symbolInfo.color[1], symbolInfo.color[2]);\n            fill = symbolInfo.color[3] > 0;\n          }\n          color = this.RGBToHex(symbolInfo.outline.color[0], symbolInfo.outline.color[1], symbolInfo.outline.color[2]);\n          weight = symbolInfo.outline.width;\n          break;\n      }\n      return {\n        value: uniqueValue,\n        weight,\n        color,\n        fillColor,\n        fill\n      };\n    }\n    buildLayerTree(layers, layersInfo, legend, visible) {\n      let layerTree = [];\n      layers.forEach(layer => {\n        const layerInfo = layersInfo.find(x => x.id === layer.id);\n        if (layerInfo && layerInfo.parentLayerId !== -1) {\n          //check if parent layer already present in layer array, add it to layer\n          const parentLayer = layerTree.find(x => x.id === layerInfo.parentLayerId);\n          if (parentLayer) {\n            //check if layer already exists in parentlayern if not add layer\n            if (!parentLayer.layers.some(l => l.id === layer.id)) {\n              parentLayer.layers.push(layer);\n            }\n          } else {\n            //if parent layer does not exists add new parent layer and add it to layertree\n            const parentLayerInfo = layersInfo.find(x => x.id === layerInfo.parentLayerId);\n            if (parentLayerInfo) {\n              const newParentLayer = this.buildLayerFromInfoAndLegend(parentLayerInfo, legend.layers, visible);\n              newParentLayer.layers = [layer];\n              layerTree.push(newParentLayer);\n            }\n          }\n        } else {\n          layerTree.push(layer);\n        }\n      });\n      // if there are still layers with parent repeat this function\n      if (layersInfo.filter(x => layerTree.map(x => x.id).includes(x.id) && x.parentLayerId !== -1).length > 0) {\n        layerTree = this.buildLayerTree(layerTree, layersInfo, legend, visible);\n      }\n      return layerTree;\n    }\n    buildLayerFromInfoAndLegend(info, legend, visible) {\n      let layer;\n      if (info) {\n        layer = {\n          id: info.id,\n          name: info.name,\n          visible: this.determineLayerVisibility(info.id, info.defaultVisibility, visible),\n          layers: []\n        };\n        const layerLegend = legend.filter(x => x.layerId === layer.id);\n        if (layerLegend.length === 1) {\n          layer.legend = layerLegend[0].legend;\n        }\n      }\n      return layer;\n    }\n    determineLayerVisibility(layerId, defaultVisibility, visible) {\n      if (visible != null) {\n        if (typeof visible === 'boolean') {\n          return visible;\n        }\n        return visible.includes(layerId);\n      }\n      return defaultVisibility;\n    }\n    buildChildLayer(parentLayerId, layers, layerLegend, visible) {\n      const childLayers = [];\n      layers.filter(x => x.parentLayerId === parentLayerId).forEach(childLayer => {\n        const layer = this.buildLayerFromInfoAndLegend(childLayer, layerLegend, visible);\n        if (layers.filter(x => x.parentLayerId === childLayer.id).length > 0) {\n          layer.layers = this.buildChildLayer(childLayer.id, layers, layerLegend, visible);\n        }\n        childLayers.push(layer);\n      });\n      return childLayers;\n    }\n    RGBToHex(red, green, blue) {\n      return `#${this.ColorToHex(red)}${this.ColorToHex(green)}${this.ColorToHex(blue)}`;\n    }\n    ColorToHex(color) {\n      const hex = color.toString(16);\n      return hex.length === 1 ? '0' + hex : hex;\n    }\n  }\n  LayerService.ɵfac = function LayerService_Factory(t) {\n    return new (t || LayerService)();\n  };\n  LayerService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: LayerService,\n    factory: LayerService.ɵfac\n  });\n  return LayerService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}