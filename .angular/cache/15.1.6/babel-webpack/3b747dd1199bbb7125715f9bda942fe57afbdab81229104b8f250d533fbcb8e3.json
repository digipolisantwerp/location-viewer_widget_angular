{"ast":null,"code":"import { setOptions, GeoJSON, markerClusterGroup } from 'leaflet';\nimport { FeatureManager } from 'esri-leaflet';\nimport packageInfo from '../package.json';\nvar version = packageInfo.version;\nexport { version as VERSION };\nexport var FeatureLayer = FeatureManager.extend({\n  statics: {\n    EVENTS: 'click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose',\n    CLUSTEREVENTS: 'clusterclick clusterdblclick clustermouseover clustermouseout clustermousemove clustercontextmenu'\n  },\n  /**\r\n   * Constructor\r\n   */\n\n  initialize: function (options) {\n    FeatureManager.prototype.initialize.call(this, options);\n    options = setOptions(this, options);\n    this._layers = {};\n    this._leafletIds = {};\n    this.cluster = markerClusterGroup(options);\n    this._key = 'c' + (Math.random() * 1e9).toString(36).replace('.', '_');\n    this.cluster.addEventParent(this);\n  },\n  /**\r\n   * Layer Interface\r\n   */\n\n  onAdd: function (map) {\n    FeatureManager.prototype.onAdd.call(this, map);\n    this._map.addLayer(this.cluster);\n  },\n  onRemove: function (map) {\n    FeatureManager.prototype.onRemove.call(this, map);\n    this._map.removeLayer(this.cluster);\n  },\n  /**\r\n   * Feature Management Methods\r\n   */\n\n  createNewLayer: function (geojson) {\n    var layer = GeoJSON.geometryToLayer(geojson, this.options);\n    // trap for GeoJSON without geometry\n    if (layer) {\n      layer.defaultOptions = layer.options;\n    }\n    return layer;\n  },\n  createLayers: function (features) {\n    var markers = [];\n    for (var i = features.length - 1; i >= 0; i--) {\n      var geojson = features[i];\n      var layer = this._layers[geojson.id];\n      if (!layer) {\n        layer = this.createNewLayer(geojson);\n        layer.feature = GeoJSON.asFeature(geojson);\n        layer.defaultOptions = layer.options;\n        layer._leaflet_id = this._key + '_' + geojson.id;\n        this.resetStyle(layer.feature.id);\n\n        // cache the layer\n        this._layers[layer.feature.id] = layer;\n        this._leafletIds[layer._leaflet_id] = geojson.id;\n        if (this.options.onEachFeature) {\n          this.options.onEachFeature(layer.feature, layer);\n        }\n        this.fire('createfeature', {\n          feature: layer.feature\n        });\n      }\n\n      // add the layer if it is within the time bounds or our layer is not time enabled\n      if (!this.options.timeField || this.options.timeField && this._featureWithinTimeRange(geojson)) {\n        markers.push(layer);\n      }\n    }\n    if (markers.length) {\n      this.cluster.addLayers(markers);\n    }\n  },\n  addLayers: function (ids) {\n    var layersToAdd = [];\n    for (var i = ids.length - 1; i >= 0; i--) {\n      var layer = this._layers[ids[i]];\n      this.fire('addfeature', {\n        feature: layer.feature\n      });\n      layersToAdd.push(layer);\n    }\n    this.cluster.addLayers(layersToAdd);\n  },\n  removeLayers: function (ids, permanent) {\n    var layersToRemove = [];\n    for (var i = ids.length - 1; i >= 0; i--) {\n      var id = ids[i];\n      var layer = this._layers[id];\n      this.fire('removefeature', {\n        feature: layer.feature,\n        permanent: permanent\n      });\n      layersToRemove.push(layer);\n      if (this._layers[id] && permanent) {\n        delete this._layers[id];\n      }\n    }\n    this.cluster.removeLayers(layersToRemove);\n  },\n  /**\r\n   * Styling Methods\r\n   */\n\n  resetStyle: function (id) {\n    var layer = this._layers[id];\n    if (layer) {\n      layer.options = layer.defaultOptions;\n      this.setFeatureStyle(layer.feature.id, this.options.style);\n    }\n    return this;\n  },\n  setStyle: function (style) {\n    this.eachFeature(function (layer) {\n      this.setFeatureStyle(layer.feature.id, style);\n    }, this);\n    return this;\n  },\n  setFeatureStyle: function (id, style) {\n    var layer = this._layers[id];\n    if (typeof style === 'function') {\n      style = style(layer.feature);\n    }\n    if (layer.setStyle) {\n      layer.setStyle(style);\n    }\n  },\n  /**\r\n   * Utility Methods\r\n   */\n\n  eachFeature: function (fn, context) {\n    for (var i in this._layers) {\n      fn.call(context, this._layers[i]);\n    }\n    return this;\n  },\n  getFeature: function (id) {\n    return this._layers[id];\n  },\n  // This is the same as the Layer.openPopup method except it excludes the `FeatureGroup`\n  // logic to work around https://github.com/Leaflet/Leaflet/issues/8761\n  openPopup(latlng) {\n    if (this._popup) {\n      if (this._popup._prepareOpen(latlng || this._latlng)) {\n        // open the popup on the map\n        this._popup.openOn(this._map);\n      }\n    }\n    return this;\n  },\n  // This is the same as the `Layer.openTooltip` method except it excludes the `FeatureGroup`\n  // logic to work around https://github.com/Leaflet/Leaflet/issues/8761\n  openTooltip(latlng) {\n    if (this._tooltip) {\n      if (this._tooltip._prepareOpen(latlng)) {\n        // open the tooltip on the map\n        this._tooltip.openOn(this._map);\n        if (this.getElement) {\n          this._setAriaDescribedByOnLayer(this);\n        } else if (this.eachLayer) {\n          this.eachLayer(this._setAriaDescribedByOnLayer, this);\n        }\n      }\n    }\n    return this;\n  }\n});\nexport function featureLayer(options) {\n  return new FeatureLayer(options);\n}\nexport default featureLayer;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}