{"ast":null,"code":"(() => {\n  var t = {\n      9705: (t, e, i) => {\n        \"use strict\";\n\n        var n = i(1540);\n        function r(t) {\n          var e = [Infinity, Infinity, -Infinity, -Infinity];\n          return n.coordEach(t, function (t) {\n            e[0] > t[0] && (e[0] = t[0]), e[1] > t[1] && (e[1] = t[1]), e[2] < t[0] && (e[2] = t[0]), e[3] < t[1] && (e[3] = t[1]);\n          }), e;\n        }\n        r[\"default\"] = r, e.Z = r;\n      },\n      4102: (t, e) => {\n        \"use strict\";\n\n        function i(t, e, i) {\n          void 0 === i && (i = {});\n          var n = {\n            type: \"Feature\"\n          };\n          return (0 === i.id || i.id) && (n.id = i.id), i.bbox && (n.bbox = i.bbox), n.properties = e || {}, n.geometry = t, n;\n        }\n        function n(t, e, n) {\n          if (void 0 === n && (n = {}), !t) throw new Error(\"coordinates is required\");\n          if (!Array.isArray(t)) throw new Error(\"coordinates must be an Array\");\n          if (t.length < 2) throw new Error(\"coordinates must be at least 2 numbers long\");\n          if (!d(t[0]) || !d(t[1])) throw new Error(\"coordinates must contain numbers\");\n          return i({\n            type: \"Point\",\n            coordinates: t\n          }, e, n);\n        }\n        function r(t, e, n) {\n          void 0 === n && (n = {});\n          for (var r = 0, a = t; r < a.length; r++) {\n            var o = a[r];\n            if (o.length < 4) throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n            for (var s = 0; s < o[o.length - 1].length; s++) if (o[o.length - 1][s] !== o[0][s]) throw new Error(\"First and last Position are not equivalent.\");\n          }\n          return i({\n            type: \"Polygon\",\n            coordinates: t\n          }, e, n);\n        }\n        function a(t, e, n) {\n          if (void 0 === n && (n = {}), t.length < 2) throw new Error(\"coordinates must be an array of two or more positions\");\n          return i({\n            type: \"LineString\",\n            coordinates: t\n          }, e, n);\n        }\n        function o(t, e) {\n          void 0 === e && (e = {});\n          var i = {\n            type: \"FeatureCollection\"\n          };\n          return e.id && (i.id = e.id), e.bbox && (i.bbox = e.bbox), i.features = t, i;\n        }\n        function s(t, e, n) {\n          return void 0 === n && (n = {}), i({\n            type: \"MultiLineString\",\n            coordinates: t\n          }, e, n);\n        }\n        function l(t, e, n) {\n          return void 0 === n && (n = {}), i({\n            type: \"MultiPoint\",\n            coordinates: t\n          }, e, n);\n        }\n        function h(t, e, n) {\n          return void 0 === n && (n = {}), i({\n            type: \"MultiPolygon\",\n            coordinates: t\n          }, e, n);\n        }\n        function u(t, i) {\n          void 0 === i && (i = \"kilometers\");\n          var n = e.factors[i];\n          if (!n) throw new Error(i + \" units is invalid\");\n          return t * n;\n        }\n        function c(t, i) {\n          void 0 === i && (i = \"kilometers\");\n          var n = e.factors[i];\n          if (!n) throw new Error(i + \" units is invalid\");\n          return t / n;\n        }\n        function p(t) {\n          return 180 * (t % (2 * Math.PI)) / Math.PI;\n        }\n        function d(t) {\n          return !isNaN(t) && null !== t && !Array.isArray(t);\n        }\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.earthRadius = 6371008.8, e.factors = {\n          centimeters: 100 * e.earthRadius,\n          centimetres: 100 * e.earthRadius,\n          degrees: e.earthRadius / 111325,\n          feet: 3.28084 * e.earthRadius,\n          inches: 39.37 * e.earthRadius,\n          kilometers: e.earthRadius / 1e3,\n          kilometres: e.earthRadius / 1e3,\n          meters: e.earthRadius,\n          metres: e.earthRadius,\n          miles: e.earthRadius / 1609.344,\n          millimeters: 1e3 * e.earthRadius,\n          millimetres: 1e3 * e.earthRadius,\n          nauticalmiles: e.earthRadius / 1852,\n          radians: 1,\n          yards: 1.0936 * e.earthRadius\n        }, e.unitsFactors = {\n          centimeters: 100,\n          centimetres: 100,\n          degrees: 1 / 111325,\n          feet: 3.28084,\n          inches: 39.37,\n          kilometers: .001,\n          kilometres: .001,\n          meters: 1,\n          metres: 1,\n          miles: 1 / 1609.344,\n          millimeters: 1e3,\n          millimetres: 1e3,\n          nauticalmiles: 1 / 1852,\n          radians: 1 / e.earthRadius,\n          yards: 1.0936133\n        }, e.areaFactors = {\n          acres: 247105e-9,\n          centimeters: 1e4,\n          centimetres: 1e4,\n          feet: 10.763910417,\n          hectares: 1e-4,\n          inches: 1550.003100006,\n          kilometers: 1e-6,\n          kilometres: 1e-6,\n          meters: 1,\n          metres: 1,\n          miles: 386e-9,\n          millimeters: 1e6,\n          millimetres: 1e6,\n          yards: 1.195990046\n        }, e.feature = i, e.geometry = function (t, e, i) {\n          switch (void 0 === i && (i = {}), t) {\n            case \"Point\":\n              return n(e).geometry;\n            case \"LineString\":\n              return a(e).geometry;\n            case \"Polygon\":\n              return r(e).geometry;\n            case \"MultiPoint\":\n              return l(e).geometry;\n            case \"MultiLineString\":\n              return s(e).geometry;\n            case \"MultiPolygon\":\n              return h(e).geometry;\n            default:\n              throw new Error(t + \" is invalid\");\n          }\n        }, e.point = n, e.points = function (t, e, i) {\n          return void 0 === i && (i = {}), o(t.map(function (t) {\n            return n(t, e);\n          }), i);\n        }, e.polygon = r, e.polygons = function (t, e, i) {\n          return void 0 === i && (i = {}), o(t.map(function (t) {\n            return r(t, e);\n          }), i);\n        }, e.lineString = a, e.lineStrings = function (t, e, i) {\n          return void 0 === i && (i = {}), o(t.map(function (t) {\n            return a(t, e);\n          }), i);\n        }, e.featureCollection = o, e.multiLineString = s, e.multiPoint = l, e.multiPolygon = h, e.geometryCollection = function (t, e, n) {\n          return void 0 === n && (n = {}), i({\n            type: \"GeometryCollection\",\n            geometries: t\n          }, e, n);\n        }, e.round = function (t, e) {\n          if (void 0 === e && (e = 0), e && !(e >= 0)) throw new Error(\"precision must be a positive number\");\n          var i = Math.pow(10, e || 0);\n          return Math.round(t * i) / i;\n        }, e.radiansToLength = u, e.lengthToRadians = c, e.lengthToDegrees = function (t, e) {\n          return p(c(t, e));\n        }, e.bearingToAzimuth = function (t) {\n          var e = t % 360;\n          return e < 0 && (e += 360), e;\n        }, e.radiansToDegrees = p, e.degreesToRadians = function (t) {\n          return t % 360 * Math.PI / 180;\n        }, e.convertLength = function (t, e, i) {\n          if (void 0 === e && (e = \"kilometers\"), void 0 === i && (i = \"kilometers\"), !(t >= 0)) throw new Error(\"length must be a positive number\");\n          return u(c(t, e), i);\n        }, e.convertArea = function (t, i, n) {\n          if (void 0 === i && (i = \"meters\"), void 0 === n && (n = \"kilometers\"), !(t >= 0)) throw new Error(\"area must be a positive number\");\n          var r = e.areaFactors[i];\n          if (!r) throw new Error(\"invalid original units\");\n          var a = e.areaFactors[n];\n          if (!a) throw new Error(\"invalid final units\");\n          return t / r * a;\n        }, e.isNumber = d, e.isObject = function (t) {\n          return !!t && t.constructor === Object;\n        }, e.validateBBox = function (t) {\n          if (!t) throw new Error(\"bbox is required\");\n          if (!Array.isArray(t)) throw new Error(\"bbox must be an Array\");\n          if (4 !== t.length && 6 !== t.length) throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n          t.forEach(function (t) {\n            if (!d(t)) throw new Error(\"bbox must only contain numbers\");\n          });\n        }, e.validateId = function (t) {\n          if (!t) throw new Error(\"id is required\");\n          if (-1 === [\"string\", \"number\"].indexOf(typeof t)) throw new Error(\"id must be a number or a string\");\n        };\n      },\n      1540: (t, e, i) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n        var n = i(4102);\n        function r(t, e, i) {\n          if (null !== t) for (var n, a, o, s, l, h, u, c, p = 0, d = 0, f = t.type, g = \"FeatureCollection\" === f, _ = \"Feature\" === f, m = g ? t.features.length : 1, y = 0; y < m; y++) {\n            l = (c = !!(u = g ? t.features[y].geometry : _ ? t.geometry : t) && \"GeometryCollection\" === u.type) ? u.geometries.length : 1;\n            for (var v = 0; v < l; v++) {\n              var L = 0,\n                b = 0;\n              if (null !== (s = c ? u.geometries[v] : u)) {\n                h = s.coordinates;\n                var k = s.type;\n                switch (p = !i || \"Polygon\" !== k && \"MultiPolygon\" !== k ? 0 : 1, k) {\n                  case null:\n                    break;\n                  case \"Point\":\n                    if (!1 === e(h, d, y, L, b)) return !1;\n                    d++, L++;\n                    break;\n                  case \"LineString\":\n                  case \"MultiPoint\":\n                    for (n = 0; n < h.length; n++) {\n                      if (!1 === e(h[n], d, y, L, b)) return !1;\n                      d++, \"MultiPoint\" === k && L++;\n                    }\n                    \"LineString\" === k && L++;\n                    break;\n                  case \"Polygon\":\n                  case \"MultiLineString\":\n                    for (n = 0; n < h.length; n++) {\n                      for (a = 0; a < h[n].length - p; a++) {\n                        if (!1 === e(h[n][a], d, y, L, b)) return !1;\n                        d++;\n                      }\n                      \"MultiLineString\" === k && L++, \"Polygon\" === k && b++;\n                    }\n                    \"Polygon\" === k && L++;\n                    break;\n                  case \"MultiPolygon\":\n                    for (n = 0; n < h.length; n++) {\n                      for (b = 0, a = 0; a < h[n].length; a++) {\n                        for (o = 0; o < h[n][a].length - p; o++) {\n                          if (!1 === e(h[n][a][o], d, y, L, b)) return !1;\n                          d++;\n                        }\n                        b++;\n                      }\n                      L++;\n                    }\n                    break;\n                  case \"GeometryCollection\":\n                    for (n = 0; n < s.geometries.length; n++) if (!1 === r(s.geometries[n], e, i)) return !1;\n                    break;\n                  default:\n                    throw new Error(\"Unknown Geometry Type\");\n                }\n              }\n            }\n          }\n        }\n        function a(t, e) {\n          var i;\n          switch (t.type) {\n            case \"FeatureCollection\":\n              for (i = 0; i < t.features.length && !1 !== e(t.features[i].properties, i); i++);\n              break;\n            case \"Feature\":\n              e(t.properties, 0);\n          }\n        }\n        function o(t, e) {\n          if (\"Feature\" === t.type) e(t, 0);else if (\"FeatureCollection\" === t.type) for (var i = 0; i < t.features.length && !1 !== e(t.features[i], i); i++);\n        }\n        function s(t, e) {\n          var i,\n            n,\n            r,\n            a,\n            o,\n            s,\n            l,\n            h,\n            u,\n            c,\n            p = 0,\n            d = \"FeatureCollection\" === t.type,\n            f = \"Feature\" === t.type,\n            g = d ? t.features.length : 1;\n          for (i = 0; i < g; i++) {\n            for (s = d ? t.features[i].geometry : f ? t.geometry : t, h = d ? t.features[i].properties : f ? t.properties : {}, u = d ? t.features[i].bbox : f ? t.bbox : undefined, c = d ? t.features[i].id : f ? t.id : undefined, o = (l = !!s && \"GeometryCollection\" === s.type) ? s.geometries.length : 1, r = 0; r < o; r++) if (null !== (a = l ? s.geometries[r] : s)) switch (a.type) {\n              case \"Point\":\n              case \"LineString\":\n              case \"MultiPoint\":\n              case \"Polygon\":\n              case \"MultiLineString\":\n              case \"MultiPolygon\":\n                if (!1 === e(a, p, h, u, c)) return !1;\n                break;\n              case \"GeometryCollection\":\n                for (n = 0; n < a.geometries.length; n++) if (!1 === e(a.geometries[n], p, h, u, c)) return !1;\n                break;\n              default:\n                throw new Error(\"Unknown Geometry Type\");\n            } else if (!1 === e(null, p, h, u, c)) return !1;\n            p++;\n          }\n        }\n        function l(t, e) {\n          s(t, function (t, i, r, a, o) {\n            var s,\n              l = null === t ? null : t.type;\n            switch (l) {\n              case null:\n              case \"Point\":\n              case \"LineString\":\n              case \"Polygon\":\n                return !1 !== e(n.feature(t, r, {\n                  bbox: a,\n                  id: o\n                }), i, 0) && void 0;\n            }\n            switch (l) {\n              case \"MultiPoint\":\n                s = \"Point\";\n                break;\n              case \"MultiLineString\":\n                s = \"LineString\";\n                break;\n              case \"MultiPolygon\":\n                s = \"Polygon\";\n            }\n            for (var h = 0; h < t.coordinates.length; h++) {\n              var u = {\n                type: s,\n                coordinates: t.coordinates[h]\n              };\n              if (!1 === e(n.feature(u, r), i, h)) return !1;\n            }\n          });\n        }\n        function h(t, e) {\n          l(t, function (t, i, a) {\n            var o = 0;\n            if (t.geometry) {\n              var s = t.geometry.type;\n              if (\"Point\" !== s && \"MultiPoint\" !== s) {\n                var l,\n                  h = 0,\n                  u = 0,\n                  c = 0;\n                return !1 !== r(t, function (r, s, p, d, f) {\n                  if (l === undefined || i > h || d > u || f > c) return l = r, h = i, u = d, c = f, void (o = 0);\n                  var g = n.lineString([l, r], t.properties);\n                  if (!1 === e(g, i, a, f, o)) return !1;\n                  o++, l = r;\n                }) && void 0;\n              }\n            }\n          });\n        }\n        function u(t, e) {\n          if (!t) throw new Error(\"geojson is required\");\n          l(t, function (t, i, r) {\n            if (null !== t.geometry) {\n              var a = t.geometry.type,\n                o = t.geometry.coordinates;\n              switch (a) {\n                case \"LineString\":\n                  if (!1 === e(t, i, r, 0, 0)) return !1;\n                  break;\n                case \"Polygon\":\n                  for (var s = 0; s < o.length; s++) if (!1 === e(n.lineString(o[s], t.properties), i, r, s)) return !1;\n              }\n            }\n          });\n        }\n        e.coordAll = function (t) {\n          var e = [];\n          return r(t, function (t) {\n            e.push(t);\n          }), e;\n        }, e.coordEach = r, e.coordReduce = function (t, e, i, n) {\n          var a = i;\n          return r(t, function (t, n, r, o, s) {\n            a = 0 === n && i === undefined ? t : e(a, t, n, r, o, s);\n          }, n), a;\n        }, e.featureEach = o, e.featureReduce = function (t, e, i) {\n          var n = i;\n          return o(t, function (t, r) {\n            n = 0 === r && i === undefined ? t : e(n, t, r);\n          }), n;\n        }, e.findPoint = function (t, e) {\n          if (e = e || {}, !n.isObject(e)) throw new Error(\"options is invalid\");\n          var i,\n            r = e.featureIndex || 0,\n            a = e.multiFeatureIndex || 0,\n            o = e.geometryIndex || 0,\n            s = e.coordIndex || 0,\n            l = e.properties;\n          switch (t.type) {\n            case \"FeatureCollection\":\n              r < 0 && (r = t.features.length + r), l = l || t.features[r].properties, i = t.features[r].geometry;\n              break;\n            case \"Feature\":\n              l = l || t.properties, i = t.geometry;\n              break;\n            case \"Point\":\n            case \"MultiPoint\":\n              return null;\n            case \"LineString\":\n            case \"Polygon\":\n            case \"MultiLineString\":\n            case \"MultiPolygon\":\n              i = t;\n              break;\n            default:\n              throw new Error(\"geojson is invalid\");\n          }\n          if (null === i) return null;\n          var h = i.coordinates;\n          switch (i.type) {\n            case \"Point\":\n              return n.point(h, l, e);\n            case \"MultiPoint\":\n              return a < 0 && (a = h.length + a), n.point(h[a], l, e);\n            case \"LineString\":\n              return s < 0 && (s = h.length + s), n.point(h[s], l, e);\n            case \"Polygon\":\n              return o < 0 && (o = h.length + o), s < 0 && (s = h[o].length + s), n.point(h[o][s], l, e);\n            case \"MultiLineString\":\n              return a < 0 && (a = h.length + a), s < 0 && (s = h[a].length + s), n.point(h[a][s], l, e);\n            case \"MultiPolygon\":\n              return a < 0 && (a = h.length + a), o < 0 && (o = h[a].length + o), s < 0 && (s = h[a][o].length - s), n.point(h[a][o][s], l, e);\n          }\n          throw new Error(\"geojson is invalid\");\n        }, e.findSegment = function (t, e) {\n          if (e = e || {}, !n.isObject(e)) throw new Error(\"options is invalid\");\n          var i,\n            r = e.featureIndex || 0,\n            a = e.multiFeatureIndex || 0,\n            o = e.geometryIndex || 0,\n            s = e.segmentIndex || 0,\n            l = e.properties;\n          switch (t.type) {\n            case \"FeatureCollection\":\n              r < 0 && (r = t.features.length + r), l = l || t.features[r].properties, i = t.features[r].geometry;\n              break;\n            case \"Feature\":\n              l = l || t.properties, i = t.geometry;\n              break;\n            case \"Point\":\n            case \"MultiPoint\":\n              return null;\n            case \"LineString\":\n            case \"Polygon\":\n            case \"MultiLineString\":\n            case \"MultiPolygon\":\n              i = t;\n              break;\n            default:\n              throw new Error(\"geojson is invalid\");\n          }\n          if (null === i) return null;\n          var h = i.coordinates;\n          switch (i.type) {\n            case \"Point\":\n            case \"MultiPoint\":\n              return null;\n            case \"LineString\":\n              return s < 0 && (s = h.length + s - 1), n.lineString([h[s], h[s + 1]], l, e);\n            case \"Polygon\":\n              return o < 0 && (o = h.length + o), s < 0 && (s = h[o].length + s - 1), n.lineString([h[o][s], h[o][s + 1]], l, e);\n            case \"MultiLineString\":\n              return a < 0 && (a = h.length + a), s < 0 && (s = h[a].length + s - 1), n.lineString([h[a][s], h[a][s + 1]], l, e);\n            case \"MultiPolygon\":\n              return a < 0 && (a = h.length + a), o < 0 && (o = h[a].length + o), s < 0 && (s = h[a][o].length - s - 1), n.lineString([h[a][o][s], h[a][o][s + 1]], l, e);\n          }\n          throw new Error(\"geojson is invalid\");\n        }, e.flattenEach = l, e.flattenReduce = function (t, e, i) {\n          var n = i;\n          return l(t, function (t, r, a) {\n            n = 0 === r && 0 === a && i === undefined ? t : e(n, t, r, a);\n          }), n;\n        }, e.geomEach = s, e.geomReduce = function (t, e, i) {\n          var n = i;\n          return s(t, function (t, r, a, o, s) {\n            n = 0 === r && i === undefined ? t : e(n, t, r, a, o, s);\n          }), n;\n        }, e.lineEach = u, e.lineReduce = function (t, e, i) {\n          var n = i;\n          return u(t, function (t, r, a, o) {\n            n = 0 === r && i === undefined ? t : e(n, t, r, a, o);\n          }), n;\n        }, e.propEach = a, e.propReduce = function (t, e, i) {\n          var n = i;\n          return a(t, function (t, r) {\n            n = 0 === r && i === undefined ? t : e(n, t, r);\n          }), n;\n        }, e.segmentEach = h, e.segmentReduce = function (t, e, i) {\n          var n = i,\n            r = !1;\n          return h(t, function (t, a, o, s, l) {\n            n = !1 === r && i === undefined ? t : e(n, t, a, o, s, l), r = !0;\n          }), n;\n        };\n      },\n      5975: (t, e, i) => {\n        \"use strict\";\n\n        i(7107);\n        var n = i(2492),\n          r = i.n(n);\n        const a = JSON.parse('{\"tooltips\":{\"placeMarker\":\"Click to place marker\",\"firstVertex\":\"Click to place first vertex\",\"continueLine\":\"Click to continue drawing\",\"finishLine\":\"Click any existing marker to finish\",\"finishPoly\":\"Click first marker to finish\",\"finishRect\":\"Click to finish\",\"startCircle\":\"Click to place circle center\",\"finishCircle\":\"Click to finish circle\",\"placeCircleMarker\":\"Click to place circle marker\",\"placeText\":\"Click to place text\"},\"actions\":{\"finish\":\"Finish\",\"cancel\":\"Cancel\",\"removeLastVertex\":\"Remove Last Vertex\"},\"buttonTitles\":{\"drawMarkerButton\":\"Draw Marker\",\"drawPolyButton\":\"Draw Polygons\",\"drawLineButton\":\"Draw Polyline\",\"drawCircleButton\":\"Draw Circle\",\"drawRectButton\":\"Draw Rectangle\",\"editButton\":\"Edit Layers\",\"dragButton\":\"Drag Layers\",\"cutButton\":\"Cut Layers\",\"deleteButton\":\"Remove Layers\",\"drawCircleMarkerButton\":\"Draw Circle Marker\",\"snappingButton\":\"Snap dragged marker to other layers and vertices\",\"pinningButton\":\"Pin shared vertices together\",\"rotateButton\":\"Rotate Layers\",\"drawTextButton\":\"Draw Text\",\"scaleButton\":\"Scale Layers\",\"autoTracingButton\":\"Auto trace Line\"},\"measurements\":{\"totalLength\":\"Length\",\"segmentLength\":\"Segment length\",\"area\":\"Area\",\"radius\":\"Radius\",\"perimeter\":\"Perimeter\",\"height\":\"Height\",\"width\":\"Width\",\"coordinates\":\"Position\",\"coordinatesMarker\":\"Position Marker\"}}'),\n          o = JSON.parse('{\"tooltips\":{\"placeMarker\":\"Platziere den Marker mit Klick\",\"firstVertex\":\"Platziere den ersten Marker mit Klick\",\"continueLine\":\"Klicke, um weiter zu zeichnen\",\"finishLine\":\"Beende mit Klick auf existierenden Marker\",\"finishPoly\":\"Beende mit Klick auf ersten Marker\",\"finishRect\":\"Beende mit Klick\",\"startCircle\":\"Platziere das Kreiszentrum mit Klick\",\"finishCircle\":\"Beende den Kreis mit Klick\",\"placeCircleMarker\":\"Platziere den Kreismarker mit Klick\",\"placeText\":\"Platziere den Text mit Klick\"},\"actions\":{\"finish\":\"Beenden\",\"cancel\":\"Abbrechen\",\"removeLastVertex\":\"Letzten Vertex löschen\"},\"buttonTitles\":{\"drawMarkerButton\":\"Marker zeichnen\",\"drawPolyButton\":\"Polygon zeichnen\",\"drawLineButton\":\"Polyline zeichnen\",\"drawCircleButton\":\"Kreis zeichnen\",\"drawRectButton\":\"Rechteck zeichnen\",\"editButton\":\"Layer editieren\",\"dragButton\":\"Layer bewegen\",\"cutButton\":\"Layer schneiden\",\"deleteButton\":\"Layer löschen\",\"drawCircleMarkerButton\":\"Kreismarker zeichnen\",\"snappingButton\":\"Bewegter Layer an andere Layer oder Vertexe einhacken\",\"pinningButton\":\"Vertexe an der gleichen Position verknüpfen\",\"rotateButton\":\"Layer drehen\",\"drawTextButton\":\"Text zeichnen\",\"scaleButton\":\"Layer skalieren\",\"autoTracingButton\":\"Linie automatisch nachzeichen\"},\"measurements\":{\"totalLength\":\"Länge\",\"segmentLength\":\"Segment Länge\",\"area\":\"Fläche\",\"radius\":\"Radius\",\"perimeter\":\"Umfang\",\"height\":\"Höhe\",\"width\":\"Breite\",\"coordinates\":\"Position\",\"coordinatesMarker\":\"Position Marker\"}}'),\n          s = JSON.parse('{\"tooltips\":{\"placeMarker\":\"Clicca per posizionare un Marker\",\"firstVertex\":\"Clicca per posizionare il primo vertice\",\"continueLine\":\"Clicca per continuare a disegnare\",\"finishLine\":\"Clicca qualsiasi marker esistente per terminare\",\"finishPoly\":\"Clicca il primo marker per terminare\",\"finishRect\":\"Clicca per terminare\",\"startCircle\":\"Clicca per posizionare il punto centrale del cerchio\",\"finishCircle\":\"Clicca per terminare il cerchio\",\"placeCircleMarker\":\"Clicca per posizionare un Marker del cherchio\"},\"actions\":{\"finish\":\"Termina\",\"cancel\":\"Annulla\",\"removeLastVertex\":\"Rimuovi l\\'ultimo vertice\"},\"buttonTitles\":{\"drawMarkerButton\":\"Disegna Marker\",\"drawPolyButton\":\"Disegna Poligoni\",\"drawLineButton\":\"Disegna Polilinea\",\"drawCircleButton\":\"Disegna Cerchio\",\"drawRectButton\":\"Disegna Rettangolo\",\"editButton\":\"Modifica Livelli\",\"dragButton\":\"Sposta Livelli\",\"cutButton\":\"Ritaglia Livelli\",\"deleteButton\":\"Elimina Livelli\",\"drawCircleMarkerButton\":\"Disegna Marker del Cerchio\",\"snappingButton\":\"Snap ha trascinato il pennarello su altri strati e vertici\",\"pinningButton\":\"Pin condiviso vertici insieme\"}}'),\n          l = JSON.parse('{\"tooltips\":{\"placeMarker\":\"Klik untuk menempatkan marker\",\"firstVertex\":\"Klik untuk menempatkan vertex pertama\",\"continueLine\":\"Klik untuk meneruskan digitasi\",\"finishLine\":\"Klik pada sembarang marker yang ada untuk mengakhiri\",\"finishPoly\":\"Klik marker pertama untuk mengakhiri\",\"finishRect\":\"Klik untuk mengakhiri\",\"startCircle\":\"Klik untuk menempatkan titik pusat lingkaran\",\"finishCircle\":\"Klik untuk mengakhiri lingkaran\",\"placeCircleMarker\":\"Klik untuk menempatkan penanda lingkarann\"},\"actions\":{\"finish\":\"Selesai\",\"cancel\":\"Batal\",\"removeLastVertex\":\"Hilangkan Vertex Terakhir\"},\"buttonTitles\":{\"drawMarkerButton\":\"Digitasi Marker\",\"drawPolyButton\":\"Digitasi Polygon\",\"drawLineButton\":\"Digitasi Polyline\",\"drawCircleButton\":\"Digitasi Lingkaran\",\"drawRectButton\":\"Digitasi Segi Empat\",\"editButton\":\"Edit Layer\",\"dragButton\":\"Geser Layer\",\"cutButton\":\"Potong Layer\",\"deleteButton\":\"Hilangkan Layer\",\"drawCircleMarkerButton\":\"Digitasi Penanda Lingkaran\",\"snappingButton\":\"Jepretkan penanda yang ditarik ke lapisan dan simpul lain\",\"pinningButton\":\"Sematkan simpul bersama bersama\"}}'),\n          h = JSON.parse('{\"tooltips\":{\"placeMarker\":\"Adaugă un punct\",\"firstVertex\":\"Apasă aici pentru a adăuga primul Vertex\",\"continueLine\":\"Apasă aici pentru a continua desenul\",\"finishLine\":\"Apasă pe orice obiect pentru a finisa desenul\",\"finishPoly\":\"Apasă pe primul obiect pentru a finisa\",\"finishRect\":\"Apasă pentru a finisa\",\"startCircle\":\"Apasă pentru a desena un cerc\",\"finishCircle\":\"Apasă pentru a finisa un cerc\",\"placeCircleMarker\":\"Adaugă un punct\"},\"actions\":{\"finish\":\"Termină\",\"cancel\":\"Anulează\",\"removeLastVertex\":\"Șterge ultimul Vertex\"},\"buttonTitles\":{\"drawMarkerButton\":\"Adaugă o bulină\",\"drawPolyButton\":\"Desenează un poligon\",\"drawLineButton\":\"Desenează o linie\",\"drawCircleButton\":\"Desenează un cerc\",\"drawRectButton\":\"Desenează un dreptunghi\",\"editButton\":\"Editează straturile\",\"dragButton\":\"Mută straturile\",\"cutButton\":\"Taie straturile\",\"deleteButton\":\"Șterge straturile\",\"drawCircleMarkerButton\":\"Desenează marcatorul cercului\",\"snappingButton\":\"Fixați marcatorul glisat pe alte straturi și vârfuri\",\"pinningButton\":\"Fixați vârfurile partajate împreună\"}}'),\n          u = JSON.parse('{\"tooltips\":{\"placeMarker\":\"Нажмите, чтобы нанести маркер\",\"firstVertex\":\"Нажмите, чтобы нанести первый объект\",\"continueLine\":\"Нажмите, чтобы продолжить рисование\",\"finishLine\":\"Нажмите любой существующий маркер для завершения\",\"finishPoly\":\"Выберите первую точку, чтобы закончить\",\"finishRect\":\"Нажмите, чтобы закончить\",\"startCircle\":\"Нажмите, чтобы добавить центр круга\",\"finishCircle\":\"Нажмите, чтобы задать радиус\",\"placeCircleMarker\":\"Нажмите, чтобы нанести круговой маркер\"},\"actions\":{\"finish\":\"Завершить\",\"cancel\":\"Отменить\",\"removeLastVertex\":\"Отменить последнее действие\"},\"buttonTitles\":{\"drawMarkerButton\":\"Добавить маркер\",\"drawPolyButton\":\"Рисовать полигон\",\"drawLineButton\":\"Рисовать кривую\",\"drawCircleButton\":\"Рисовать круг\",\"drawRectButton\":\"Рисовать прямоугольник\",\"editButton\":\"Редактировать слой\",\"dragButton\":\"Перенести слой\",\"cutButton\":\"Вырезать слой\",\"deleteButton\":\"Удалить слой\",\"drawCircleMarkerButton\":\"Добавить круговой маркер\",\"snappingButton\":\"Привязать перетаскиваемый маркер к другим слоям и вершинам\",\"pinningButton\":\"Связать общие точки вместе\"}}'),\n          c = JSON.parse('{\"tooltips\":{\"placeMarker\":\"Presiona para colocar un marcador\",\"firstVertex\":\"Presiona para colocar el primer vértice\",\"continueLine\":\"Presiona para continuar dibujando\",\"finishLine\":\"Presiona cualquier marcador existente para finalizar\",\"finishPoly\":\"Presiona el primer marcador para finalizar\",\"finishRect\":\"Presiona para finalizar\",\"startCircle\":\"Presiona para colocar el centro del círculo\",\"finishCircle\":\"Presiona para finalizar el círculo\",\"placeCircleMarker\":\"Presiona para colocar un marcador de círculo\"},\"actions\":{\"finish\":\"Finalizar\",\"cancel\":\"Cancelar\",\"removeLastVertex\":\"Eliminar último vértice\"},\"buttonTitles\":{\"drawMarkerButton\":\"Dibujar Marcador\",\"drawPolyButton\":\"Dibujar Polígono\",\"drawLineButton\":\"Dibujar Línea\",\"drawCircleButton\":\"Dibujar Círculo\",\"drawRectButton\":\"Dibujar Rectángulo\",\"editButton\":\"Editar Capas\",\"dragButton\":\"Arrastrar Capas\",\"cutButton\":\"Cortar Capas\",\"deleteButton\":\"Eliminar Capas\",\"drawCircleMarkerButton\":\"Dibujar Marcador de Círculo\",\"snappingButton\":\"El marcador de Snap arrastrado a otras capas y vértices\",\"pinningButton\":\"Fijar juntos los vértices compartidos\"}}'),\n          p = JSON.parse('{\"tooltips\":{\"placeMarker\":\"Klik om een marker te plaatsen\",\"firstVertex\":\"Klik om het eerste punt te plaatsen\",\"continueLine\":\"Klik om te blijven tekenen\",\"finishLine\":\"Klik op een bestaand punt om te beëindigen\",\"finishPoly\":\"Klik op het eerst punt om te beëindigen\",\"finishRect\":\"Klik om te beëindigen\",\"startCircle\":\"Klik om het middelpunt te plaatsen\",\"finishCircle\":\"Klik om de cirkel te beëindigen\",\"placeCircleMarker\":\"Klik om een marker te plaatsen\"},\"actions\":{\"finish\":\"Bewaar\",\"cancel\":\"Annuleer\",\"removeLastVertex\":\"Verwijder laatste punt\"},\"buttonTitles\":{\"drawMarkerButton\":\"Plaats Marker\",\"drawPolyButton\":\"Teken een vlak\",\"drawLineButton\":\"Teken een lijn\",\"drawCircleButton\":\"Teken een cirkel\",\"drawRectButton\":\"Teken een vierkant\",\"editButton\":\"Bewerk\",\"dragButton\":\"Verplaats\",\"cutButton\":\"Knip\",\"deleteButton\":\"Verwijder\",\"drawCircleMarkerButton\":\"Plaats Marker\",\"snappingButton\":\"Snap gesleepte marker naar andere lagen en hoekpunten\",\"pinningButton\":\"Speld gedeelde hoekpunten samen\"}}'),\n          d = JSON.parse('{\"tooltips\":{\"placeMarker\":\"Cliquez pour placer un marqueur\",\"firstVertex\":\"Cliquez pour placer le premier sommet\",\"continueLine\":\"Cliquez pour continuer à dessiner\",\"finishLine\":\"Cliquez sur n\\'importe quel marqueur pour terminer\",\"finishPoly\":\"Cliquez sur le premier marqueur pour terminer\",\"finishRect\":\"Cliquez pour terminer\",\"startCircle\":\"Cliquez pour placer le centre du cercle\",\"finishCircle\":\"Cliquez pour finir le cercle\",\"placeCircleMarker\":\"Cliquez pour placer le marqueur circulaire\"},\"actions\":{\"finish\":\"Terminer\",\"cancel\":\"Annuler\",\"removeLastVertex\":\"Retirer le dernier sommet\"},\"buttonTitles\":{\"drawMarkerButton\":\"Placer des marqueurs\",\"drawPolyButton\":\"Dessiner des polygones\",\"drawLineButton\":\"Dessiner des polylignes\",\"drawCircleButton\":\"Dessiner un cercle\",\"drawRectButton\":\"Dessiner un rectangle\",\"editButton\":\"Éditer des calques\",\"dragButton\":\"Déplacer des calques\",\"cutButton\":\"Couper des calques\",\"deleteButton\":\"Supprimer des calques\",\"drawCircleMarkerButton\":\"Dessiner un marqueur circulaire\",\"snappingButton\":\"Glisser le marqueur vers d\\'autres couches et sommets\",\"pinningButton\":\"Épingler ensemble les sommets partagés\",\"rotateButton\":\"Tourner des calques\"}}'),\n          f = JSON.parse('{\"tooltips\":{\"placeMarker\":\"单击放置标记\",\"firstVertex\":\"单击放置首个顶点\",\"continueLine\":\"单击继续绘制\",\"finishLine\":\"单击任何存在的标记以完成\",\"finishPoly\":\"单击第一个标记以完成\",\"finishRect\":\"单击完成\",\"startCircle\":\"单击放置圆心\",\"finishCircle\":\"单击完成圆形\",\"placeCircleMarker\":\"点击放置圆形标记\"},\"actions\":{\"finish\":\"完成\",\"cancel\":\"取消\",\"removeLastVertex\":\"移除最后的顶点\"},\"buttonTitles\":{\"drawMarkerButton\":\"绘制标记\",\"drawPolyButton\":\"绘制多边形\",\"drawLineButton\":\"绘制线段\",\"drawCircleButton\":\"绘制圆形\",\"drawRectButton\":\"绘制长方形\",\"editButton\":\"编辑图层\",\"dragButton\":\"拖拽图层\",\"cutButton\":\"剪切图层\",\"deleteButton\":\"删除图层\",\"drawCircleMarkerButton\":\"画圆圈标记\",\"snappingButton\":\"将拖动的标记捕捉到其他图层和顶点\",\"pinningButton\":\"将共享顶点固定在一起\"}}'),\n          g = JSON.parse('{\"tooltips\":{\"placeMarker\":\"單擊放置標記\",\"firstVertex\":\"單擊放置第一個頂點\",\"continueLine\":\"單擊繼續繪製\",\"finishLine\":\"單擊任何存在的標記以完成\",\"finishPoly\":\"單擊第一個標記以完成\",\"finishRect\":\"單擊完成\",\"startCircle\":\"單擊放置圓心\",\"finishCircle\":\"單擊完成圓形\",\"placeCircleMarker\":\"點擊放置圓形標記\"},\"actions\":{\"finish\":\"完成\",\"cancel\":\"取消\",\"removeLastVertex\":\"移除最後一個頂點\"},\"buttonTitles\":{\"drawMarkerButton\":\"放置標記\",\"drawPolyButton\":\"繪製多邊形\",\"drawLineButton\":\"繪製線段\",\"drawCircleButton\":\"繪製圓形\",\"drawRectButton\":\"繪製方形\",\"editButton\":\"編輯圖形\",\"dragButton\":\"移動圖形\",\"cutButton\":\"裁切圖形\",\"deleteButton\":\"刪除圖形\",\"drawCircleMarkerButton\":\"畫圓圈標記\",\"snappingButton\":\"將拖動的標記對齊到其他圖層和頂點\",\"pinningButton\":\"將共享頂點固定在一起\"}}'),\n          _ = {\n            en: a,\n            de: o,\n            it: s,\n            id: l,\n            ro: h,\n            ru: u,\n            es: c,\n            nl: p,\n            fr: d,\n            pt_br: JSON.parse('{\"tooltips\":{\"placeMarker\":\"Clique para posicionar o marcador\",\"firstVertex\":\"Clique para posicionar o primeiro vértice\",\"continueLine\":\"Clique para continuar desenhando\",\"finishLine\":\"Clique em qualquer marcador existente para finalizar\",\"finishPoly\":\"Clique no primeiro ponto para fechar o polígono\",\"finishRect\":\"Clique para finalizar\",\"startCircle\":\"Clique para posicionar o centro do círculo\",\"finishCircle\":\"Clique para fechar o círculo\",\"placeCircleMarker\":\"Clique para posicionar o marcador circular\"},\"actions\":{\"finish\":\"Finalizar\",\"cancel\":\"Cancelar\",\"removeLastVertex\":\"Remover último vértice\"},\"buttonTitles\":{\"drawMarkerButton\":\"Desenhar um marcador\",\"drawPolyButton\":\"Desenhar um polígono\",\"drawLineButton\":\"Desenhar uma polilinha\",\"drawCircleButton\":\"Desenhar um círculo\",\"drawRectButton\":\"Desenhar um retângulo\",\"editButton\":\"Editar camada(s)\",\"dragButton\":\"Mover camada(s)\",\"cutButton\":\"Recortar camada(s)\",\"deleteButton\":\"Remover camada(s)\",\"drawCircleMarkerButton\":\"Marcador de círculos de desenho\",\"snappingButton\":\"Marcador arrastado para outras camadas e vértices\",\"pinningButton\":\"Vértices compartilhados de pinos juntos\"}}'),\n            zh: f,\n            zh_tw: g,\n            pl: JSON.parse('{\"tooltips\":{\"placeMarker\":\"Kliknij, aby ustawić znacznik\",\"firstVertex\":\"Kliknij, aby ustawić pierwszy punkt\",\"continueLine\":\"Kliknij, aby kontynuować rysowanie\",\"finishLine\":\"Kliknij dowolny punkt, aby zakończyć\",\"finishPoly\":\"Kliknij pierwszy punkt, aby zakończyć\",\"finishRect\":\"Kliknij, aby zakończyć\",\"startCircle\":\"Kliknij, aby ustawić środek koła\",\"finishCircle\":\"Kliknij, aby zakończyć rysowanie koła\",\"placeCircleMarker\":\"Kliknij, aby ustawić okrągły znacznik\"},\"actions\":{\"finish\":\"Zakończ\",\"cancel\":\"Anuluj\",\"removeLastVertex\":\"Usuń ostatni punkt\"},\"buttonTitles\":{\"drawMarkerButton\":\"Narysuj znacznik\",\"drawPolyButton\":\"Narysuj wielokąt\",\"drawLineButton\":\"Narysuj ścieżkę\",\"drawCircleButton\":\"Narysuj koło\",\"drawRectButton\":\"Narysuj prostokąt\",\"editButton\":\"Edytuj\",\"dragButton\":\"Przesuń\",\"cutButton\":\"Wytnij\",\"deleteButton\":\"Usuń\",\"drawCircleMarkerButton\":\"Narysuj okrągły znacznik\",\"snappingButton\":\"Snap przeciągnięty marker na inne warstwy i wierzchołki\",\"pinningButton\":\"Sworzeń wspólne wierzchołki razem\"}}'),\n            sv: JSON.parse('{\"tooltips\":{\"placeMarker\":\"Klicka för att placera markör\",\"firstVertex\":\"Klicka för att placera första hörnet\",\"continueLine\":\"Klicka för att fortsätta rita\",\"finishLine\":\"Klicka på en existerande punkt för att slutföra\",\"finishPoly\":\"Klicka på den första punkten för att slutföra\",\"finishRect\":\"Klicka för att slutföra\",\"startCircle\":\"Klicka för att placera cirkelns centrum\",\"finishCircle\":\"Klicka för att slutföra cirkeln\",\"placeCircleMarker\":\"Klicka för att placera cirkelmarkör\"},\"actions\":{\"finish\":\"Slutför\",\"cancel\":\"Avbryt\",\"removeLastVertex\":\"Ta bort sista hörnet\"},\"buttonTitles\":{\"drawMarkerButton\":\"Rita Markör\",\"drawPolyButton\":\"Rita Polygoner\",\"drawLineButton\":\"Rita Linje\",\"drawCircleButton\":\"Rita Cirkel\",\"drawRectButton\":\"Rita Rektangel\",\"editButton\":\"Redigera Lager\",\"dragButton\":\"Dra Lager\",\"cutButton\":\"Klipp i Lager\",\"deleteButton\":\"Ta bort Lager\",\"drawCircleMarkerButton\":\"Rita Cirkelmarkör\",\"snappingButton\":\"Snäpp dra markören till andra lager och hörn\",\"pinningButton\":\"Fäst delade hörn tillsammans\"}}'),\n            el: JSON.parse('{\"tooltips\":{\"placeMarker\":\"Κάντε κλικ για να τοποθετήσετε Δείκτη\",\"firstVertex\":\"Κάντε κλικ για να τοποθετήσετε το πρώτο σημείο\",\"continueLine\":\"Κάντε κλικ για να συνεχίσετε να σχεδιάζετε\",\"finishLine\":\"Κάντε κλικ σε οποιονδήποτε υπάρχον σημείο για να ολοκληρωθεί\",\"finishPoly\":\"Κάντε κλικ στο πρώτο σημείο για να τελειώσετε\",\"finishRect\":\"Κάντε κλικ για να τελειώσετε\",\"startCircle\":\"Κάντε κλικ για να τοποθετήσετε κέντρο Κύκλου\",\"finishCircle\":\"Κάντε κλικ για να ολοκληρώσετε τον Κύκλο\",\"placeCircleMarker\":\"Κάντε κλικ για να τοποθετήσετε Κυκλικό Δείκτη\"},\"actions\":{\"finish\":\"Τέλος\",\"cancel\":\"Ακύρωση\",\"removeLastVertex\":\"Κατάργηση τελευταίου σημείου\"},\"buttonTitles\":{\"drawMarkerButton\":\"Σχεδίαση Δείκτη\",\"drawPolyButton\":\"Σχεδίαση Πολυγώνου\",\"drawLineButton\":\"Σχεδίαση Γραμμής\",\"drawCircleButton\":\"Σχεδίαση Κύκλου\",\"drawRectButton\":\"Σχεδίαση Ορθογωνίου\",\"editButton\":\"Επεξεργασία Επιπέδων\",\"dragButton\":\"Μεταφορά Επιπέδων\",\"cutButton\":\"Αποκοπή Επιπέδων\",\"deleteButton\":\"Κατάργηση Επιπέδων\",\"drawCircleMarkerButton\":\"Σχεδίαση Κυκλικού Δείκτη\",\"snappingButton\":\"Προσκόλληση του Δείκτη μεταφοράς σε άλλα Επίπεδα και Κορυφές\",\"pinningButton\":\"Περικοπή κοινών κορυφών μαζί\"}}'),\n            hu: JSON.parse('{\"tooltips\":{\"placeMarker\":\"Kattintson a jelölő elhelyezéséhez\",\"firstVertex\":\"Kattintson az első pont elhelyezéséhez\",\"continueLine\":\"Kattintson a következő pont elhelyezéséhez\",\"finishLine\":\"A befejezéshez kattintson egy meglévő pontra\",\"finishPoly\":\"A befejezéshez kattintson az első pontra\",\"finishRect\":\"Kattintson a befejezéshez\",\"startCircle\":\"Kattintson a kör középpontjának elhelyezéséhez\",\"finishCircle\":\"Kattintson a kör befejezéséhez\",\"placeCircleMarker\":\"Kattintson a körjelölő elhelyezéséhez\"},\"actions\":{\"finish\":\"Befejezés\",\"cancel\":\"Mégse\",\"removeLastVertex\":\"Utolsó pont eltávolítása\"},\"buttonTitles\":{\"drawMarkerButton\":\"Jelölő rajzolása\",\"drawPolyButton\":\"Poligon rajzolása\",\"drawLineButton\":\"Vonal rajzolása\",\"drawCircleButton\":\"Kör rajzolása\",\"drawRectButton\":\"Négyzet rajzolása\",\"editButton\":\"Elemek szerkesztése\",\"dragButton\":\"Elemek mozgatása\",\"cutButton\":\"Elemek vágása\",\"deleteButton\":\"Elemek törlése\",\"drawCircleMarkerButton\":\"Kör jelölő rajzolása\",\"snappingButton\":\"Kapcsolja a jelöltőt másik elemhez vagy ponthoz\",\"pinningButton\":\"Közös pontok összekötése\"}}'),\n            da: JSON.parse('{\"tooltips\":{\"placeMarker\":\"Tryk for at placere en markør\",\"firstVertex\":\"Tryk for at placere det første punkt\",\"continueLine\":\"Tryk for at fortsætte linjen\",\"finishLine\":\"Tryk på et eksisterende punkt for at afslutte\",\"finishPoly\":\"Tryk på det første punkt for at afslutte\",\"finishRect\":\"Tryk for at afslutte\",\"startCircle\":\"Tryk for at placere cirklens center\",\"finishCircle\":\"Tryk for at afslutte cirklen\",\"placeCircleMarker\":\"Tryk for at placere en cirkelmarkør\"},\"actions\":{\"finish\":\"Afslut\",\"cancel\":\"Afbryd\",\"removeLastVertex\":\"Fjern sidste punkt\"},\"buttonTitles\":{\"drawMarkerButton\":\"Placer markør\",\"drawPolyButton\":\"Tegn polygon\",\"drawLineButton\":\"Tegn linje\",\"drawCircleButton\":\"Tegn cirkel\",\"drawRectButton\":\"Tegn firkant\",\"editButton\":\"Rediger\",\"dragButton\":\"Træk\",\"cutButton\":\"Klip\",\"deleteButton\":\"Fjern\",\"drawCircleMarkerButton\":\"Tegn cirkelmarkør\",\"snappingButton\":\"Fastgør trukket markør til andre elementer\",\"pinningButton\":\"Sammenlæg delte elementer\"}}'),\n            no: JSON.parse('{\"tooltips\":{\"placeMarker\":\"Klikk for å plassere punkt\",\"firstVertex\":\"Klikk for å plassere første punkt\",\"continueLine\":\"Klikk for å tegne videre\",\"finishLine\":\"Klikk på et eksisterende punkt for å fullføre\",\"finishPoly\":\"Klikk første punkt for å fullføre\",\"finishRect\":\"Klikk for å fullføre\",\"startCircle\":\"Klikk for å sette sirkel midtpunkt\",\"finishCircle\":\"Klikk for å fullføre sirkel\",\"placeCircleMarker\":\"Klikk for å plassere sirkel\"},\"actions\":{\"finish\":\"Fullfør\",\"cancel\":\"Kanseller\",\"removeLastVertex\":\"Fjern forrige punkt\"},\"buttonTitles\":{\"drawMarkerButton\":\"Tegn Punkt\",\"drawPolyButton\":\"Tegn Flate\",\"drawLineButton\":\"Tegn Linje\",\"drawCircleButton\":\"Tegn Sirkel\",\"drawRectButton\":\"Tegn rektangel\",\"editButton\":\"Rediger Objekter\",\"dragButton\":\"Dra Objekter\",\"cutButton\":\"Kutt Objekter\",\"deleteButton\":\"Fjern Objekter\",\"drawCircleMarkerButton\":\"Tegn sirkel-punkt\",\"snappingButton\":\"Fest dratt punkt til andre objekter og punkt\",\"pinningButton\":\"Pin delte punkt sammen\"}}'),\n            fa: JSON.parse('{\"tooltips\":{\"placeMarker\":\"کلیک برای جانمایی نشان\",\"firstVertex\":\"کلیک برای رسم اولین رأس\",\"continueLine\":\"کلیک برای ادامه رسم\",\"finishLine\":\"کلیک روی هر نشان موجود برای پایان\",\"finishPoly\":\"کلیک روی اولین نشان برای پایان\",\"finishRect\":\"کلیک برای پایان\",\"startCircle\":\"کلیک برای رسم مرکز دایره\",\"finishCircle\":\"کلیک برای پایان رسم دایره\",\"placeCircleMarker\":\"کلیک برای رسم نشان دایره\",\"placeText\":\"کلیک برای نوشتن متن\"},\"actions\":{\"finish\":\"پایان\",\"cancel\":\"لفو\",\"removeLastVertex\":\"حذف آخرین رأس\"},\"buttonTitles\":{\"drawMarkerButton\":\"درج نشان\",\"drawPolyButton\":\"رسم چندضلعی\",\"drawLineButton\":\"رسم خط\",\"drawCircleButton\":\"رسم دایره\",\"drawRectButton\":\"رسم چهارضلعی\",\"editButton\":\"ویرایش لایه‌ها\",\"dragButton\":\"جابجایی لایه‌ها\",\"cutButton\":\"برش لایه‌ها\",\"deleteButton\":\"حذف لایه‌ها\",\"drawCircleMarkerButton\":\"رسم نشان دایره\",\"snappingButton\":\"نشانگر را به لایه‌ها و رئوس دیگر بکشید\",\"pinningButton\":\"رئوس مشترک را با هم پین کنید\",\"rotateButton\":\"چرخش لایه\",\"drawTextButton\":\"رسم متن\"}}'),\n            ua: JSON.parse('{\"tooltips\":{\"placeMarker\":\"Натисніть, щоб нанести маркер\",\"firstVertex\":\"Натисніть, щоб нанести першу вершину\",\"continueLine\":\"Натисніть, щоб продовжити малювати\",\"finishLine\":\"Натисніть будь-який існуючий маркер для завершення\",\"finishPoly\":\"Виберіть перший маркер, щоб завершити\",\"finishRect\":\"Натисніть, щоб завершити\",\"startCircle\":\"Натисніть, щоб додати центр кола\",\"finishCircle\":\"Натисніть, щоб завершити коло\",\"placeCircleMarker\":\"Натисніть, щоб нанести круговий маркер\"},\"actions\":{\"finish\":\"Завершити\",\"cancel\":\"Відмінити\",\"removeLastVertex\":\"Видалити попередню вершину\"},\"buttonTitles\":{\"drawMarkerButton\":\"Малювати маркер\",\"drawPolyButton\":\"Малювати полігон\",\"drawLineButton\":\"Малювати криву\",\"drawCircleButton\":\"Малювати коло\",\"drawRectButton\":\"Малювати прямокутник\",\"editButton\":\"Редагувати шари\",\"dragButton\":\"Перенести шари\",\"cutButton\":\"Вирізати шари\",\"deleteButton\":\"Видалити шари\",\"drawCircleMarkerButton\":\"Малювати круговий маркер\",\"snappingButton\":\"Прив’язати перетягнутий маркер до інших шарів та вершин\",\"pinningButton\":\"Зв\\'язати спільні вершини разом\"}}'),\n            tr: JSON.parse('{\"tooltips\":{\"placeMarker\":\"İşaretçi yerleştirmek için tıklayın\",\"firstVertex\":\"İlk tepe noktasını yerleştirmek için tıklayın\",\"continueLine\":\"Çizime devam etmek için tıklayın\",\"finishLine\":\"Bitirmek için mevcut herhangi bir işaretçiyi tıklayın\",\"finishPoly\":\"Bitirmek için ilk işaretçiyi tıklayın\",\"finishRect\":\"Bitirmek için tıklayın\",\"startCircle\":\"Daire merkezine yerleştirmek için tıklayın\",\"finishCircle\":\"Daireyi bitirmek için tıklayın\",\"placeCircleMarker\":\"Daire işaretçisi yerleştirmek için tıklayın\"},\"actions\":{\"finish\":\"Bitir\",\"cancel\":\"İptal\",\"removeLastVertex\":\"Son köşeyi kaldır\"},\"buttonTitles\":{\"drawMarkerButton\":\"Çizim İşaretçisi\",\"drawPolyButton\":\"Çokgenler çiz\",\"drawLineButton\":\"Çoklu çizgi çiz\",\"drawCircleButton\":\"Çember çiz\",\"drawRectButton\":\"Dikdörtgen çiz\",\"editButton\":\"Katmanları düzenle\",\"dragButton\":\"Katmanları sürükle\",\"cutButton\":\"Katmanları kes\",\"deleteButton\":\"Katmanları kaldır\",\"drawCircleMarkerButton\":\"Daire işaretçisi çiz\",\"snappingButton\":\"Sürüklenen işaretçiyi diğer katmanlara ve köşelere yapıştır\",\"pinningButton\":\"Paylaşılan köşeleri birbirine sabitle\"}}'),\n            cz: JSON.parse('{\"tooltips\":{\"placeMarker\":\"Kliknutím vytvoříte značku\",\"firstVertex\":\"Kliknutím vytvoříte první objekt\",\"continueLine\":\"Kliknutím pokračujte v kreslení\",\"finishLine\":\"Kliknutí na libovolnou existující značku pro dokončení\",\"finishPoly\":\"Vyberte první bod pro dokončení\",\"finishRect\":\"Klikněte pro dokončení\",\"startCircle\":\"Kliknutím přidejte střed kruhu\",\"finishCircle\":\"Нажмите, чтобы задать радиус\",\"placeCircleMarker\":\"Kliknutím nastavte poloměr\"},\"actions\":{\"finish\":\"Dokončit\",\"cancel\":\"Zrušit\",\"removeLastVertex\":\"Zrušit poslední akci\"},\"buttonTitles\":{\"drawMarkerButton\":\"Přidat značku\",\"drawPolyButton\":\"Nakreslit polygon\",\"drawLineButton\":\"Nakreslit křivku\",\"drawCircleButton\":\"Nakreslit kruh\",\"drawRectButton\":\"Nakreslit obdélník\",\"editButton\":\"Upravit vrstvu\",\"dragButton\":\"Přeneste vrstvu\",\"cutButton\":\"Vyjmout vrstvu\",\"deleteButton\":\"Smazat vrstvu\",\"drawCircleMarkerButton\":\"Přidat kruhovou značku\",\"snappingButton\":\"Navázat tažnou značku k dalším vrstvám a vrcholům\",\"pinningButton\":\"Spojit společné body dohromady\"}}'),\n            ja: JSON.parse('{\"tooltips\":{\"placeMarker\":\"クリックしてマーカーを配置\",\"firstVertex\":\"クリックして最初の頂点を配置\",\"continueLine\":\"クリックして描画を続ける\",\"finishLine\":\"任意のマーカーをクリックして終了\",\"finishPoly\":\"最初のマーカーをクリックして終了\",\"finishRect\":\"クリックして終了\",\"startCircle\":\"クリックして円の中心を配置\",\"finishCircle\":\"クリックして円の描画を終了\",\"placeCircleMarker\":\"クリックして円マーカーを配置\",\"placeText\":\"クリックしてテキストを配置\"},\"actions\":{\"finish\":\"終了\",\"cancel\":\"キャンセル\",\"removeLastVertex\":\"最後の頂点を削除\"},\"buttonTitles\":{\"drawMarkerButton\":\"マーカーを描画\",\"drawPolyButton\":\"ポリゴンを描画\",\"drawLineButton\":\"折れ線を描画\",\"drawCircleButton\":\"円を描画\",\"drawRectButton\":\"矩形を描画\",\"editButton\":\"レイヤーを編集\",\"dragButton\":\"レイヤーをドラッグ\",\"cutButton\":\"レイヤーを切り取り\",\"deleteButton\":\"レイヤーを削除\",\"drawCircleMarkerButton\":\"円マーカーを描画\",\"snappingButton\":\"ドラッグしたマーカーを他のレイヤーや頂点にスナップする\",\"pinningButton\":\"共有する頂点を同時に動かす\",\"rotateButton\":\"レイヤーを回転\",\"drawTextButton\":\"テキストを描画\"}}'),\n            fi: JSON.parse('{\"tooltips\":{\"placeMarker\":\"Klikkaa asettaaksesi merkin\",\"firstVertex\":\"Klikkaa asettaakseni ensimmäisen osuuden\",\"continueLine\":\"Klikkaa jatkaaksesi piirtämistä\",\"finishLine\":\"Klikkaa olemassa olevaa merkkiä lopettaaksesi\",\"finishPoly\":\"Klikkaa ensimmäistä merkkiä lopettaaksesi\",\"finishRect\":\"Klikkaa lopettaaksesi\",\"startCircle\":\"Klikkaa asettaaksesi ympyrän keskipisteen\",\"finishCircle\":\"Klikkaa lopettaaksesi ympyrän\",\"placeCircleMarker\":\"Klikkaa asettaaksesi ympyrämerkin\",\"placeText\":\"Klikkaa asettaaksesi tekstin\"},\"actions\":{\"finish\":\"Valmis\",\"cancel\":\"Peruuta\",\"removeLastVertex\":\"Poista viimeinen osuus\"},\"buttonTitles\":{\"drawMarkerButton\":\"Piirrä merkkejä\",\"drawPolyButton\":\"Piirrä monikulmioita\",\"drawLineButton\":\"Piirrä viivoja\",\"drawCircleButton\":\"Piirrä ympyrä\",\"drawRectButton\":\"Piirrä neliskulmioita\",\"editButton\":\"Muokkaa\",\"dragButton\":\"Siirrä\",\"cutButton\":\"Leikkaa\",\"deleteButton\":\"Poista\",\"drawCircleMarkerButton\":\"Piirrä ympyrämerkki\",\"snappingButton\":\"Kiinnitä siirrettävä merkki toisiin muotoihin\",\"pinningButton\":\"Kiinnitä jaetut muodot yhteen\",\"rotateButton\":\"Käännä\",\"drawTextButton\":\"Piirrä tekstiä\"}}'),\n            ko: JSON.parse('{\"tooltips\":{\"placeMarker\":\"마커 위치를 클릭하세요\",\"firstVertex\":\"첫번째 꼭지점 위치을 클릭하세요\",\"continueLine\":\"계속 그리려면 클릭하세요\",\"finishLine\":\"끝내려면 기존 마커를 클릭하세요\",\"finishPoly\":\"끝내려면 처음 마커를 클릭하세요\",\"finishRect\":\"끝내려면 클릭하세요\",\"startCircle\":\"원의 중심이 될 위치를 클릭하세요\",\"finishCircle\":\"원을 끝내려면 클릭하세요\",\"placeCircleMarker\":\"원 마커 위치를 클릭하세요\",\"placeText\":\"텍스트 위치를 클릭하세요\"},\"actions\":{\"finish\":\"끝내기\",\"cancel\":\"취소\",\"removeLastVertex\":\"마지막 꼭지점 제거\"},\"buttonTitles\":{\"drawMarkerButton\":\"마커 그리기\",\"drawPolyButton\":\"다각형 그리기\",\"drawLineButton\":\"다각선 그리기\",\"drawCircleButton\":\"원 그리기\",\"drawRectButton\":\"직사각형 그리기\",\"editButton\":\"레이어 편집하기\",\"dragButton\":\"레이어 끌기\",\"cutButton\":\"레이어 자르기\",\"deleteButton\":\"레이어 제거하기\",\"drawCircleMarkerButton\":\"원 마커 그리기\",\"snappingButton\":\"잡아끈 마커를 다른 레이어 및 꼭지점에 들러붙게 하기\",\"pinningButton\":\"공유 꼭지점을 함께 찍기\",\"rotateButton\":\"레이어 회전하기\",\"drawTextButton\":\"텍스트 그리기\"}}')\n          };\n        function m(t, e) {\n          var i = Object.keys(t);\n          if (Object.getOwnPropertySymbols) {\n            var n = Object.getOwnPropertySymbols(t);\n            e && (n = n.filter(function (e) {\n              return Object.getOwnPropertyDescriptor(t, e).enumerable;\n            })), i.push.apply(i, n);\n          }\n          return i;\n        }\n        function y(t) {\n          for (var e = 1; e < arguments.length; e++) {\n            var i = null != arguments[e] ? arguments[e] : {};\n            e % 2 ? m(Object(i), !0).forEach(function (e) {\n              v(t, e, i[e]);\n            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : m(Object(i)).forEach(function (e) {\n              Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e));\n            });\n          }\n          return t;\n        }\n        function v(t, e, i) {\n          return e in t ? Object.defineProperty(t, e, {\n            value: i,\n            enumerable: !0,\n            configurable: !0,\n            writable: !0\n          }) : t[e] = i, t;\n        }\n        const b = {\n          _globalEditModeEnabled: !1,\n          enableGlobalEditMode: function (t) {\n            var e = y({}, t);\n            this._globalEditModeEnabled = !0, this.Toolbar.toggleButton(\"editMode\", this.globalEditModeEnabled()), L.PM.Utils.findLayers(this.map).forEach(function (t) {\n              t.pm.enable(e);\n            }), this.throttledReInitEdit || (this.throttledReInitEdit = L.Util.throttle(this.handleLayerAdditionInGlobalEditMode, 100, this)), this._addedLayers = {}, this.map.on(\"layeradd\", this._layerAdded, this), this.map.on(\"layeradd\", this.throttledReInitEdit, this), this._fireGlobalEditModeToggled(!0);\n          },\n          disableGlobalEditMode: function () {\n            this._globalEditModeEnabled = !1, L.PM.Utils.findLayers(this.map).forEach(function (t) {\n              t.pm.disable();\n            }), this.map.off(\"layeradd\", this.throttledReInitEdit, this), this.Toolbar.toggleButton(\"editMode\", this.globalEditModeEnabled()), this._fireGlobalEditModeToggled(!1);\n          },\n          globalEditEnabled: function () {\n            return this.globalEditModeEnabled();\n          },\n          globalEditModeEnabled: function () {\n            return this._globalEditModeEnabled;\n          },\n          toggleGlobalEditMode: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.globalOptions;\n            this.globalEditModeEnabled() ? this.disableGlobalEditMode() : this.enableGlobalEditMode(t);\n          },\n          handleLayerAdditionInGlobalEditMode: function () {\n            var t = this._addedLayers;\n            for (var e in this._addedLayers = {}, t) {\n              var i = t[e];\n              this._isRelevantForEdit(i) && this.globalEditModeEnabled() && i.pm.enable(y({}, this.globalOptions));\n            }\n          },\n          _layerAdded: function (t) {\n            var e = t.layer;\n            this._addedLayers[L.stamp(e)] = e;\n          },\n          _isRelevantForEdit: function (t) {\n            return t.pm && !(t instanceof L.LayerGroup) && (!L.PM.optIn && !t.options.pmIgnore || L.PM.optIn && !1 === t.options.pmIgnore) && !t._pmTempLayer && t.pm.options.allowEditing;\n          }\n        };\n        const k = {\n          _globalDragModeEnabled: !1,\n          enableGlobalDragMode: function () {\n            var t = L.PM.Utils.findLayers(this.map);\n            this._globalDragModeEnabled = !0, this._addedLayersDrag = {}, t.forEach(function (t) {\n              t.pm.enableLayerDrag();\n            }), this.throttledReInitDrag || (this.throttledReInitDrag = L.Util.throttle(this.reinitGlobalDragMode, 100, this)), this.map.on(\"layeradd\", this._layerAddedDrag, this), this.map.on(\"layeradd\", this.throttledReInitDrag, this), this.Toolbar.toggleButton(\"dragMode\", this.globalDragModeEnabled()), this._fireGlobalDragModeToggled(!0);\n          },\n          disableGlobalDragMode: function () {\n            var t = L.PM.Utils.findLayers(this.map);\n            this._globalDragModeEnabled = !1, t.forEach(function (t) {\n              t.pm.disableLayerDrag();\n            }), this.map.off(\"layeradd\", this._layerAddedDrag, this), this.map.off(\"layeradd\", this.throttledReInitDrag, this), this.Toolbar.toggleButton(\"dragMode\", this.globalDragModeEnabled()), this._fireGlobalDragModeToggled(!1);\n          },\n          globalDragModeEnabled: function () {\n            return !!this._globalDragModeEnabled;\n          },\n          toggleGlobalDragMode: function () {\n            this.globalDragModeEnabled() ? this.disableGlobalDragMode() : this.enableGlobalDragMode();\n          },\n          reinitGlobalDragMode: function () {\n            var t = this._addedLayersDrag;\n            for (var e in this._addedLayersDrag = {}, t) {\n              var i = t[e];\n              this._isRelevantForDrag(i) && this.globalDragModeEnabled() && i.pm.enableLayerDrag();\n            }\n          },\n          _layerAddedDrag: function (t) {\n            var e = t.layer;\n            this._addedLayersDrag[L.stamp(e)] = e;\n          },\n          _isRelevantForDrag: function (t) {\n            return t.pm && !(t instanceof L.LayerGroup) && (!L.PM.optIn && !t.options.pmIgnore || L.PM.optIn && !1 === t.options.pmIgnore) && !t._pmTempLayer && t.pm.options.draggable;\n          }\n        };\n        const M = {\n          _globalRemovalModeEnabled: !1,\n          enableGlobalRemovalMode: function () {\n            var t = this;\n            this._globalRemovalModeEnabled = !0, this.map.eachLayer(function (e) {\n              t._isRelevantForRemoval(e) && (e.pm.disable(), e.on(\"click\", t.removeLayer, t));\n            }), this.throttledReInitRemoval || (this.throttledReInitRemoval = L.Util.throttle(this.reinitGlobalRemovalMode, 100, this)), this.map.on(\"layeradd\", this.throttledReInitRemoval, this), this.Toolbar.toggleButton(\"removalMode\", this.globalRemovalModeEnabled()), this._fireGlobalRemovalModeToggled(!0);\n          },\n          disableGlobalRemovalMode: function () {\n            var t = this;\n            this._globalRemovalModeEnabled = !1, this.map.eachLayer(function (e) {\n              e.off(\"click\", t.removeLayer, t);\n            }), this.map.off(\"layeradd\", this.throttledReInitRemoval, this), this.Toolbar.toggleButton(\"removalMode\", this.globalRemovalModeEnabled()), this._fireGlobalRemovalModeToggled(!1);\n          },\n          globalRemovalEnabled: function () {\n            return this.globalRemovalModeEnabled();\n          },\n          globalRemovalModeEnabled: function () {\n            return !!this._globalRemovalModeEnabled;\n          },\n          toggleGlobalRemovalMode: function () {\n            this.globalRemovalModeEnabled() ? this.disableGlobalRemovalMode() : this.enableGlobalRemovalMode();\n          },\n          reinitGlobalRemovalMode: function (t) {\n            var e = t.layer;\n            this._isRelevantForRemoval(e) && this.globalRemovalModeEnabled() && (this.disableGlobalRemovalMode(), this.enableGlobalRemovalMode());\n          },\n          removeLayer: function (t) {\n            var e = t.target;\n            this._isRelevantForRemoval(e) && !e.pm.dragging() && (e.removeFrom(this.map.pm._getContainingLayer()), e.remove(), e instanceof L.LayerGroup ? (this._fireRemoveLayerGroup(e), this._fireRemoveLayerGroup(this.map, e)) : (e.pm._fireRemove(e), e.pm._fireRemove(this.map, e)));\n          },\n          _isRelevantForRemoval: function (t) {\n            return t.pm && !(t instanceof L.LayerGroup) && (!L.PM.optIn && !t.options.pmIgnore || L.PM.optIn && !1 === t.options.pmIgnore) && !t._pmTempLayer && t.pm.options.allowRemoval;\n          }\n        };\n        const x = {\n          _globalRotateModeEnabled: !1,\n          enableGlobalRotateMode: function () {\n            var t = this;\n            this._globalRotateModeEnabled = !0, L.PM.Utils.findLayers(this.map).filter(function (t) {\n              return t instanceof L.Polyline;\n            }).forEach(function (e) {\n              t._isRelevantForRotate(e) && e.pm.enableRotate();\n            }), this.throttledReInitRotate || (this.throttledReInitRotate = L.Util.throttle(this._reinitGlobalRotateMode, 100, this)), this.map.on(\"layeradd\", this.throttledReInitRotate, this), this.Toolbar.toggleButton(\"rotateMode\", this.globalRotateModeEnabled()), this._fireGlobalRotateModeToggled();\n          },\n          disableGlobalRotateMode: function () {\n            this._globalRotateModeEnabled = !1, L.PM.Utils.findLayers(this.map).filter(function (t) {\n              return t instanceof L.Polyline;\n            }).forEach(function (t) {\n              t.pm.disableRotate();\n            }), this.map.off(\"layeradd\", this.throttledReInitRotate, this), this.Toolbar.toggleButton(\"rotateMode\", this.globalRotateModeEnabled()), this._fireGlobalRotateModeToggled();\n          },\n          globalRotateModeEnabled: function () {\n            return !!this._globalRotateModeEnabled;\n          },\n          toggleGlobalRotateMode: function () {\n            this.globalRotateModeEnabled() ? this.disableGlobalRotateMode() : this.enableGlobalRotateMode();\n          },\n          _reinitGlobalRotateMode: function (t) {\n            var e = t.layer;\n            this._isRelevantForRotate(e) && this.globalRotateModeEnabled() && (this.disableGlobalRotateMode(), this.enableGlobalRotateMode());\n          },\n          _isRelevantForRotate: function (t) {\n            return t.pm && !(t instanceof L.LayerGroup) && (!L.PM.optIn && !t.options.pmIgnore || L.PM.optIn && !1 === t.options.pmIgnore) && !t._pmTempLayer && t.pm.options.allowRotation;\n          }\n        };\n        function w(t, e) {\n          var i = Object.keys(t);\n          if (Object.getOwnPropertySymbols) {\n            var n = Object.getOwnPropertySymbols(t);\n            e && (n = n.filter(function (e) {\n              return Object.getOwnPropertyDescriptor(t, e).enumerable;\n            })), i.push.apply(i, n);\n          }\n          return i;\n        }\n        function C(t) {\n          for (var e = 1; e < arguments.length; e++) {\n            var i = null != arguments[e] ? arguments[e] : {};\n            e % 2 ? w(Object(i), !0).forEach(function (e) {\n              P(t, e, i[e]);\n            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : w(Object(i)).forEach(function (e) {\n              Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e));\n            });\n          }\n          return t;\n        }\n        function P(t, e, i) {\n          return e in t ? Object.defineProperty(t, e, {\n            value: i,\n            enumerable: !0,\n            configurable: !0,\n            writable: !0\n          }) : t[e] = i, t;\n        }\n        var E = {\n          _fireDrawStart: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Draw\",\n              e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            this.__fire(this._map, \"pm:drawstart\", {\n              shape: this._shape,\n              workingLayer: this._layer\n            }, t, e);\n          },\n          _fireDrawEnd: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Draw\",\n              e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            this.__fire(this._map, \"pm:drawend\", {\n              shape: this._shape\n            }, t, e);\n          },\n          _fireCreate: function (t) {\n            var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Draw\",\n              i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n            this.__fire(this._map, \"pm:create\", {\n              shape: this._shape,\n              marker: t,\n              layer: t\n            }, e, i);\n          },\n          _fireCenterPlaced: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Draw\",\n              e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n              i = \"Draw\" === t ? this._layer : undefined,\n              n = \"Draw\" !== t ? this._layer : undefined;\n            this.__fire(this._layer, \"pm:centerplaced\", {\n              shape: this._shape,\n              workingLayer: i,\n              layer: n,\n              latlng: this._layer.getLatLng()\n            }, t, e);\n          },\n          _fireCut: function (t, e, i) {\n            var n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"Draw\",\n              r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n            this.__fire(t, \"pm:cut\", {\n              shape: this._shape,\n              layer: e,\n              originalLayer: i\n            }, n, r);\n          },\n          _fireEdit: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._layer,\n              e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Edit\",\n              i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n            this.__fire(t, \"pm:edit\", {\n              layer: this._layer,\n              shape: this.getShape()\n            }, e, i);\n          },\n          _fireEnable: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Edit\",\n              e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            this.__fire(this._layer, \"pm:enable\", {\n              layer: this._layer,\n              shape: this.getShape()\n            }, t, e);\n          },\n          _fireDisable: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Edit\",\n              e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            this.__fire(this._layer, \"pm:disable\", {\n              layer: this._layer,\n              shape: this.getShape()\n            }, t, e);\n          },\n          _fireUpdate: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Edit\",\n              e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            this.__fire(this._layer, \"pm:update\", {\n              layer: this._layer,\n              shape: this.getShape()\n            }, t, e);\n          },\n          _fireMarkerDragStart: function (t) {\n            var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined,\n              i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"Edit\",\n              n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n            this.__fire(this._layer, \"pm:markerdragstart\", {\n              layer: this._layer,\n              markerEvent: t,\n              shape: this.getShape(),\n              indexPath: e\n            }, i, n);\n          },\n          _fireMarkerDrag: function (t) {\n            var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined,\n              i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"Edit\",\n              n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n            this.__fire(this._layer, \"pm:markerdrag\", {\n              layer: this._layer,\n              markerEvent: t,\n              shape: this.getShape(),\n              indexPath: e\n            }, i, n);\n          },\n          _fireMarkerDragEnd: function (t) {\n            var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined,\n              i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined,\n              n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"Edit\",\n              r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n            this.__fire(this._layer, \"pm:markerdragend\", {\n              layer: this._layer,\n              markerEvent: t,\n              shape: this.getShape(),\n              indexPath: e,\n              intersectionReset: i\n            }, n, r);\n          },\n          _fireDragStart: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Edit\",\n              e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            this.__fire(this._layer, \"pm:dragstart\", {\n              layer: this._layer,\n              shape: this.getShape()\n            }, t, e);\n          },\n          _fireDrag: function (t) {\n            var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Edit\",\n              i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n            this.__fire(this._layer, \"pm:drag\", C(C({}, t), {}, {\n              shape: this.getShape()\n            }), e, i);\n          },\n          _fireDragEnd: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Edit\",\n              e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            this.__fire(this._layer, \"pm:dragend\", {\n              layer: this._layer,\n              shape: this.getShape()\n            }, t, e);\n          },\n          _fireDragEnable: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Edit\",\n              e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            this.__fire(this._layer, \"pm:dragenable\", {\n              layer: this._layer,\n              shape: this.getShape()\n            }, t, e);\n          },\n          _fireDragDisable: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Edit\",\n              e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            this.__fire(this._layer, \"pm:dragdisable\", {\n              layer: this._layer,\n              shape: this.getShape()\n            }, t, e);\n          },\n          _fireRemove: function (t) {\n            var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : t,\n              i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"Edit\",\n              n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n            this.__fire(t, \"pm:remove\", {\n              layer: e,\n              shape: this.getShape()\n            }, i, n);\n          },\n          _fireVertexAdded: function (t, e, i) {\n            var n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"Edit\",\n              r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n            this.__fire(this._layer, \"pm:vertexadded\", {\n              layer: this._layer,\n              workingLayer: this._layer,\n              marker: t,\n              indexPath: e,\n              latlng: i,\n              shape: this.getShape()\n            }, n, r);\n          },\n          _fireVertexRemoved: function (t, e) {\n            var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"Edit\",\n              n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n            this.__fire(this._layer, \"pm:vertexremoved\", {\n              layer: this._layer,\n              marker: t,\n              indexPath: e,\n              shape: this.getShape()\n            }, i, n);\n          },\n          _fireVertexClick: function (t, e) {\n            var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"Edit\",\n              n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n            this.__fire(this._layer, \"pm:vertexclick\", {\n              layer: this._layer,\n              markerEvent: t,\n              indexPath: e,\n              shape: this.getShape()\n            }, i, n);\n          },\n          _fireIntersect: function (t) {\n            var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Edit\",\n              i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n            this.__fire(this._layer, \"pm:intersect\", {\n              layer: this._layer,\n              intersection: t,\n              shape: this.getShape()\n            }, e, i);\n          },\n          _fireLayerReset: function (t, e) {\n            var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"Edit\",\n              n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n            this.__fire(this._layer, \"pm:layerreset\", {\n              layer: this._layer,\n              markerEvent: t,\n              indexPath: e,\n              shape: this.getShape()\n            }, i, n);\n          },\n          _fireChange: function (t) {\n            var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Edit\",\n              i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n            this.__fire(this._layer, \"pm:change\", {\n              layer: this._layer,\n              latlngs: t,\n              shape: this.getShape()\n            }, e, i);\n          },\n          _fireTextChange: function (t) {\n            var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Edit\",\n              i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n            this.__fire(this._layer, \"pm:textchange\", {\n              layer: this._layer,\n              text: t,\n              shape: this.getShape()\n            }, e, i);\n          },\n          _fireTextFocus: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Edit\",\n              e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            this.__fire(this._layer, \"pm:textfocus\", {\n              layer: this._layer,\n              shape: this.getShape()\n            }, t, e);\n          },\n          _fireTextBlur: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Edit\",\n              e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            this.__fire(this._layer, \"pm:textblur\", {\n              layer: this._layer,\n              shape: this.getShape()\n            }, t, e);\n          },\n          _fireSnapDrag: function (t, e) {\n            var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"Snapping\",\n              n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n            this.__fire(t, \"pm:snapdrag\", e, i, n);\n          },\n          _fireSnap: function (t, e) {\n            var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"Snapping\",\n              n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n            this.__fire(t, \"pm:snap\", e, i, n);\n          },\n          _fireUnsnap: function (t, e) {\n            var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"Snapping\",\n              n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n            this.__fire(t, \"pm:unsnap\", e, i, n);\n          },\n          _fireRotationEnable: function (t, e) {\n            var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"Rotation\",\n              n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n            this.__fire(t, \"pm:rotateenable\", {\n              layer: this._layer,\n              helpLayer: this._rotatePoly,\n              shape: this.getShape()\n            }, i, n);\n          },\n          _fireRotationDisable: function (t) {\n            var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Rotation\",\n              i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n            this.__fire(t, \"pm:rotatedisable\", {\n              layer: this._layer,\n              shape: this.getShape()\n            }, e, i);\n          },\n          _fireRotationStart: function (t, e) {\n            var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"Rotation\",\n              n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n            this.__fire(t, \"pm:rotatestart\", {\n              layer: this._rotationLayer,\n              helpLayer: this._layer,\n              startAngle: this._startAngle,\n              originLatLngs: e\n            }, i, n);\n          },\n          _fireRotation: function (t, e, i) {\n            var n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this._rotationLayer,\n              r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"Rotation\",\n              a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n            this.__fire(t, \"pm:rotate\", {\n              layer: n,\n              helpLayer: this._layer,\n              startAngle: this._startAngle,\n              angle: n.pm.getAngle(),\n              angleDiff: e,\n              oldLatLngs: i,\n              newLatLngs: n.getLatLngs()\n            }, r, a);\n          },\n          _fireRotationEnd: function (t, e, i) {\n            var n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"Rotation\",\n              r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n            this.__fire(t, \"pm:rotateend\", {\n              layer: this._rotationLayer,\n              helpLayer: this._layer,\n              startAngle: e,\n              angle: this._rotationLayer.pm.getAngle(),\n              originLatLngs: i,\n              newLatLngs: this._rotationLayer.getLatLngs()\n            }, n, r);\n          },\n          _fireActionClick: function (t, e, i) {\n            var n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"Toolbar\",\n              r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n            this.__fire(this._map, \"pm:actionclick\", {\n              text: t.text,\n              action: t,\n              btnName: e,\n              button: i\n            }, n, r);\n          },\n          _fireButtonClick: function (t, e) {\n            var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"Toolbar\",\n              n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n            this.__fire(this._map, \"pm:buttonclick\", {\n              btnName: t,\n              button: e\n            }, i, n);\n          },\n          _fireLangChange: function (t, e, i, n) {\n            var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"Global\",\n              a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n            this.__fire(this.map, \"pm:langchange\", {\n              oldLang: t,\n              activeLang: e,\n              fallback: i,\n              translations: n\n            }, r, a);\n          },\n          _fireGlobalDragModeToggled: function (t) {\n            var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Global\",\n              i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n            this.__fire(this.map, \"pm:globaldragmodetoggled\", {\n              enabled: t,\n              map: this.map\n            }, e, i);\n          },\n          _fireGlobalEditModeToggled: function (t) {\n            var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Global\",\n              i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n            this.__fire(this.map, \"pm:globaleditmodetoggled\", {\n              enabled: t,\n              map: this.map\n            }, e, i);\n          },\n          _fireGlobalRemovalModeToggled: function (t) {\n            var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Global\",\n              i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n            this.__fire(this.map, \"pm:globalremovalmodetoggled\", {\n              enabled: t,\n              map: this.map\n            }, e, i);\n          },\n          _fireGlobalCutModeToggled: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Global\",\n              e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            this.__fire(this._map, \"pm:globalcutmodetoggled\", {\n              enabled: !!this._enabled,\n              map: this._map\n            }, t, e);\n          },\n          _fireGlobalDrawModeToggled: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Global\",\n              e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            this.__fire(this._map, \"pm:globaldrawmodetoggled\", {\n              enabled: this._enabled,\n              shape: this._shape,\n              map: this._map\n            }, t, e);\n          },\n          _fireGlobalRotateModeToggled: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Global\",\n              e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            this.__fire(this.map, \"pm:globalrotatemodetoggled\", {\n              enabled: this.globalRotateModeEnabled(),\n              map: this.map\n            }, t, e);\n          },\n          _fireRemoveLayerGroup: function (t) {\n            var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : t,\n              i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"Edit\",\n              n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n            this.__fire(t, \"pm:remove\", {\n              layer: e,\n              shape: undefined\n            }, i, n);\n          },\n          _fireKeyeventEvent: function (t, e, i) {\n            var n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"Global\",\n              r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n            this.__fire(this.map, \"pm:keyevent\", {\n              event: t,\n              eventType: e,\n              focusOn: i\n            }, n, r);\n          },\n          __fire: function (t, e, i, n) {\n            var a = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n            i = r()(i, a, {\n              source: n\n            }), L.PM.Utils._fireEvent(t, e, i);\n          }\n        };\n        const S = E;\n        const O = {\n          _lastEvents: {\n            keydown: undefined,\n            keyup: undefined,\n            current: undefined\n          },\n          _initKeyListener: function (t) {\n            this.map = t, L.DomEvent.on(document, \"keydown keyup\", this._onKeyListener, this), L.DomEvent.on(window, \"blur\", this._onBlur, this);\n          },\n          _onKeyListener: function (t) {\n            var e = \"document\";\n            this.map.getContainer().contains(t.target) && (e = \"map\");\n            var i = {\n              event: t,\n              eventType: t.type,\n              focusOn: e\n            };\n            this._lastEvents[t.type] = i, this._lastEvents.current = i, this.map.pm._fireKeyeventEvent(t, t.type, e);\n          },\n          _onBlur: function (t) {\n            t.altKey = !1;\n            var e = {\n              event: t,\n              eventType: t.type,\n              focusOn: \"document\"\n            };\n            this._lastEvents[t.type] = e, this._lastEvents.current = e;\n          },\n          getLastKeyEvent: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"current\";\n            return this._lastEvents[t];\n          },\n          isShiftKeyPressed: function () {\n            var t;\n            return null === (t = this._lastEvents.current) || void 0 === t ? void 0 : t.event.shiftKey;\n          },\n          isAltKeyPressed: function () {\n            var t;\n            return null === (t = this._lastEvents.current) || void 0 === t ? void 0 : t.event.altKey;\n          },\n          isCtrlKeyPressed: function () {\n            var t;\n            return null === (t = this._lastEvents.current) || void 0 === t ? void 0 : t.event.ctrlKey;\n          },\n          isMetaKeyPressed: function () {\n            var t;\n            return null === (t = this._lastEvents.current) || void 0 === t ? void 0 : t.event.metaKey;\n          },\n          getPressedKey: function () {\n            var t;\n            return null === (t = this._lastEvents.current) || void 0 === t ? void 0 : t.event.key;\n          }\n        };\n        var D = i(7361),\n          B = i.n(D),\n          R = i(8721),\n          T = i.n(R);\n        function I(t) {\n          var e = L.PM.activeLang;\n          return T()(_, e) || (e = \"en\"), B()(_[e], t);\n        }\n        function j(t) {\n          for (var e = 0; e < t.length; e += 1) {\n            var i = t[e];\n            if (Array.isArray(i)) {\n              if (j(i)) return !0;\n            } else if (null !== i && i !== undefined && \"\" !== i) return !0;\n          }\n          return !1;\n        }\n        function A(t) {\n          return t.reduce(function (t, e) {\n            if (0 !== e.length) {\n              var i = Array.isArray(e) ? A(e) : e;\n              Array.isArray(i) ? 0 !== i.length && t.push(i) : t.push(i);\n            }\n            return t;\n          }, []);\n        }\n        function G(t, e, i) {\n          for (var n, r, a, o = 6378137, s = 6356752.3142, l = 1 / 298.257223563, h = t.lng, u = t.lat, c = i, p = Math.PI, d = e * p / 180, f = Math.sin(d), g = Math.cos(d), _ = (1 - l) * Math.tan(u * p / 180), m = 1 / Math.sqrt(1 + _ * _), y = _ * m, v = Math.atan2(_, g), b = m * f, k = 1 - b * b, M = k * (o * o - s * s) / (s * s), x = 1 + M / 16384 * (4096 + M * (M * (320 - 175 * M) - 768)), w = M / 1024 * (256 + M * (M * (74 - 47 * M) - 128)), C = c / (s * x), P = 2 * Math.PI; Math.abs(C - P) > 1e-12;) {\n            n = Math.cos(2 * v + C), P = C, C = c / (s * x) + w * (r = Math.sin(C)) * (n + w / 4 * ((a = Math.cos(C)) * (2 * n * n - 1) - w / 6 * n * (4 * r * r - 3) * (4 * n * n - 3)));\n          }\n          var E = y * r - m * a * g,\n            S = Math.atan2(y * a + m * r * g, (1 - l) * Math.sqrt(b * b + E * E)),\n            O = l / 16 * k * (4 + l * (4 - 3 * k)),\n            D = h + 180 * (Math.atan2(r * f, m * a - y * r * g) - (1 - O) * l * b * (C + O * r * (n + O * a * (2 * n * n - 1)))) / p,\n            B = 180 * S / p;\n          return L.latLng(D, B);\n        }\n        function N(t, e, i, n) {\n          for (var r, a, o = !(arguments.length > 4 && arguments[4] !== undefined) || arguments[4], s = [], l = 0; l < i; l += 1) {\n            if (o) r = G(t, 360 * l / i + n, e), a = L.latLng(r.lng, r.lat);else {\n              var h = t.lat + Math.cos(2 * l * Math.PI / i) * e,\n                u = t.lng + Math.sin(2 * l * Math.PI / i) * e;\n              a = L.latLng(h, u);\n            }\n            s.push(a);\n          }\n          return s;\n        }\n        function z(t, e, i, n) {\n          var r = function (t, e, i) {\n            var n = t.latLngToContainerPoint(e),\n              r = t.latLngToContainerPoint(i),\n              a = 180 * Math.atan2(r.y - n.y, r.x - n.x) / Math.PI + 90;\n            return a + (a < 0 ? 360 : 0);\n          }(t, e, i);\n          return function (t, e, i) {\n            e = (e + 360) % 360;\n            var n = Math.PI / 180,\n              r = 180 / Math.PI,\n              a = 6378137,\n              o = t.lng * n,\n              s = t.lat * n,\n              l = e * n,\n              h = Math.sin(s),\n              u = Math.cos(s),\n              c = Math.cos(i / a),\n              p = Math.sin(i / a),\n              d = Math.asin(h * c + u * p * Math.cos(l)),\n              f = o + Math.atan2(Math.sin(l) * p * u, c - h * Math.sin(d));\n            return f = (f *= r) > 180 ? f - 360 : f < -180 ? f + 360 : f, L.latLng([d * r, f]);\n          }(e, r, n);\n        }\n        function F(t, e) {\n          var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"asc\";\n          if (!e || 0 === Object.keys(e).length) return function (t, e) {\n            return t - e;\n          };\n          for (var n, r = Object.keys(e), a = r.length - 1, o = {}; a >= 0;) n = r[a], o[n.toLowerCase()] = e[n], a -= 1;\n          function s(t) {\n            return t instanceof L.Marker ? \"Marker\" : t instanceof L.Circle ? \"Circle\" : t instanceof L.CircleMarker ? \"CircleMarker\" : t instanceof L.Rectangle ? \"Rectangle\" : t instanceof L.Polygon ? \"Polygon\" : t instanceof L.Polyline ? \"Line\" : undefined;\n          }\n          return function (e, n) {\n            var r, a;\n            if (\"instanceofShape\" === t) {\n              if (r = s(e.layer).toLowerCase(), a = s(n.layer).toLowerCase(), !r || !a) return 0;\n            } else {\n              if (!e.hasOwnProperty(t) || !n.hasOwnProperty(t)) return 0;\n              r = e[t].toLowerCase(), a = n[t].toLowerCase();\n            }\n            var l = r in o ? o[r] : Number.MAX_SAFE_INTEGER,\n              h = a in o ? o[a] : Number.MAX_SAFE_INTEGER,\n              u = 0;\n            return l < h ? u = -1 : l > h && (u = 1), \"desc\" === i ? -1 * u : u;\n          };\n        }\n        function U(t) {\n          var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : t.getLatLngs();\n          return t instanceof L.Polygon ? L.polygon(e).getLatLngs() : L.polyline(e).getLatLngs();\n        }\n        function V(t, e) {\n          var i, n;\n          if (null !== (i = e.options.crs) && void 0 !== i && null !== (n = i.projection) && void 0 !== n && n.MAX_LATITUDE) {\n            var r,\n              a,\n              o = null === (r = e.options.crs) || void 0 === r || null === (a = r.projection) || void 0 === a ? void 0 : a.MAX_LATITUDE;\n            t.lat = Math.max(Math.min(o, t.lat), -o);\n          }\n          return t;\n        }\n        function K(t) {\n          return t.options.renderer || t._map && (t._map._getPaneRenderer(t.options.pane) || t._map.options.renderer || t._map._renderer) || t._renderer;\n        }\n        const H = L.Class.extend({\n          includes: [b, k, M, x, S],\n          initialize: function (t) {\n            this.map = t, this.Draw = new L.PM.Draw(t), this.Toolbar = new L.PM.Toolbar(t), this.Keyboard = O, this.globalOptions = {\n              snappable: !0,\n              layerGroup: undefined,\n              snappingOrder: [\"Marker\", \"CircleMarker\", \"Circle\", \"Line\", \"Polygon\", \"Rectangle\"],\n              panes: {\n                vertexPane: \"markerPane\",\n                layerPane: \"overlayPane\",\n                markerPane: \"markerPane\"\n              },\n              draggable: !0\n            }, this.Keyboard._initKeyListener(t);\n          },\n          setLang: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"en\",\n              e = arguments.length > 1 ? arguments[1] : undefined,\n              i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"en\",\n              n = L.PM.activeLang;\n            e && (_[t] = r()(_[i], e)), L.PM.activeLang = t, this.map.pm.Toolbar.reinit(), this._fireLangChange(n, t, i, _[t]);\n          },\n          addControls: function (t) {\n            this.Toolbar.addControls(t);\n          },\n          removeControls: function () {\n            this.Toolbar.removeControls();\n          },\n          toggleControls: function () {\n            this.Toolbar.toggleControls();\n          },\n          controlsVisible: function () {\n            return this.Toolbar.isVisible;\n          },\n          enableDraw: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Polygon\",\n              e = arguments.length > 1 ? arguments[1] : undefined;\n            \"Poly\" === t && (t = \"Polygon\"), this.Draw.enable(t, e);\n          },\n          disableDraw: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Polygon\";\n            \"Poly\" === t && (t = \"Polygon\"), this.Draw.disable(t);\n          },\n          setPathOptions: function (t) {\n            var e = this,\n              i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n              n = i.ignoreShapes || [],\n              r = i.merge || !1;\n            this.map.pm.Draw.shapes.forEach(function (i) {\n              -1 === n.indexOf(i) && e.map.pm.Draw[i].setPathOptions(t, r);\n            });\n          },\n          getGlobalOptions: function () {\n            return this.globalOptions;\n          },\n          setGlobalOptions: function (t) {\n            var e = this,\n              i = r()(this.globalOptions, t),\n              n = !1;\n            this.map.pm.Draw.CircleMarker.enabled() && !!this.map.pm.Draw.CircleMarker.options.editable != !!i.editable && (this.map.pm.Draw.CircleMarker.disable(), n = !0), this.map.pm.Draw.shapes.forEach(function (t) {\n              e.map.pm.Draw[t].setOptions(i);\n            }), n && this.map.pm.Draw.CircleMarker.enable(), L.PM.Utils.findLayers(this.map).forEach(function (t) {\n              t.pm.setOptions(i);\n            }), this.map.fire(\"pm:globaloptionschanged\"), this.globalOptions = i, this.applyGlobalOptions();\n          },\n          applyGlobalOptions: function () {\n            L.PM.Utils.findLayers(this.map).forEach(function (t) {\n              t.pm.enabled() && t.pm.applyOptions();\n            });\n          },\n          globalDrawModeEnabled: function () {\n            return !!this.Draw.getActiveShape();\n          },\n          globalCutModeEnabled: function () {\n            return !!this.Draw.Cut.enabled();\n          },\n          enableGlobalCutMode: function (t) {\n            return this.Draw.Cut.enable(t);\n          },\n          toggleGlobalCutMode: function (t) {\n            return this.Draw.Cut.toggle(t);\n          },\n          disableGlobalCutMode: function () {\n            return this.Draw.Cut.disable();\n          },\n          getGeomanLayers: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined && arguments[0],\n              e = L.PM.Utils.findLayers(this.map);\n            if (!t) return e;\n            var i = L.featureGroup();\n            return i._pmTempLayer = !0, e.forEach(function (t) {\n              i.addLayer(t);\n            }), i;\n          },\n          getGeomanDrawLayers: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined && arguments[0],\n              e = L.PM.Utils.findLayers(this.map).filter(function (t) {\n                return !0 === t._drawnByGeoman;\n              });\n            if (!t) return e;\n            var i = L.featureGroup();\n            return i._pmTempLayer = !0, e.forEach(function (t) {\n              i.addLayer(t);\n            }), i;\n          },\n          _getContainingLayer: function () {\n            return this.globalOptions.layerGroup && this.globalOptions.layerGroup instanceof L.LayerGroup ? this.globalOptions.layerGroup : this.map;\n          },\n          _isCRSSimple: function () {\n            return this.map.options.crs === L.CRS.Simple;\n          },\n          _touchEventCounter: 0,\n          _addTouchEvents: function (t) {\n            0 === this._touchEventCounter && (L.DomEvent.on(t, \"touchmove\", this._canvasTouchMove, this), L.DomEvent.on(t, \"touchstart touchend touchcancel\", this._canvasTouchClick, this)), this._touchEventCounter += 1;\n          },\n          _removeTouchEvents: function (t) {\n            1 === this._touchEventCounter && (L.DomEvent.off(t, \"touchmove\", this._canvasTouchMove, this), L.DomEvent.off(t, \"touchstart touchend touchcancel\", this._canvasTouchClick, this)), this._touchEventCounter = this._touchEventCounter <= 1 ? 0 : this._touchEventCounter - 1;\n          },\n          _canvasTouchMove: function (t) {\n            K(this.map)._onMouseMove(this._createMouseEvent(\"mousemove\", t));\n          },\n          _canvasTouchClick: function (t) {\n            var e = \"\";\n            \"touchstart\" === t.type || \"pointerdown\" === t.type ? e = \"mousedown\" : \"touchend\" === t.type || \"pointerup\" === t.type ? e = \"mouseup\" : \"touchcancel\" !== t.type && \"pointercancel\" !== t.type || (e = \"mouseup\"), e && K(this.map)._onClick(this._createMouseEvent(e, t));\n          },\n          _createMouseEvent: function (t, e) {\n            var i,\n              n = e.touches[0] || e.changedTouches[0];\n            try {\n              i = new MouseEvent(t, {\n                bubbles: e.bubbles,\n                cancelable: e.cancelable,\n                view: e.view,\n                detail: n.detail,\n                screenX: n.screenX,\n                screenY: n.screenY,\n                clientX: n.clientX,\n                clientY: n.clientY,\n                ctrlKey: e.ctrlKey,\n                altKey: e.altKey,\n                shiftKey: e.shiftKey,\n                metaKey: e.metaKey,\n                button: e.button,\n                relatedTarget: e.relatedTarget\n              });\n            } catch (r) {\n              (i = document.createEvent(\"MouseEvents\")).initMouseEvent(t, e.bubbles, e.cancelable, e.view, n.detail, n.screenX, n.screenY, n.clientX, n.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget);\n            }\n            return i;\n          }\n        });\n        const q = L.Control.extend({\n          includes: [S],\n          options: {\n            position: \"topleft\",\n            disableByOtherButtons: !0\n          },\n          initialize: function (t) {\n            this._button = L.Util.extend({}, this.options, t);\n          },\n          onAdd: function (t) {\n            return this._map = t, this._map.pm.Toolbar.options.oneBlock ? this._container = this._map.pm.Toolbar._createContainer(this.options.position) : \"edit\" === this._button.tool ? this._container = this._map.pm.Toolbar.editContainer : \"options\" === this._button.tool ? this._container = this._map.pm.Toolbar.optionsContainer : \"custom\" === this._button.tool ? this._container = this._map.pm.Toolbar.customContainer : this._container = this._map.pm.Toolbar.drawContainer, this.buttonsDomNode = this._makeButton(this._button), this._container.appendChild(this.buttonsDomNode), this._container;\n          },\n          onRemove: function () {\n            return this.buttonsDomNode.remove(), this._container;\n          },\n          getText: function () {\n            return this._button.text;\n          },\n          getIconUrl: function () {\n            return this._button.iconUrl;\n          },\n          destroy: function () {\n            this._button = {}, this._update();\n          },\n          toggle: function (t) {\n            return this._button.toggleStatus = \"boolean\" == typeof t ? t : !this._button.toggleStatus, this._applyStyleClasses(), this._button.toggleStatus;\n          },\n          toggled: function () {\n            return this._button.toggleStatus;\n          },\n          onCreate: function () {\n            this.toggle(!1);\n          },\n          disable: function () {\n            this.toggle(!1), this._button.disabled = !0, this._updateDisabled();\n          },\n          enable: function () {\n            this._button.disabled = !1, this._updateDisabled();\n          },\n          _triggerClick: function (t) {\n            t && t.preventDefault(), this._button.disabled || (this._button.onClick(t, {\n              button: this,\n              event: t\n            }), this._clicked(t), this._button.afterClick(t, {\n              button: this,\n              event: t\n            }));\n          },\n          _makeButton: function (t) {\n            var e = this,\n              i = this.options.position.indexOf(\"right\") > -1 ? \"pos-right\" : \"\",\n              n = L.DomUtil.create(\"div\", \"button-container  \".concat(i), this._container);\n            t.title && n.setAttribute(\"title\", t.title);\n            var r = L.DomUtil.create(\"a\", \"leaflet-buttons-control-button\", n);\n            r.setAttribute(\"role\", \"button\"), r.setAttribute(\"tabindex\", \"0\"), r.href = \"#\";\n            var a = L.DomUtil.create(\"div\", \"leaflet-pm-actions-container \".concat(i), n),\n              o = t.actions,\n              s = {\n                cancel: {\n                  text: I(\"actions.cancel\"),\n                  onClick: function () {\n                    this._triggerClick();\n                  }\n                },\n                finishMode: {\n                  text: I(\"actions.finish\"),\n                  onClick: function () {\n                    this._triggerClick();\n                  }\n                },\n                removeLastVertex: {\n                  text: I(\"actions.removeLastVertex\"),\n                  onClick: function () {\n                    this._map.pm.Draw[t.jsClass]._removeLastVertex();\n                  }\n                },\n                finish: {\n                  text: I(\"actions.finish\"),\n                  onClick: function (e) {\n                    this._map.pm.Draw[t.jsClass]._finishShape(e);\n                  }\n                }\n              };\n            o.forEach(function (n) {\n              var r,\n                o = \"string\" == typeof n ? n : n.name;\n              if (s[o]) r = s[o];else {\n                if (!n.text) return;\n                r = n;\n              }\n              var l = L.DomUtil.create(\"a\", \"leaflet-pm-action \".concat(i, \" action-\").concat(o), a);\n              if (l.setAttribute(\"role\", \"button\"), l.setAttribute(\"tabindex\", \"0\"), l.href = \"#\", l.innerHTML = r.text, L.DomEvent.disableClickPropagation(l), L.DomEvent.on(l, \"click\", L.DomEvent.stop), !t.disabled && r.onClick) {\n                L.DomEvent.addListener(l, \"click\", function (i) {\n                  i.preventDefault();\n                  var n = \"\",\n                    a = e._map.pm.Toolbar.buttons;\n                  for (var o in a) if (a[o]._button === t) {\n                    n = o;\n                    break;\n                  }\n                  e._fireActionClick(r, n, t);\n                }, e), L.DomEvent.addListener(l, \"click\", r.onClick, e);\n              }\n            }), t.toggleStatus && L.DomUtil.addClass(n, \"active\");\n            var l = L.DomUtil.create(\"div\", \"control-icon\", r);\n            return t.iconUrl && l.setAttribute(\"src\", t.iconUrl), t.className && L.DomUtil.addClass(l, t.className), L.DomEvent.disableClickPropagation(r), L.DomEvent.on(r, \"click\", L.DomEvent.stop), t.disabled || (L.DomEvent.addListener(r, \"click\", this._onBtnClick, this), L.DomEvent.addListener(r, \"click\", this._triggerClick, this)), t.disabled && (L.DomUtil.addClass(r, \"pm-disabled\"), r.setAttribute(\"aria-disabled\", \"true\")), n;\n          },\n          _applyStyleClasses: function () {\n            this._container && (this._button.toggleStatus && !1 !== this._button.cssToggle ? (L.DomUtil.addClass(this.buttonsDomNode, \"active\"), L.DomUtil.addClass(this._container, \"activeChild\")) : (L.DomUtil.removeClass(this.buttonsDomNode, \"active\"), L.DomUtil.removeClass(this._container, \"activeChild\")));\n          },\n          _onBtnClick: function () {\n            this._button.disableOtherButtons && this._map.pm.Toolbar.triggerClickOnToggledButtons(this);\n            var t = \"\",\n              e = this._map.pm.Toolbar.buttons;\n            for (var i in e) if (e[i]._button === this._button) {\n              t = i;\n              break;\n            }\n            this._fireButtonClick(t, this._button);\n          },\n          _clicked: function () {\n            this._button.doToggle && this.toggle();\n          },\n          _updateDisabled: function () {\n            if (this._container) {\n              var t = \"pm-disabled\",\n                e = this.buttonsDomNode.children[0];\n              this._button.disabled ? (L.DomUtil.addClass(e, t), e.setAttribute(\"aria-disabled\", \"true\"), L.DomEvent.off(e, \"click\", this._triggerClick, this), L.DomEvent.off(e, \"click\", this._onBtnClick, this)) : (L.DomUtil.removeClass(e, t), e.setAttribute(\"aria-disabled\", \"false\"), L.DomEvent.on(e, \"click\", this._triggerClick, this), L.DomEvent.on(e, \"click\", this._onBtnClick, this));\n            }\n          }\n        });\n        function J(t, e) {\n          var i = Object.keys(t);\n          if (Object.getOwnPropertySymbols) {\n            var n = Object.getOwnPropertySymbols(t);\n            e && (n = n.filter(function (e) {\n              return Object.getOwnPropertyDescriptor(t, e).enumerable;\n            })), i.push.apply(i, n);\n          }\n          return i;\n        }\n        function Y(t) {\n          for (var e = 1; e < arguments.length; e++) {\n            var i = null != arguments[e] ? arguments[e] : {};\n            e % 2 ? J(Object(i), !0).forEach(function (e) {\n              X(t, e, i[e]);\n            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : J(Object(i)).forEach(function (e) {\n              Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e));\n            });\n          }\n          return t;\n        }\n        function X(t, e, i) {\n          return e in t ? Object.defineProperty(t, e, {\n            value: i,\n            enumerable: !0,\n            configurable: !0,\n            writable: !0\n          }) : t[e] = i, t;\n        }\n        function Z(t) {\n          return Z = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n            return typeof t;\n          } : function (t) {\n            return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n          }, Z(t);\n        }\n        L.Control.PMButton = q;\n        const $ = L.Class.extend({\n          options: {\n            drawMarker: !0,\n            drawRectangle: !0,\n            drawPolyline: !0,\n            drawPolygon: !0,\n            drawCircle: !0,\n            drawCircleMarker: !0,\n            drawText: !0,\n            editMode: !0,\n            dragMode: !0,\n            cutPolygon: !0,\n            removalMode: !0,\n            rotateMode: !0,\n            snappingOption: !0,\n            drawControls: !0,\n            editControls: !0,\n            optionsControls: !0,\n            customControls: !0,\n            oneBlock: !1,\n            position: \"topleft\",\n            positions: {\n              draw: \"\",\n              edit: \"\",\n              options: \"\",\n              custom: \"\"\n            }\n          },\n          customButtons: [],\n          initialize: function (t) {\n            this.init(t);\n          },\n          reinit: function () {\n            var t = this.isVisible;\n            this.removeControls(), this._defineButtons(), t && this.addControls();\n          },\n          init: function (t) {\n            this.map = t, this.buttons = {}, this.isVisible = !1, this.drawContainer = L.DomUtil.create(\"div\", \"leaflet-pm-toolbar leaflet-pm-draw leaflet-bar leaflet-control\"), this.editContainer = L.DomUtil.create(\"div\", \"leaflet-pm-toolbar leaflet-pm-edit leaflet-bar leaflet-control\"), this.optionsContainer = L.DomUtil.create(\"div\", \"leaflet-pm-toolbar leaflet-pm-options leaflet-bar leaflet-control\"), this.customContainer = L.DomUtil.create(\"div\", \"leaflet-pm-toolbar leaflet-pm-custom leaflet-bar leaflet-control\"), this._defineButtons();\n          },\n          _createContainer: function (t) {\n            var e = \"\".concat(t, \"Container\");\n            return this[e] || (this[e] = L.DomUtil.create(\"div\", \"leaflet-pm-toolbar leaflet-pm-\".concat(t, \" leaflet-bar leaflet-control\"))), this[e];\n          },\n          getButtons: function () {\n            return this.buttons;\n          },\n          addControls: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options;\n            \"undefined\" != typeof t.editPolygon && (t.editMode = t.editPolygon), \"undefined\" != typeof t.deleteLayer && (t.removalMode = t.deleteLayer), L.Util.setOptions(this, t), this.applyIconStyle(), this.isVisible = !0, this._showHideButtons();\n          },\n          applyIconStyle: function () {\n            var t = this.getButtons(),\n              e = {\n                geomanIcons: {\n                  drawMarker: \"control-icon leaflet-pm-icon-marker\",\n                  drawPolyline: \"control-icon leaflet-pm-icon-polyline\",\n                  drawRectangle: \"control-icon leaflet-pm-icon-rectangle\",\n                  drawPolygon: \"control-icon leaflet-pm-icon-polygon\",\n                  drawCircle: \"control-icon leaflet-pm-icon-circle\",\n                  drawCircleMarker: \"control-icon leaflet-pm-icon-circle-marker\",\n                  editMode: \"control-icon leaflet-pm-icon-edit\",\n                  dragMode: \"control-icon leaflet-pm-icon-drag\",\n                  cutPolygon: \"control-icon leaflet-pm-icon-cut\",\n                  removalMode: \"control-icon leaflet-pm-icon-delete\",\n                  drawText: \"control-icon leaflet-pm-icon-text\"\n                }\n              };\n            for (var i in t) {\n              var n = t[i];\n              L.Util.setOptions(n, {\n                className: e.geomanIcons[i]\n              });\n            }\n          },\n          removeControls: function () {\n            var t = this.getButtons();\n            for (var e in t) t[e].remove();\n            this.isVisible = !1;\n          },\n          toggleControls: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options;\n            this.isVisible ? this.removeControls() : this.addControls(t);\n          },\n          _addButton: function (t, e) {\n            return this.buttons[t] = e, this.options[t] = this.options[t] || !1, this.buttons[t];\n          },\n          triggerClickOnToggledButtons: function (t) {\n            for (var e in this.buttons) {\n              var i = this.buttons[e];\n              i._button.disableByOtherButtons && i !== t && i.toggled() && i._triggerClick();\n            }\n          },\n          toggleButton: function (t, e) {\n            var i = !(arguments.length > 2 && arguments[2] !== undefined) || arguments[2];\n            return \"editPolygon\" === t && (t = \"editMode\"), \"deleteLayer\" === t && (t = \"removalMode\"), i && this.triggerClickOnToggledButtons(this.buttons[t]), !!this.buttons[t] && this.buttons[t].toggle(e);\n          },\n          _defineButtons: function () {\n            var t = this,\n              e = {\n                className: \"control-icon leaflet-pm-icon-marker\",\n                title: I(\"buttonTitles.drawMarkerButton\"),\n                jsClass: \"Marker\",\n                onClick: function () {},\n                afterClick: function (e, i) {\n                  t.map.pm.Draw[i.button._button.jsClass].toggle();\n                },\n                doToggle: !0,\n                toggleStatus: !1,\n                disableOtherButtons: !0,\n                position: this.options.position,\n                actions: [\"cancel\"]\n              },\n              i = {\n                title: I(\"buttonTitles.drawPolyButton\"),\n                className: \"control-icon leaflet-pm-icon-polygon\",\n                jsClass: \"Polygon\",\n                onClick: function () {},\n                afterClick: function (e, i) {\n                  t.map.pm.Draw[i.button._button.jsClass].toggle();\n                },\n                doToggle: !0,\n                toggleStatus: !1,\n                disableOtherButtons: !0,\n                position: this.options.position,\n                actions: [\"finish\", \"removeLastVertex\", \"cancel\"]\n              },\n              n = {\n                className: \"control-icon leaflet-pm-icon-polyline\",\n                title: I(\"buttonTitles.drawLineButton\"),\n                jsClass: \"Line\",\n                onClick: function () {},\n                afterClick: function (e, i) {\n                  t.map.pm.Draw[i.button._button.jsClass].toggle();\n                },\n                doToggle: !0,\n                toggleStatus: !1,\n                disableOtherButtons: !0,\n                position: this.options.position,\n                actions: [\"finish\", \"removeLastVertex\", \"cancel\"]\n              },\n              r = {\n                title: I(\"buttonTitles.drawCircleButton\"),\n                className: \"control-icon leaflet-pm-icon-circle\",\n                jsClass: \"Circle\",\n                onClick: function () {},\n                afterClick: function (e, i) {\n                  t.map.pm.Draw[i.button._button.jsClass].toggle();\n                },\n                doToggle: !0,\n                toggleStatus: !1,\n                disableOtherButtons: !0,\n                position: this.options.position,\n                actions: [\"cancel\"]\n              },\n              a = {\n                title: I(\"buttonTitles.drawCircleMarkerButton\"),\n                className: \"control-icon leaflet-pm-icon-circle-marker\",\n                jsClass: \"CircleMarker\",\n                onClick: function () {},\n                afterClick: function (e, i) {\n                  t.map.pm.Draw[i.button._button.jsClass].toggle();\n                },\n                doToggle: !0,\n                toggleStatus: !1,\n                disableOtherButtons: !0,\n                position: this.options.position,\n                actions: [\"cancel\"]\n              },\n              o = {\n                title: I(\"buttonTitles.drawRectButton\"),\n                className: \"control-icon leaflet-pm-icon-rectangle\",\n                jsClass: \"Rectangle\",\n                onClick: function () {},\n                afterClick: function (e, i) {\n                  t.map.pm.Draw[i.button._button.jsClass].toggle();\n                },\n                doToggle: !0,\n                toggleStatus: !1,\n                disableOtherButtons: !0,\n                position: this.options.position,\n                actions: [\"cancel\"]\n              },\n              s = {\n                title: I(\"buttonTitles.editButton\"),\n                className: \"control-icon leaflet-pm-icon-edit\",\n                onClick: function () {},\n                afterClick: function () {\n                  t.map.pm.toggleGlobalEditMode();\n                },\n                doToggle: !0,\n                toggleStatus: !1,\n                disableOtherButtons: !0,\n                position: this.options.position,\n                tool: \"edit\",\n                actions: [\"finishMode\"]\n              },\n              l = {\n                title: I(\"buttonTitles.dragButton\"),\n                className: \"control-icon leaflet-pm-icon-drag\",\n                onClick: function () {},\n                afterClick: function () {\n                  t.map.pm.toggleGlobalDragMode();\n                },\n                doToggle: !0,\n                toggleStatus: !1,\n                disableOtherButtons: !0,\n                position: this.options.position,\n                tool: \"edit\",\n                actions: [\"finishMode\"]\n              },\n              h = {\n                title: I(\"buttonTitles.cutButton\"),\n                className: \"control-icon leaflet-pm-icon-cut\",\n                jsClass: \"Cut\",\n                onClick: function () {},\n                afterClick: function (e, i) {\n                  t.map.pm.Draw[i.button._button.jsClass].toggle({\n                    snappable: !0,\n                    cursorMarker: !0,\n                    allowSelfIntersection: !1\n                  });\n                },\n                doToggle: !0,\n                toggleStatus: !1,\n                disableOtherButtons: !0,\n                position: this.options.position,\n                tool: \"edit\",\n                actions: [\"finish\", \"removeLastVertex\", \"cancel\"]\n              },\n              u = {\n                title: I(\"buttonTitles.deleteButton\"),\n                className: \"control-icon leaflet-pm-icon-delete\",\n                onClick: function () {},\n                afterClick: function () {\n                  t.map.pm.toggleGlobalRemovalMode();\n                },\n                doToggle: !0,\n                toggleStatus: !1,\n                disableOtherButtons: !0,\n                position: this.options.position,\n                tool: \"edit\",\n                actions: [\"finishMode\"]\n              },\n              c = {\n                title: I(\"buttonTitles.rotateButton\"),\n                className: \"control-icon leaflet-pm-icon-rotate\",\n                onClick: function () {},\n                afterClick: function () {\n                  t.map.pm.toggleGlobalRotateMode();\n                },\n                doToggle: !0,\n                toggleStatus: !1,\n                disableOtherButtons: !0,\n                position: this.options.position,\n                tool: \"edit\",\n                actions: [\"finishMode\"]\n              },\n              p = {\n                className: \"control-icon leaflet-pm-icon-text\",\n                title: I(\"buttonTitles.drawTextButton\"),\n                jsClass: \"Text\",\n                onClick: function () {},\n                afterClick: function (e, i) {\n                  t.map.pm.Draw[i.button._button.jsClass].toggle();\n                },\n                doToggle: !0,\n                toggleStatus: !1,\n                disableOtherButtons: !0,\n                position: this.options.position,\n                actions: [\"cancel\"]\n              };\n            this._addButton(\"drawMarker\", new L.Control.PMButton(e)), this._addButton(\"drawPolyline\", new L.Control.PMButton(n)), this._addButton(\"drawRectangle\", new L.Control.PMButton(o)), this._addButton(\"drawPolygon\", new L.Control.PMButton(i)), this._addButton(\"drawCircle\", new L.Control.PMButton(r)), this._addButton(\"drawCircleMarker\", new L.Control.PMButton(a)), this._addButton(\"drawText\", new L.Control.PMButton(p)), this._addButton(\"editMode\", new L.Control.PMButton(s)), this._addButton(\"dragMode\", new L.Control.PMButton(l)), this._addButton(\"cutPolygon\", new L.Control.PMButton(h)), this._addButton(\"removalMode\", new L.Control.PMButton(u)), this._addButton(\"rotateMode\", new L.Control.PMButton(c));\n          },\n          _showHideButtons: function () {\n            if (this.isVisible) {\n              this.removeControls(), this.isVisible = !0;\n              var t = this.getButtons(),\n                e = [];\n              for (var i in !1 === this.options.drawControls && (e = e.concat(Object.keys(t).filter(function (e) {\n                return !t[e]._button.tool;\n              }))), !1 === this.options.editControls && (e = e.concat(Object.keys(t).filter(function (e) {\n                return \"edit\" === t[e]._button.tool;\n              }))), !1 === this.options.optionsControls && (e = e.concat(Object.keys(t).filter(function (e) {\n                return \"options\" === t[e]._button.tool;\n              }))), !1 === this.options.customControls && (e = e.concat(Object.keys(t).filter(function (e) {\n                return \"custom\" === t[e]._button.tool;\n              }))), t) if (this.options[i] && -1 === e.indexOf(i)) {\n                var n = t[i]._button.tool;\n                n || (n = \"draw\"), t[i].setPosition(this._getBtnPosition(n)), t[i].addTo(this.map);\n              }\n            }\n          },\n          _getBtnPosition: function (t) {\n            return this.options.positions && this.options.positions[t] ? this.options.positions[t] : this.options.position;\n          },\n          setBlockPosition: function (t, e) {\n            this.options.positions[t] = e, this._showHideButtons(), this.changeControlOrder();\n          },\n          getBlockPositions: function () {\n            return this.options.positions;\n          },\n          copyDrawControl: function (t, e) {\n            if (!e) throw new TypeError(\"Button has no name\");\n            \"object\" !== Z(e) && (e = {\n              name: e\n            });\n            var i = this._btnNameMapping(t);\n            if (!e.name) throw new TypeError(\"Button has no name\");\n            if (this.buttons[e.name]) throw new TypeError(\"Button with this name already exists\");\n            var n = this.map.pm.Draw.createNewDrawInstance(e.name, i);\n            return e = Y(Y({}, this.buttons[i]._button), e), {\n              drawInstance: n,\n              control: this.createCustomControl(e)\n            };\n          },\n          createCustomControl: function (t) {\n            var e, i;\n            if (!t.name) throw new TypeError(\"Button has no name\");\n            if (this.buttons[t.name]) throw new TypeError(\"Button with this name already exists\");\n            t.onClick || (t.onClick = function () {}), t.afterClick || (t.afterClick = function () {}), !1 !== t.toggle && (t.toggle = !0), t.block && (t.block = t.block.toLowerCase()), t.block && \"draw\" !== t.block || (t.block = \"\"), t.className ? -1 === t.className.indexOf(\"control-icon\") && (t.className = \"control-icon \".concat(t.className)) : t.className = \"control-icon\";\n            var n = {\n              tool: t.block,\n              className: t.className,\n              title: t.title || \"\",\n              jsClass: t.name,\n              onClick: t.onClick,\n              afterClick: t.afterClick,\n              doToggle: t.toggle,\n              toggleStatus: !1,\n              disableOtherButtons: null === (e = t.disableOtherButtons) || void 0 === e || e,\n              disableByOtherButtons: null === (i = t.disableByOtherButtons) || void 0 === i || i,\n              cssToggle: t.toggle,\n              position: this.options.position,\n              actions: t.actions || [],\n              disabled: !!t.disabled\n            };\n            !1 !== this.options[t.name] && (this.options[t.name] = !0);\n            var r = this._addButton(t.name, new L.Control.PMButton(n));\n            return this.changeControlOrder(), r;\n          },\n          changeControlOrder: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [],\n              e = this._shapeMapping(),\n              i = [];\n            t.forEach(function (t) {\n              e[t] ? i.push(e[t]) : i.push(t);\n            });\n            var n = this.getButtons(),\n              r = {};\n            i.forEach(function (t) {\n              n[t] && (r[t] = n[t]);\n            });\n            var a = Object.keys(n).filter(function (t) {\n              return !n[t]._button.tool;\n            });\n            a.forEach(function (t) {\n              -1 === i.indexOf(t) && (r[t] = n[t]);\n            });\n            var o = Object.keys(n).filter(function (t) {\n              return \"edit\" === n[t]._button.tool;\n            });\n            o.forEach(function (t) {\n              -1 === i.indexOf(t) && (r[t] = n[t]);\n            });\n            var s = Object.keys(n).filter(function (t) {\n              return \"options\" === n[t]._button.tool;\n            });\n            s.forEach(function (t) {\n              -1 === i.indexOf(t) && (r[t] = n[t]);\n            });\n            var l = Object.keys(n).filter(function (t) {\n              return \"custom\" === n[t]._button.tool;\n            });\n            l.forEach(function (t) {\n              -1 === i.indexOf(t) && (r[t] = n[t]);\n            }), Object.keys(n).forEach(function (t) {\n              -1 === i.indexOf(t) && (r[t] = n[t]);\n            }), this.map.pm.Toolbar.buttons = r, this._showHideButtons();\n          },\n          getControlOrder: function () {\n            var t = this.getButtons(),\n              e = [];\n            for (var i in t) e.push(i);\n            return e;\n          },\n          changeActionsOfControl: function (t, e) {\n            var i = this._btnNameMapping(t);\n            if (!i) throw new TypeError(\"No name passed\");\n            if (!e) throw new TypeError(\"No actions passed\");\n            if (!this.buttons[i]) throw new TypeError(\"Button with this name not exists\");\n            this.buttons[i]._button.actions = e, this.changeControlOrder();\n          },\n          setButtonDisabled: function (t, e) {\n            var i = this._btnNameMapping(t);\n            e ? this.buttons[i].disable() : this.buttons[i].enable();\n          },\n          _shapeMapping: function () {\n            return {\n              Marker: \"drawMarker\",\n              Circle: \"drawCircle\",\n              Polygon: \"drawPolygon\",\n              Rectangle: \"drawRectangle\",\n              Polyline: \"drawPolyline\",\n              Line: \"drawPolyline\",\n              CircleMarker: \"drawCircleMarker\",\n              Edit: \"editMode\",\n              Drag: \"dragMode\",\n              Cut: \"cutPolygon\",\n              Removal: \"removalMode\",\n              Rotate: \"rotateMode\",\n              Text: \"drawText\"\n            };\n          },\n          _btnNameMapping: function (t) {\n            var e = this._shapeMapping();\n            return e[t] ? e[t] : t;\n          }\n        });\n        function W(t, e) {\n          var i = Object.keys(t);\n          if (Object.getOwnPropertySymbols) {\n            var n = Object.getOwnPropertySymbols(t);\n            e && (n = n.filter(function (e) {\n              return Object.getOwnPropertyDescriptor(t, e).enumerable;\n            })), i.push.apply(i, n);\n          }\n          return i;\n        }\n        function Q(t) {\n          for (var e = 1; e < arguments.length; e++) {\n            var i = null != arguments[e] ? arguments[e] : {};\n            e % 2 ? W(Object(i), !0).forEach(function (e) {\n              tt(t, e, i[e]);\n            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : W(Object(i)).forEach(function (e) {\n              Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e));\n            });\n          }\n          return t;\n        }\n        function tt(t, e, i) {\n          return e in t ? Object.defineProperty(t, e, {\n            value: i,\n            enumerable: !0,\n            configurable: !0,\n            writable: !0\n          }) : t[e] = i, t;\n        }\n        var et = {\n          _initSnappableMarkers: function () {\n            this.options.snapDistance = this.options.snapDistance || 30, this.options.snapSegment = this.options.snapSegment === undefined || this.options.snapSegment, this._assignEvents(this._markers), this._layer.off(\"pm:dragstart\", this._unsnap, this), this._layer.on(\"pm:dragstart\", this._unsnap, this);\n          },\n          _disableSnapping: function () {\n            this._layer.off(\"pm:dragstart\", this._unsnap, this);\n          },\n          _assignEvents: function (t) {\n            var e = this;\n            t.forEach(function (t) {\n              Array.isArray(t) ? e._assignEvents(t) : (t.off(\"drag\", e._handleSnapping, e), t.on(\"drag\", e._handleSnapping, e), t.off(\"dragend\", e._cleanupSnapping, e), t.on(\"dragend\", e._cleanupSnapping, e));\n            });\n          },\n          _cleanupSnapping: function (t) {\n            t && (t.target._snapped = !1);\n            delete this._snapList, this.throttledList && (this._map.off(\"layeradd\", this.throttledList, this), this.throttledList = undefined), this._map.off(\"pm:remove\", this._handleSnapLayerRemoval, this), this.debugIndicatorLines && this.debugIndicatorLines.forEach(function (t) {\n              t.remove();\n            });\n          },\n          _handleThrottleSnapping: function () {\n            this.throttledList && this._createSnapList();\n          },\n          _handleSnapping: function (t) {\n            var e = this,\n              i = t.target;\n            if (i._snapped = !1, this.throttledList || (this.throttledList = L.Util.throttle(this._handleThrottleSnapping, 100, this)), this._map.pm.Keyboard.isAltKeyPressed()) return !1;\n            if (this._snapList === undefined && (this._createSnapList(), this._map.off(\"layeradd\", this.throttledList, this), this._map.on(\"layeradd\", this.throttledList, this)), this._snapList.length <= 0) return !1;\n            var n = this._calcClosestLayer(i.getLatLng(), this._snapList);\n            if (0 === Object.keys(n).length) return !1;\n            var r,\n              a = n.layer instanceof L.Marker || n.layer instanceof L.CircleMarker || !this.options.snapSegment;\n            r = a ? n.latlng : this._checkPrioritiySnapping(n);\n            var o = this.options.snapDistance,\n              s = {\n                marker: i,\n                shape: this._shape,\n                snapLatLng: r,\n                segment: n.segment,\n                layer: this._layer,\n                workingLayer: this._layer,\n                layerInteractedWith: n.layer,\n                distance: n.distance\n              };\n            if (this._fireSnapDrag(s.marker, s), this._fireSnapDrag(this._layer, s), n.distance < o) {\n              i._orgLatLng = i.getLatLng(), i.setLatLng(r), i._snapped = !0, i._snapInfo = s;\n              var l = this._snapLatLng || {},\n                h = r || {};\n              l.lat === h.lat && l.lng === h.lng || (e._snapLatLng = r, e._fireSnap(i, s), e._fireSnap(e._layer, s));\n            } else this._snapLatLng && (this._unsnap(s), i._snapped = !1, i._snapInfo = undefined, this._fireUnsnap(s.marker, s), this._fireUnsnap(this._layer, s));\n            return !0;\n          },\n          _createSnapList: function () {\n            var t = this,\n              e = [],\n              i = [],\n              n = this._map;\n            n.off(\"pm:remove\", this._handleSnapLayerRemoval, this), n.on(\"pm:remove\", this._handleSnapLayerRemoval, this), n.eachLayer(function (t) {\n              if ((t instanceof L.Polyline || t instanceof L.Marker || t instanceof L.CircleMarker || t instanceof L.ImageOverlay) && !0 !== t.options.snapIgnore) {\n                if (t.options.snapIgnore === undefined && (!L.PM.optIn && !0 === t.options.pmIgnore || L.PM.optIn && !1 !== t.options.pmIgnore)) return;\n                (t instanceof L.Circle || t instanceof L.CircleMarker) && t.pm && t.pm._hiddenPolyCircle ? e.push(t.pm._hiddenPolyCircle) : t instanceof L.ImageOverlay && (t = L.rectangle(t.getBounds())), e.push(t);\n                var n = L.polyline([], {\n                  color: \"red\",\n                  pmIgnore: !0\n                });\n                n._pmTempLayer = !0, i.push(n), (t instanceof L.Circle || t instanceof L.CircleMarker) && i.push(n);\n              }\n            }), e = (e = (e = e.filter(function (e) {\n              return t._layer !== e;\n            })).filter(function (t) {\n              return t._latlng || t._latlngs && j(t._latlngs);\n            })).filter(function (t) {\n              return !t._pmTempLayer;\n            }), this._otherSnapLayers ? (this._otherSnapLayers.forEach(function () {\n              var t = L.polyline([], {\n                color: \"red\",\n                pmIgnore: !0\n              });\n              t._pmTempLayer = !0, i.push(t);\n            }), this._snapList = e.concat(this._otherSnapLayers)) : this._snapList = e, this.debugIndicatorLines = i;\n          },\n          _handleSnapLayerRemoval: function (t) {\n            var e = t.layer,\n              i = this._snapList.findIndex(function (t) {\n                return t._leaflet_id === e._leaflet_id;\n              });\n            this._snapList.splice(i, 1);\n          },\n          _calcClosestLayer: function (t, e) {\n            return this._calcClosestLayers(t, e, 1)[0];\n          },\n          _calcClosestLayers: function (t, e) {\n            var i = this,\n              n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1,\n              r = [],\n              a = {};\n            e.forEach(function (e, o) {\n              if (!e._parentCopy || e._parentCopy !== i._layer) {\n                var s = i._calcLayerDistances(t, e);\n                if (s.distance = Math.floor(s.distance), i.debugIndicatorLines) {\n                  if (!i.debugIndicatorLines[o]) {\n                    var l = L.polyline([], {\n                      color: \"red\",\n                      pmIgnore: !0\n                    });\n                    l._pmTempLayer = !0, i.debugIndicatorLines[o] = l;\n                  }\n                  i.debugIndicatorLines[o].setLatLngs([t, s.latlng]);\n                }\n                1 === n && (a.distance === undefined || s.distance <= a.distance) ? (s.distance < a.distance && (r = []), (a = s).layer = e, r.push(a)) : 1 !== n && (a = {}, (a = s).layer = e, r.push(a));\n              }\n            }), 1 !== n && (r = r.sort(function (t, e) {\n              return t.distance - e.distance;\n            })), -1 === n && (n = r.length);\n            var o = this._getClosestLayerByPriority(r, n);\n            return L.Util.isArray(o) ? o : [o];\n          },\n          _calcLayerDistances: function (t, e) {\n            var i = this._map,\n              n = e instanceof L.Marker || e instanceof L.CircleMarker,\n              r = e instanceof L.Polygon,\n              a = t;\n            if (n) {\n              var o = e.getLatLng();\n              return {\n                latlng: Q({}, o),\n                distance: this._getDistance(i, o, a)\n              };\n            }\n            return this._calcLatLngDistances(a, e.getLatLngs(), i, r);\n          },\n          _calcLatLngDistances: function (t, e, i) {\n            var n,\n              r,\n              a,\n              o = this,\n              s = arguments.length > 3 && arguments[3] !== undefined && arguments[3],\n              l = function u(e) {\n                e.forEach(function (l, h) {\n                  if (Array.isArray(l)) u(l);else if (o.options.snapSegment) {\n                    var c,\n                      p = l;\n                    c = s ? h + 1 === e.length ? 0 : h + 1 : h + 1 === e.length ? undefined : h + 1;\n                    var d = e[c];\n                    if (d) {\n                      var f = o._getDistanceToSegment(i, t, p, d);\n                      (r === undefined || f < r) && (r = f, a = [p, d]);\n                    }\n                  } else {\n                    var g = o._getDistance(i, t, l);\n                    (r === undefined || g < r) && (r = g, n = l);\n                  }\n                });\n              };\n            if (l(e), this.options.snapSegment) {\n              var h = this._getClosestPointOnSegment(i, t, a[0], a[1]);\n              return {\n                latlng: Q({}, h),\n                segment: a,\n                distance: r\n              };\n            }\n            return {\n              latlng: n,\n              distance: r\n            };\n          },\n          _getClosestLayerByPriority: function (t) {\n            var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n            t = t.sort(function (t, e) {\n              return t._leaflet_id - e._leaflet_id;\n            });\n            var i = [\"Marker\", \"CircleMarker\", \"Circle\", \"Line\", \"Polygon\", \"Rectangle\"],\n              n = this._map.pm.globalOptions.snappingOrder || [],\n              r = 0,\n              a = {};\n            return n.concat(i).forEach(function (t) {\n              a[t] || (r += 1, a[t] = r);\n            }), t.sort(F(\"instanceofShape\", a)), 1 === e ? t[0] || {} : t.slice(0, e);\n          },\n          _checkPrioritiySnapping: function (t) {\n            var e = this._map,\n              i = t.segment[0],\n              n = t.segment[1],\n              r = t.latlng,\n              a = this._getDistance(e, i, r),\n              o = this._getDistance(e, n, r),\n              s = a < o ? i : n,\n              l = a < o ? a : o;\n            if (this.options.snapMiddle) {\n              var h = L.PM.Utils.calcMiddleLatLng(e, i, n),\n                u = this._getDistance(e, h, r);\n              u < a && u < o && (s = h, l = u);\n            }\n            return Q({}, l < this.options.snapDistance ? s : r);\n          },\n          _unsnap: function () {\n            delete this._snapLatLng;\n          },\n          _getClosestPointOnSegment: function (t, e, i, n) {\n            var r = t.getMaxZoom();\n            r === Infinity && (r = t.getZoom());\n            var a = t.project(e, r),\n              o = t.project(i, r),\n              s = t.project(n, r),\n              l = L.LineUtil.closestPointOnSegment(a, o, s);\n            return t.unproject(l, r);\n          },\n          _getDistanceToSegment: function (t, e, i, n) {\n            var r = t.latLngToLayerPoint(e),\n              a = t.latLngToLayerPoint(i),\n              o = t.latLngToLayerPoint(n);\n            return L.LineUtil.pointToSegmentDistance(r, a, o);\n          },\n          _getDistance: function (t, e, i) {\n            return t.latLngToLayerPoint(e).distanceTo(t.latLngToLayerPoint(i));\n          }\n        };\n        const it = et;\n        const nt = L.Class.extend({\n          includes: [it, S],\n          options: {\n            snappable: !0,\n            snapDistance: 20,\n            snapMiddle: !1,\n            allowSelfIntersection: !0,\n            tooltips: !0,\n            templineStyle: {},\n            hintlineStyle: {\n              color: \"#3388ff\",\n              dashArray: \"5,5\"\n            },\n            pathOptions: null,\n            cursorMarker: !0,\n            finishOn: null,\n            markerStyle: {\n              draggable: !0,\n              icon: L.icon()\n            },\n            hideMiddleMarkers: !1,\n            minRadiusCircle: null,\n            maxRadiusCircle: null,\n            minRadiusCircleMarker: null,\n            maxRadiusCircleMarker: null,\n            editable: !1,\n            markerEditable: !0,\n            continueDrawing: !1,\n            snapSegment: !0,\n            requireSnapToFinish: !1\n          },\n          setOptions: function (t) {\n            L.Util.setOptions(this, t), this.setStyle(this.options);\n          },\n          setStyle: function () {},\n          getOptions: function () {\n            return this.options;\n          },\n          initialize: function (t) {\n            var e = this,\n              i = new L.Icon.Default();\n            i.options.tooltipAnchor = [0, 0], this.options.markerStyle.icon = i, this._map = t, this.shapes = [\"Marker\", \"CircleMarker\", \"Line\", \"Polygon\", \"Rectangle\", \"Circle\", \"Cut\", \"Text\"], this.shapes.forEach(function (t) {\n              e[t] = new L.PM.Draw[t](e._map);\n            }), this.Marker.setOptions({\n              continueDrawing: !0\n            }), this.CircleMarker.setOptions({\n              continueDrawing: !0\n            });\n          },\n          setPathOptions: function (t) {\n            var e = arguments.length > 1 && arguments[1] !== undefined && arguments[1];\n            this.options.pathOptions = e ? r()(this.options.pathOptions, t) : t;\n          },\n          getShapes: function () {\n            return this.shapes;\n          },\n          getShape: function () {\n            return this._shape;\n          },\n          enable: function (t, e) {\n            if (!t) throw new Error(\"Error: Please pass a shape as a parameter. Possible shapes are: \".concat(this.getShapes().join(\",\")));\n            this.disable(), this[t].enable(e);\n          },\n          disable: function () {\n            var t = this;\n            this.shapes.forEach(function (e) {\n              t[e].disable();\n            });\n          },\n          addControls: function () {\n            var t = this;\n            this.shapes.forEach(function (e) {\n              t[e].addButton();\n            });\n          },\n          getActiveShape: function () {\n            var t,\n              e = this;\n            return this.shapes.forEach(function (i) {\n              e[i]._enabled && (t = i);\n            }), t;\n          },\n          _setGlobalDrawMode: function () {\n            \"Cut\" === this._shape ? this._fireGlobalCutModeToggled() : this._fireGlobalDrawModeToggled();\n            var t = L.PM.Utils.findLayers(this._map);\n            this._enabled ? t.forEach(function (t) {\n              L.PM.Utils.disablePopup(t);\n            }) : t.forEach(function (t) {\n              L.PM.Utils.enablePopup(t);\n            });\n          },\n          createNewDrawInstance: function (t, e) {\n            var i = this._getShapeFromBtnName(e);\n            if (this[t]) throw new TypeError(\"Draw Type already exists\");\n            if (!L.PM.Draw[i]) throw new TypeError(\"There is no class L.PM.Draw.\".concat(i));\n            return this[t] = new L.PM.Draw[i](this._map), this[t].toolbarButtonName = t, this[t]._shape = t, this.shapes.push(t), this[e] && this[t].setOptions(this[e].options), this[t].setOptions(this[t].options), this[t];\n          },\n          _getShapeFromBtnName: function (t) {\n            var e = {\n              drawMarker: \"Marker\",\n              drawCircle: \"Circle\",\n              drawPolygon: \"Polygon\",\n              drawPolyline: \"Line\",\n              drawRectangle: \"Rectangle\",\n              drawCircleMarker: \"CircleMarker\",\n              editMode: \"Edit\",\n              dragMode: \"Drag\",\n              cutPolygon: \"Cut\",\n              removalMode: \"Removal\",\n              rotateMode: \"Rotate\",\n              drawText: \"Text\"\n            };\n            return e[t] ? e[t] : this[t] ? this[t]._shape : t;\n          },\n          _finishLayer: function (t) {\n            t.pm && (t.pm.setOptions(this.options), t.pm._shape = this._shape, t.pm._map = this._map), this._addDrawnLayerProp(t);\n          },\n          _addDrawnLayerProp: function (t) {\n            t._drawnByGeoman = !0;\n          },\n          _setPane: function (t, e) {\n            \"layerPane\" === e ? t.options.pane = this._map.pm.globalOptions.panes && this._map.pm.globalOptions.panes.layerPane || \"overlayPane\" : \"vertexPane\" === e ? t.options.pane = this._map.pm.globalOptions.panes && this._map.pm.globalOptions.panes.vertexPane || \"markerPane\" : \"markerPane\" === e && (t.options.pane = this._map.pm.globalOptions.panes && this._map.pm.globalOptions.panes.markerPane || \"markerPane\");\n          },\n          _isFirstLayer: function () {\n            return 0 === (this._map || this._layer._map).pm.getGeomanLayers().length;\n          }\n        });\n        nt.Marker = nt.extend({\n          initialize: function (t) {\n            this._map = t, this._shape = \"Marker\", this.toolbarButtonName = \"drawMarker\";\n          },\n          enable: function (t) {\n            var e = this;\n            L.Util.setOptions(this, t), this._enabled = !0, this._map.on(\"click\", this._createMarker, this), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !0), this._hintMarker = L.marker(this._map.getCenter(), this.options.markerStyle), this._setPane(this._hintMarker, \"markerPane\"), this._hintMarker._pmTempLayer = !0, this._hintMarker.addTo(this._map), this.options.tooltips && this._hintMarker.bindTooltip(I(\"tooltips.placeMarker\"), {\n              permanent: !0,\n              offset: L.point(0, 10),\n              direction: \"bottom\",\n              opacity: .8\n            }).openTooltip(), this._layer = this._hintMarker, this._map.on(\"mousemove\", this._syncHintMarker, this), this.options.markerEditable && this._map.eachLayer(function (t) {\n              e.isRelevantMarker(t) && t.pm.enable();\n            }), this._fireDrawStart(), this._setGlobalDrawMode();\n          },\n          disable: function () {\n            var t = this;\n            this._enabled && (this._enabled = !1, this._map.off(\"click\", this._createMarker, this), this._hintMarker.remove(), this._map.off(\"mousemove\", this._syncHintMarker, this), this._map.eachLayer(function (e) {\n              t.isRelevantMarker(e) && e.pm.disable();\n            }), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !1), this.options.snappable && this._cleanupSnapping(), this._fireDrawEnd(), this._setGlobalDrawMode());\n          },\n          enabled: function () {\n            return this._enabled;\n          },\n          toggle: function (t) {\n            this.enabled() ? this.disable() : this.enable(t);\n          },\n          isRelevantMarker: function (t) {\n            return t instanceof L.Marker && t.pm && !t._pmTempLayer && !t.pm._initTextMarker;\n          },\n          _syncHintMarker: function (t) {\n            if (this._hintMarker.setLatLng(t.latlng), this.options.snappable) {\n              var e = t;\n              e.target = this._hintMarker, this._handleSnapping(e);\n            }\n            this._fireChange(this._hintMarker.getLatLng(), \"Draw\");\n          },\n          _createMarker: function (t) {\n            if (t.latlng && (!this.options.requireSnapToFinish || this._hintMarker._snapped || this._isFirstLayer())) {\n              this._hintMarker._snapped || this._hintMarker.setLatLng(t.latlng);\n              var e = this._hintMarker.getLatLng(),\n                i = new L.Marker(e, this.options.markerStyle);\n              this._setPane(i, \"markerPane\"), this._finishLayer(i), i.pm || (i.options.draggable = !1), i.addTo(this._map.pm._getContainingLayer()), i.pm && this.options.markerEditable ? i.pm.enable() : i.dragging && i.dragging.disable(), this._fireCreate(i), this._cleanupSnapping(), this.options.continueDrawing || this.disable();\n            }\n          },\n          setStyle: function () {\n            var t, e;\n            null !== (t = this.options.markerStyle) && void 0 !== t && t.icon && (null === (e = this._hintMarker) || void 0 === e || e.setIcon(this.options.markerStyle.icon));\n          }\n        });\n        var rt = 6371008.8,\n          at = {\n            centimeters: 637100880,\n            centimetres: 637100880,\n            degrees: 57.22891354143274,\n            feet: 20902260.511392,\n            inches: 39.37 * rt,\n            kilometers: 6371.0088,\n            kilometres: 6371.0088,\n            meters: rt,\n            metres: rt,\n            miles: 3958.761333810546,\n            millimeters: 6371008800,\n            millimetres: 6371008800,\n            nauticalmiles: rt / 1852,\n            radians: 1,\n            yards: 6967335.223679999\n          };\n        function ot(t, e, i) {\n          void 0 === i && (i = {});\n          var n = {\n            type: \"Feature\"\n          };\n          return (0 === i.id || i.id) && (n.id = i.id), i.bbox && (n.bbox = i.bbox), n.properties = e || {}, n.geometry = t, n;\n        }\n        function st(t, e, i) {\n          if (void 0 === i && (i = {}), !t) throw new Error(\"coordinates is required\");\n          if (!Array.isArray(t)) throw new Error(\"coordinates must be an Array\");\n          if (t.length < 2) throw new Error(\"coordinates must be at least 2 numbers long\");\n          if (!ft(t[0]) || !ft(t[1])) throw new Error(\"coordinates must contain numbers\");\n          return ot({\n            type: \"Point\",\n            coordinates: t\n          }, e, i);\n        }\n        function lt(t, e, i) {\n          if (void 0 === i && (i = {}), t.length < 2) throw new Error(\"coordinates must be an array of two or more positions\");\n          return ot({\n            type: \"LineString\",\n            coordinates: t\n          }, e, i);\n        }\n        function ht(t, e) {\n          void 0 === e && (e = {});\n          var i = {\n            type: \"FeatureCollection\"\n          };\n          return e.id && (i.id = e.id), e.bbox && (i.bbox = e.bbox), i.features = t, i;\n        }\n        function ut(t, e) {\n          void 0 === e && (e = \"kilometers\");\n          var i = at[e];\n          if (!i) throw new Error(e + \" units is invalid\");\n          return t * i;\n        }\n        function ct(t, e) {\n          void 0 === e && (e = \"kilometers\");\n          var i = at[e];\n          if (!i) throw new Error(e + \" units is invalid\");\n          return t / i;\n        }\n        function pt(t) {\n          return 180 * (t % (2 * Math.PI)) / Math.PI;\n        }\n        function dt(t) {\n          return t % 360 * Math.PI / 180;\n        }\n        function ft(t) {\n          return !isNaN(t) && null !== t && !Array.isArray(t);\n        }\n        function gt(t) {\n          var e,\n            i,\n            n = {\n              type: \"FeatureCollection\",\n              features: []\n            };\n          if (\"LineString\" === (i = \"Feature\" === t.type ? t.geometry : t).type) e = [i.coordinates];else if (\"MultiLineString\" === i.type) e = i.coordinates;else if (\"MultiPolygon\" === i.type) e = [].concat.apply([], i.coordinates);else {\n            if (\"Polygon\" !== i.type) throw new Error(\"Input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry\");\n            e = i.coordinates;\n          }\n          return e.forEach(function (t) {\n            e.forEach(function (e) {\n              for (var i = 0; i < t.length - 1; i++) for (var r = i; r < e.length - 1; r++) {\n                if (t === e) {\n                  if (1 === Math.abs(i - r)) continue;\n                  if (0 === i && r === t.length - 2 && t[i][0] === t[t.length - 1][0] && t[i][1] === t[t.length - 1][1]) continue;\n                }\n                var a = _t(t[i][0], t[i][1], t[i + 1][0], t[i + 1][1], e[r][0], e[r][1], e[r + 1][0], e[r + 1][1]);\n                a && n.features.push(st([a[0], a[1]]));\n              }\n            });\n          }), n;\n        }\n        function _t(t, e, i, n, r, a, o, s) {\n          var l,\n            h,\n            u,\n            c,\n            p = {\n              x: null,\n              y: null,\n              onLine1: !1,\n              onLine2: !1\n            };\n          return 0 === (l = (s - a) * (i - t) - (o - r) * (n - e)) ? null !== p.x && null !== p.y && p : (c = (i - t) * (h = e - a) - (n - e) * (u = t - r), h = ((o - r) * h - (s - a) * u) / l, u = c / l, p.x = t + h * (i - t), p.y = e + h * (n - e), h >= 0 && h <= 1 && (p.onLine1 = !0), u >= 0 && u <= 1 && (p.onLine2 = !0), !(!p.onLine1 || !p.onLine2) && [p.x, p.y]);\n        }\n        function mt(t, e) {\n          var i = Object.keys(t);\n          if (Object.getOwnPropertySymbols) {\n            var n = Object.getOwnPropertySymbols(t);\n            e && (n = n.filter(function (e) {\n              return Object.getOwnPropertyDescriptor(t, e).enumerable;\n            })), i.push.apply(i, n);\n          }\n          return i;\n        }\n        function yt(t) {\n          for (var e = 1; e < arguments.length; e++) {\n            var i = null != arguments[e] ? arguments[e] : {};\n            e % 2 ? mt(Object(i), !0).forEach(function (e) {\n              vt(t, e, i[e]);\n            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : mt(Object(i)).forEach(function (e) {\n              Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e));\n            });\n          }\n          return t;\n        }\n        function vt(t, e, i) {\n          return e in t ? Object.defineProperty(t, e, {\n            value: i,\n            enumerable: !0,\n            configurable: !0,\n            writable: !0\n          }) : t[e] = i, t;\n        }\n        function Lt(t, e) {\n          var i = Object.keys(t);\n          if (Object.getOwnPropertySymbols) {\n            var n = Object.getOwnPropertySymbols(t);\n            e && (n = n.filter(function (e) {\n              return Object.getOwnPropertyDescriptor(t, e).enumerable;\n            })), i.push.apply(i, n);\n          }\n          return i;\n        }\n        function bt(t) {\n          for (var e = 1; e < arguments.length; e++) {\n            var i = null != arguments[e] ? arguments[e] : {};\n            e % 2 ? Lt(Object(i), !0).forEach(function (e) {\n              kt(t, e, i[e]);\n            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : Lt(Object(i)).forEach(function (e) {\n              Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e));\n            });\n          }\n          return t;\n        }\n        function kt(t, e, i) {\n          return e in t ? Object.defineProperty(t, e, {\n            value: i,\n            enumerable: !0,\n            configurable: !0,\n            writable: !0\n          }) : t[e] = i, t;\n        }\n        function Mt(t, e) {\n          var i = Object.keys(t);\n          if (Object.getOwnPropertySymbols) {\n            var n = Object.getOwnPropertySymbols(t);\n            e && (n = n.filter(function (e) {\n              return Object.getOwnPropertyDescriptor(t, e).enumerable;\n            })), i.push.apply(i, n);\n          }\n          return i;\n        }\n        function xt(t) {\n          for (var e = 1; e < arguments.length; e++) {\n            var i = null != arguments[e] ? arguments[e] : {};\n            e % 2 ? Mt(Object(i), !0).forEach(function (e) {\n              wt(t, e, i[e]);\n            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : Mt(Object(i)).forEach(function (e) {\n              Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e));\n            });\n          }\n          return t;\n        }\n        function wt(t, e, i) {\n          return e in t ? Object.defineProperty(t, e, {\n            value: i,\n            enumerable: !0,\n            configurable: !0,\n            writable: !0\n          }) : t[e] = i, t;\n        }\n        function Ct(t) {\n          if (!t) throw new Error(\"coord is required\");\n          if (!Array.isArray(t)) {\n            if (\"Feature\" === t.type && null !== t.geometry && \"Point\" === t.geometry.type) return t.geometry.coordinates;\n            if (\"Point\" === t.type) return t.coordinates;\n          }\n          if (Array.isArray(t) && t.length >= 2 && !Array.isArray(t[0]) && !Array.isArray(t[1])) return t;\n          throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n        }\n        function Pt(t) {\n          if (Array.isArray(t)) return t;\n          if (\"Feature\" === t.type) {\n            if (null !== t.geometry) return t.geometry.coordinates;\n          } else if (t.coordinates) return t.coordinates;\n          throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n        }\n        function Et(t) {\n          return \"Feature\" === t.type ? t.geometry : t;\n        }\n        function St(t, e) {\n          return \"FeatureCollection\" === t.type ? \"FeatureCollection\" : \"GeometryCollection\" === t.type ? \"GeometryCollection\" : \"Feature\" === t.type && null !== t.geometry ? t.geometry.type : t.type;\n        }\n        function Ot(t, e, i) {\n          if (null !== t) for (var n, r, a, o, s, l, h, u, c = 0, p = 0, d = t.type, f = \"FeatureCollection\" === d, g = \"Feature\" === d, _ = f ? t.features.length : 1, m = 0; m < _; m++) {\n            s = (u = !!(h = f ? t.features[m].geometry : g ? t.geometry : t) && \"GeometryCollection\" === h.type) ? h.geometries.length : 1;\n            for (var y = 0; y < s; y++) {\n              var v = 0,\n                L = 0;\n              if (null !== (o = u ? h.geometries[y] : h)) {\n                l = o.coordinates;\n                var b = o.type;\n                switch (c = !i || \"Polygon\" !== b && \"MultiPolygon\" !== b ? 0 : 1, b) {\n                  case null:\n                    break;\n                  case \"Point\":\n                    if (!1 === e(l, p, m, v, L)) return !1;\n                    p++, v++;\n                    break;\n                  case \"LineString\":\n                  case \"MultiPoint\":\n                    for (n = 0; n < l.length; n++) {\n                      if (!1 === e(l[n], p, m, v, L)) return !1;\n                      p++, \"MultiPoint\" === b && v++;\n                    }\n                    \"LineString\" === b && v++;\n                    break;\n                  case \"Polygon\":\n                  case \"MultiLineString\":\n                    for (n = 0; n < l.length; n++) {\n                      for (r = 0; r < l[n].length - c; r++) {\n                        if (!1 === e(l[n][r], p, m, v, L)) return !1;\n                        p++;\n                      }\n                      \"MultiLineString\" === b && v++, \"Polygon\" === b && L++;\n                    }\n                    \"Polygon\" === b && v++;\n                    break;\n                  case \"MultiPolygon\":\n                    for (n = 0; n < l.length; n++) {\n                      for (L = 0, r = 0; r < l[n].length; r++) {\n                        for (a = 0; a < l[n][r].length - c; a++) {\n                          if (!1 === e(l[n][r][a], p, m, v, L)) return !1;\n                          p++;\n                        }\n                        L++;\n                      }\n                      v++;\n                    }\n                    break;\n                  case \"GeometryCollection\":\n                    for (n = 0; n < o.geometries.length; n++) if (!1 === Ot(o.geometries[n], e, i)) return !1;\n                    break;\n                  default:\n                    throw new Error(\"Unknown Geometry Type\");\n                }\n              }\n            }\n          }\n        }\n        function Dt(t, e) {\n          if (\"Feature\" === t.type) e(t, 0);else if (\"FeatureCollection\" === t.type) for (var i = 0; i < t.features.length && !1 !== e(t.features[i], i); i++);\n        }\n        function Bt(t, e) {\n          var i,\n            n,\n            r,\n            a,\n            o,\n            s,\n            l,\n            h,\n            u,\n            c,\n            p = 0,\n            d = \"FeatureCollection\" === t.type,\n            f = \"Feature\" === t.type,\n            g = d ? t.features.length : 1;\n          for (i = 0; i < g; i++) {\n            for (s = d ? t.features[i].geometry : f ? t.geometry : t, h = d ? t.features[i].properties : f ? t.properties : {}, u = d ? t.features[i].bbox : f ? t.bbox : undefined, c = d ? t.features[i].id : f ? t.id : undefined, o = (l = !!s && \"GeometryCollection\" === s.type) ? s.geometries.length : 1, r = 0; r < o; r++) if (null !== (a = l ? s.geometries[r] : s)) switch (a.type) {\n              case \"Point\":\n              case \"LineString\":\n              case \"MultiPoint\":\n              case \"Polygon\":\n              case \"MultiLineString\":\n              case \"MultiPolygon\":\n                if (!1 === e(a, p, h, u, c)) return !1;\n                break;\n              case \"GeometryCollection\":\n                for (n = 0; n < a.geometries.length; n++) if (!1 === e(a.geometries[n], p, h, u, c)) return !1;\n                break;\n              default:\n                throw new Error(\"Unknown Geometry Type\");\n            } else if (!1 === e(null, p, h, u, c)) return !1;\n            p++;\n          }\n        }\n        function Rt(t, e) {\n          Bt(t, function (t, i, n, r, a) {\n            var o,\n              s = null === t ? null : t.type;\n            switch (s) {\n              case null:\n              case \"Point\":\n              case \"LineString\":\n              case \"Polygon\":\n                return !1 !== e(ot(t, n, {\n                  bbox: r,\n                  id: a\n                }), i, 0) && void 0;\n            }\n            switch (s) {\n              case \"MultiPoint\":\n                o = \"Point\";\n                break;\n              case \"MultiLineString\":\n                o = \"LineString\";\n                break;\n              case \"MultiPolygon\":\n                o = \"Polygon\";\n            }\n            for (var l = 0; l < t.coordinates.length; l++) {\n              var h = t.coordinates[l];\n              if (!1 === e(ot({\n                type: o,\n                coordinates: h\n              }, n), i, l)) return !1;\n            }\n          });\n        }\n        nt.Line = nt.extend({\n          initialize: function (t) {\n            this._map = t, this._shape = \"Line\", this.toolbarButtonName = \"drawPolyline\", this._doesSelfIntersect = !1;\n          },\n          enable: function (t) {\n            L.Util.setOptions(this, t), this._enabled = !0, this._markers = [], this._layerGroup = new L.FeatureGroup(), this._layerGroup._pmTempLayer = !0, this._layerGroup.addTo(this._map), this._layer = L.polyline([], yt(yt({}, this.options.templineStyle), {}, {\n              pmIgnore: !1\n            })), this._setPane(this._layer, \"layerPane\"), this._layer._pmTempLayer = !0, this._layerGroup.addLayer(this._layer), this._hintline = L.polyline([], this.options.hintlineStyle), this._setPane(this._hintline, \"layerPane\"), this._hintline._pmTempLayer = !0, this._layerGroup.addLayer(this._hintline), this._hintMarker = L.marker(this._map.getCenter(), {\n              interactive: !1,\n              zIndexOffset: 100,\n              icon: L.divIcon({\n                className: \"marker-icon cursor-marker\"\n              })\n            }), this._setPane(this._hintMarker, \"vertexPane\"), this._hintMarker._pmTempLayer = !0, this._layerGroup.addLayer(this._hintMarker), this.options.cursorMarker && L.DomUtil.addClass(this._hintMarker._icon, \"visible\"), this.options.tooltips && this._hintMarker.bindTooltip(I(\"tooltips.firstVertex\"), {\n              permanent: !0,\n              offset: L.point(0, 10),\n              direction: \"bottom\",\n              opacity: .8\n            }).openTooltip(), this._map._container.style.cursor = \"crosshair\", this._map.on(\"click\", this._createVertex, this), this.options.finishOn && \"snap\" !== this.options.finishOn && this._map.on(this.options.finishOn, this._finishShape, this), \"dblclick\" === this.options.finishOn && (this.tempMapDoubleClickZoomState = this._map.doubleClickZoom._enabled, this.tempMapDoubleClickZoomState && this._map.doubleClickZoom.disable()), this._map.on(\"mousemove\", this._syncHintMarker, this), this._hintMarker.on(\"move\", this._syncHintLine, this), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !0), this._otherSnapLayers = [], this._fireDrawStart(), this._setGlobalDrawMode();\n          },\n          disable: function () {\n            this._enabled && (this._enabled = !1, this._map._container.style.cursor = \"\", this._map.off(\"click\", this._createVertex, this), this._map.off(\"mousemove\", this._syncHintMarker, this), this.options.finishOn && \"snap\" !== this.options.finishOn && this._map.off(this.options.finishOn, this._finishShape, this), this.tempMapDoubleClickZoomState && this._map.doubleClickZoom.enable(), this._map.removeLayer(this._layerGroup), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !1), this.options.snappable && this._cleanupSnapping(), this._fireDrawEnd(), this._setGlobalDrawMode());\n          },\n          enabled: function () {\n            return this._enabled;\n          },\n          toggle: function (t) {\n            this.enabled() ? this.disable() : this.enable(t);\n          },\n          _syncHintLine: function () {\n            var t = this._layer.getLatLngs();\n            if (t.length > 0) {\n              var e = t[t.length - 1];\n              this._hintline.setLatLngs([e, this._hintMarker.getLatLng()]);\n            }\n          },\n          _syncHintMarker: function (t) {\n            if (this._hintMarker.setLatLng(t.latlng), this.options.snappable) {\n              var e = t;\n              e.target = this._hintMarker, this._handleSnapping(e);\n            }\n            this.options.allowSelfIntersection || this._handleSelfIntersection(!0, this._hintMarker.getLatLng());\n            var i = this._layer._defaultShape().slice();\n            i.push(this._hintMarker.getLatLng()), this._change(i);\n          },\n          hasSelfIntersection: function () {\n            return gt(this._layer.toGeoJSON(15)).features.length > 0;\n          },\n          _handleSelfIntersection: function (t, e) {\n            var i = L.polyline(this._layer.getLatLngs());\n            t && (e || (e = this._hintMarker.getLatLng()), i.addLatLng(e));\n            var n = gt(i.toGeoJSON(15));\n            this._doesSelfIntersect = n.features.length > 0, this._doesSelfIntersect ? this._hintline.setStyle({\n              color: \"#f00000ff\"\n            }) : this._hintline.isEmpty() || this._hintline.setStyle(this.options.hintlineStyle);\n          },\n          _createVertex: function (t) {\n            if (this.options.allowSelfIntersection || (this._handleSelfIntersection(!0, t.latlng), !this._doesSelfIntersect)) {\n              this._hintMarker._snapped || this._hintMarker.setLatLng(t.latlng);\n              var e = this._hintMarker.getLatLng(),\n                i = this._layer.getLatLngs(),\n                n = i[i.length - 1];\n              if (e.equals(i[0]) || i.length > 0 && e.equals(n)) this._finishShape();else {\n                this._layer._latlngInfo = this._layer._latlngInfo || [], this._layer._latlngInfo.push({\n                  latlng: e,\n                  snapInfo: this._hintMarker._snapInfo\n                }), this._layer.addLatLng(e);\n                var r = this._createMarker(e);\n                this._setTooltipText(), this._setHintLineAfterNewVertex(e), this._fireVertexAdded(r, undefined, e, \"Draw\"), this._change(this._layer.getLatLngs()), \"snap\" === this.options.finishOn && this._hintMarker._snapped && this._finishShape(t);\n              }\n            }\n          },\n          _setHintLineAfterNewVertex: function (t) {\n            this._hintline.setLatLngs([t, t]);\n          },\n          _removeLastVertex: function () {\n            var t = this._markers;\n            if (t.length <= 1) this.disable();else {\n              var e = this._layer.getLatLngs(),\n                i = t[t.length - 1],\n                n = L.PM.Utils.findDeepMarkerIndex(t, i).indexPath;\n              t.pop(), this._layerGroup.removeLayer(i);\n              var r = t[t.length - 1],\n                a = e.indexOf(r.getLatLng());\n              e = e.slice(0, a + 1), this._layer.setLatLngs(e), this._layer._latlngInfo.pop(), this._syncHintLine(), this._setTooltipText(), this._fireVertexRemoved(i, n, \"Draw\"), this._change(this._layer.getLatLngs());\n            }\n          },\n          _finishShape: function () {\n            if ((this.options.allowSelfIntersection || (this._handleSelfIntersection(!1), !this._doesSelfIntersect)) && (!this.options.requireSnapToFinish || this._hintMarker._snapped || this._isFirstLayer())) {\n              var t = this._layer.getLatLngs();\n              if (!(t.length <= 1)) {\n                var e = L.polyline(t, this.options.pathOptions);\n                this._setPane(e, \"layerPane\"), this._finishLayer(e), e.addTo(this._map.pm._getContainingLayer()), this._fireCreate(e), this.options.snappable && this._cleanupSnapping(), this.disable(), this.options.continueDrawing && this.enable();\n              }\n            }\n          },\n          _createMarker: function (t) {\n            var e = new L.Marker(t, {\n              draggable: !1,\n              icon: L.divIcon({\n                className: \"marker-icon\"\n              })\n            });\n            return this._setPane(e, \"vertexPane\"), e._pmTempLayer = !0, this._layerGroup.addLayer(e), this._markers.push(e), e.on(\"click\", this._finishShape, this), e;\n          },\n          _setTooltipText: function () {\n            var t = \"\";\n            t = I(this._layer.getLatLngs().flat().length <= 1 ? \"tooltips.continueLine\" : \"tooltips.finishLine\"), this._hintMarker.setTooltipContent(t);\n          },\n          _change: function (t) {\n            this._fireChange(t, \"Draw\");\n          },\n          setStyle: function () {\n            var t, e;\n            null === (t = this._layer) || void 0 === t || t.setStyle(this.options.templineStyle), null === (e = this._hintline) || void 0 === e || e.setStyle(this.options.hintlineStyle);\n          }\n        }), nt.Polygon = nt.Line.extend({\n          initialize: function (t) {\n            this._map = t, this._shape = \"Polygon\", this.toolbarButtonName = \"drawPolygon\";\n          },\n          enable: function (t) {\n            L.PM.Draw.Line.prototype.enable.call(this, t), this._layer.pm._shape = \"Polygon\";\n          },\n          _createMarker: function (t) {\n            var e = new L.Marker(t, {\n              draggable: !1,\n              icon: L.divIcon({\n                className: \"marker-icon\"\n              })\n            });\n            return this._setPane(e, \"vertexPane\"), e._pmTempLayer = !0, this._layerGroup.addLayer(e), this._markers.push(e), 1 === this._layer.getLatLngs().flat().length ? (e.on(\"click\", this._finishShape, this), this._tempSnapLayerIndex = this._otherSnapLayers.push(e) - 1, this.options.snappable && this._cleanupSnapping()) : e.on(\"click\", function () {\n              return 1;\n            }), e;\n          },\n          _setTooltipText: function () {\n            var t = \"\";\n            t = I(this._layer.getLatLngs().flat().length <= 2 ? \"tooltips.continueLine\" : \"tooltips.finishPoly\"), this._hintMarker.setTooltipContent(t);\n          },\n          _finishShape: function () {\n            if ((this.options.allowSelfIntersection || (this._handleSelfIntersection(!0, this._layer.getLatLngs()[0]), !this._doesSelfIntersect)) && (!this.options.requireSnapToFinish || this._hintMarker._snapped || this._isFirstLayer())) {\n              var t = this._layer.getLatLngs();\n              if (!(t.length <= 2)) {\n                var e = L.polygon(t, this.options.pathOptions);\n                this._setPane(e, \"layerPane\"), this._finishLayer(e), e.addTo(this._map.pm._getContainingLayer()), this._fireCreate(e), this._cleanupSnapping(), this._otherSnapLayers.splice(this._tempSnapLayerIndex, 1), delete this._tempSnapLayerIndex, this.disable(), this.options.continueDrawing && this.enable();\n              }\n            }\n          }\n        }), nt.Rectangle = nt.extend({\n          initialize: function (t) {\n            this._map = t, this._shape = \"Rectangle\", this.toolbarButtonName = \"drawRectangle\";\n          },\n          enable: function (t) {\n            if (L.Util.setOptions(this, t), this._enabled = !0, this._layerGroup = new L.FeatureGroup(), this._layerGroup._pmTempLayer = !0, this._layerGroup.addTo(this._map), this._layer = L.rectangle([[0, 0], [0, 0]], this.options.pathOptions), this._setPane(this._layer, \"layerPane\"), this._layer._pmTempLayer = !0, this._startMarker = L.marker(this._map.getCenter(), {\n              icon: L.divIcon({\n                className: \"marker-icon rect-start-marker\"\n              }),\n              draggable: !1,\n              zIndexOffset: -100,\n              opacity: this.options.cursorMarker ? 1 : 0\n            }), this._setPane(this._startMarker, \"vertexPane\"), this._startMarker._pmTempLayer = !0, this._layerGroup.addLayer(this._startMarker), this._hintMarker = L.marker(this._map.getCenter(), {\n              zIndexOffset: 150,\n              icon: L.divIcon({\n                className: \"marker-icon cursor-marker\"\n              })\n            }), this._setPane(this._hintMarker, \"vertexPane\"), this._hintMarker._pmTempLayer = !0, this._layerGroup.addLayer(this._hintMarker), this.options.cursorMarker && L.DomUtil.addClass(this._hintMarker._icon, \"visible\"), this.options.tooltips && this._hintMarker.bindTooltip(I(\"tooltips.firstVertex\"), {\n              permanent: !0,\n              offset: L.point(0, 10),\n              direction: \"bottom\",\n              opacity: .8\n            }).openTooltip(), this.options.cursorMarker) {\n              this._styleMarkers = [];\n              for (var e = 0; e < 2; e += 1) {\n                var i = L.marker(this._map.getCenter(), {\n                  icon: L.divIcon({\n                    className: \"marker-icon rect-style-marker\"\n                  }),\n                  draggable: !1,\n                  zIndexOffset: 100\n                });\n                this._setPane(i, \"vertexPane\"), i._pmTempLayer = !0, this._layerGroup.addLayer(i), this._styleMarkers.push(i);\n              }\n            }\n            this._map._container.style.cursor = \"crosshair\", this._map.on(\"click\", this._placeStartingMarkers, this), this._map.on(\"mousemove\", this._syncHintMarker, this), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !0), this._otherSnapLayers = [], this._fireDrawStart(), this._setGlobalDrawMode();\n          },\n          disable: function () {\n            this._enabled && (this._enabled = !1, this._map._container.style.cursor = \"\", this._map.off(\"click\", this._finishShape, this), this._map.off(\"click\", this._placeStartingMarkers, this), this._map.off(\"mousemove\", this._syncHintMarker, this), this._map.removeLayer(this._layerGroup), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !1), this.options.snappable && this._cleanupSnapping(), this._fireDrawEnd(), this._setGlobalDrawMode());\n          },\n          enabled: function () {\n            return this._enabled;\n          },\n          toggle: function (t) {\n            this.enabled() ? this.disable() : this.enable(t);\n          },\n          _placeStartingMarkers: function (t) {\n            this._hintMarker._snapped || this._hintMarker.setLatLng(t.latlng);\n            var e = this._hintMarker.getLatLng();\n            L.DomUtil.addClass(this._startMarker._icon, \"visible\"), this._startMarker.setLatLng(e), this.options.cursorMarker && this._styleMarkers && this._styleMarkers.forEach(function (t) {\n              L.DomUtil.addClass(t._icon, \"visible\"), t.setLatLng(e);\n            }), this._map.off(\"click\", this._placeStartingMarkers, this), this._map.on(\"click\", this._finishShape, this), this._hintMarker.setTooltipContent(I(\"tooltips.finishRect\")), this._setRectangleOrigin();\n          },\n          _setRectangleOrigin: function () {\n            var t = this._startMarker.getLatLng();\n            t && (this._layerGroup.addLayer(this._layer), this._layer.setLatLngs([t, t]), this._hintMarker.on(\"move\", this._syncRectangleSize, this));\n          },\n          _syncHintMarker: function (t) {\n            if (this._hintMarker.setLatLng(t.latlng), this.options.snappable) {\n              var e = t;\n              e.target = this._hintMarker, this._handleSnapping(e);\n            }\n            var i = this._layerGroup && this._layerGroup.hasLayer(this._layer) ? this._layer.getLatLngs() : [this._hintMarker.getLatLng()];\n            this._fireChange(i, \"Draw\");\n          },\n          _syncRectangleSize: function () {\n            var t = this,\n              e = V(this._startMarker.getLatLng(), this._map),\n              i = V(this._hintMarker.getLatLng(), this._map),\n              n = L.PM.Utils._getRotatedRectangle(e, i, this.options.rectangleAngle || 0, this._map);\n            if (this._layer.setLatLngs(n), this.options.cursorMarker && this._styleMarkers) {\n              var r = [];\n              n.forEach(function (t) {\n                t.equals(e, 1e-8) || t.equals(i, 1e-8) || r.push(t);\n              }), r.forEach(function (e, i) {\n                try {\n                  t._styleMarkers[i].setLatLng(e);\n                } catch (n) {}\n              });\n            }\n          },\n          _findCorners: function () {\n            var t = this._layer.getBounds();\n            return [t.getNorthWest(), t.getNorthEast(), t.getSouthEast(), t.getSouthWest()];\n          },\n          _finishShape: function (t) {\n            this._hintMarker._snapped || this._hintMarker.setLatLng(t.latlng);\n            var e = this._hintMarker.getLatLng(),\n              i = this._startMarker.getLatLng();\n            if (!this.options.requireSnapToFinish || this._hintMarker._snapped || this._isFirstLayer()) {\n              var n = L.rectangle([i, e], this.options.pathOptions);\n              if (this.options.rectangleAngle) {\n                var r = L.PM.Utils._getRotatedRectangle(i, e, this.options.rectangleAngle || 0, this._map);\n                n.setLatLngs(r), n.pm && n.pm._setAngle(this.options.rectangleAngle || 0);\n              }\n              this._setPane(n, \"layerPane\"), this._finishLayer(n), n.addTo(this._map.pm._getContainingLayer()), this._fireCreate(n), this.disable(), this.options.continueDrawing && this.enable();\n            }\n          },\n          setStyle: function () {\n            var t;\n            null === (t = this._layer) || void 0 === t || t.setStyle(this.options.pathOptions);\n          }\n        }), nt.Circle = nt.extend({\n          initialize: function (t) {\n            this._map = t, this._shape = \"Circle\", this.toolbarButtonName = \"drawCircle\";\n          },\n          enable: function (t) {\n            L.Util.setOptions(this, t), this.options.radius = 0, this._enabled = !0, this._layerGroup = new L.FeatureGroup(), this._layerGroup._pmTempLayer = !0, this._layerGroup.addTo(this._map), this._layer = L.circle(this._map.getCenter(), bt(bt({}, this.options.templineStyle), {}, {\n              radius: 0\n            })), this._setPane(this._layer, \"layerPane\"), this._layer._pmTempLayer = !0, this._centerMarker = L.marker(this._map.getCenter(), {\n              icon: L.divIcon({\n                className: \"marker-icon\"\n              }),\n              draggable: !1,\n              zIndexOffset: 100\n            }), this._setPane(this._centerMarker, \"vertexPane\"), this._centerMarker._pmTempLayer = !0, this._hintMarker = L.marker(this._map.getCenter(), {\n              zIndexOffset: 110,\n              icon: L.divIcon({\n                className: \"marker-icon cursor-marker\"\n              })\n            }), this._setPane(this._hintMarker, \"vertexPane\"), this._hintMarker._pmTempLayer = !0, this._layerGroup.addLayer(this._hintMarker), this.options.cursorMarker && L.DomUtil.addClass(this._hintMarker._icon, \"visible\"), this.options.tooltips && this._hintMarker.bindTooltip(I(\"tooltips.startCircle\"), {\n              permanent: !0,\n              offset: L.point(0, 10),\n              direction: \"bottom\",\n              opacity: .8\n            }).openTooltip(), this._hintline = L.polyline([], this.options.hintlineStyle), this._setPane(this._hintline, \"layerPane\"), this._hintline._pmTempLayer = !0, this._layerGroup.addLayer(this._hintline), this._map._container.style.cursor = \"crosshair\", this._map.on(\"click\", this._placeCenterMarker, this), this._map.on(\"mousemove\", this._syncHintMarker, this), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !0), this._otherSnapLayers = [], this._fireDrawStart(), this._setGlobalDrawMode();\n          },\n          disable: function () {\n            this._enabled && (this._enabled = !1, this._map._container.style.cursor = \"\", this._map.off(\"click\", this._finishShape, this), this._map.off(\"click\", this._placeCenterMarker, this), this._map.off(\"mousemove\", this._syncHintMarker, this), this._map.removeLayer(this._layerGroup), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !1), this.options.snappable && this._cleanupSnapping(), this._fireDrawEnd(), this._setGlobalDrawMode());\n          },\n          enabled: function () {\n            return this._enabled;\n          },\n          toggle: function (t) {\n            this.enabled() ? this.disable() : this.enable(t);\n          },\n          _syncHintLine: function () {\n            var t = this._centerMarker.getLatLng(),\n              e = this._getNewDestinationOfHintMarker();\n            this._hintline.setLatLngs([t, e]);\n          },\n          _syncCircleRadius: function () {\n            var t,\n              e = this._centerMarker.getLatLng(),\n              i = this._hintMarker.getLatLng();\n            t = this._map.options.crs === L.CRS.Simple ? this._map.distance(e, i) : e.distanceTo(i), this.options.minRadiusCircle && t < this.options.minRadiusCircle ? this._layer.setRadius(this.options.minRadiusCircle) : this.options.maxRadiusCircle && t > this.options.maxRadiusCircle ? this._layer.setRadius(this.options.maxRadiusCircle) : this._layer.setRadius(t);\n          },\n          _syncHintMarker: function (t) {\n            if (this._hintMarker.setLatLng(t.latlng), this._hintMarker.setLatLng(this._getNewDestinationOfHintMarker()), this.options.snappable) {\n              var e = t;\n              e.target = this._hintMarker, this._handleSnapping(e);\n            }\n            this._handleHintMarkerSnapping();\n            var i = this._layerGroup && this._layerGroup.hasLayer(this._centerMarker) ? this._centerMarker.getLatLng() : this._hintMarker.getLatLng();\n            this._fireChange(i, \"Draw\");\n          },\n          _placeCenterMarker: function (t) {\n            this._layerGroup.addLayer(this._layer), this._layerGroup.addLayer(this._centerMarker), this._hintMarker._snapped || this._hintMarker.setLatLng(t.latlng);\n            var e = this._hintMarker.getLatLng();\n            this._layerGroup.addLayer(this._layer), this._centerMarker.setLatLng(e), this._map.off(\"click\", this._placeCenterMarker, this), this._map.on(\"click\", this._finishShape, this), this._placeCircleCenter();\n          },\n          _placeCircleCenter: function () {\n            var t = this._centerMarker.getLatLng();\n            t && (this._layer.setLatLng(t), this._hintMarker.on(\"move\", this._syncHintLine, this), this._hintMarker.on(\"move\", this._syncCircleRadius, this), this._hintMarker.setTooltipContent(I(\"tooltips.finishCircle\")), this._fireCenterPlaced(), this._fireChange(this._layer.getLatLng(), \"Draw\"));\n          },\n          _finishShape: function (t) {\n            if (!this.options.requireSnapToFinish || this._hintMarker._snapped || this._isFirstLayer()) {\n              this._hintMarker._snapped || this._hintMarker.setLatLng(t.latlng);\n              var e,\n                i = this._centerMarker.getLatLng(),\n                n = this._hintMarker.getLatLng();\n              e = this._map.options.crs === L.CRS.Simple ? this._map.distance(i, n) : i.distanceTo(n), this.options.minRadiusCircle && e < this.options.minRadiusCircle ? e = this.options.minRadiusCircle : this.options.maxRadiusCircle && e > this.options.maxRadiusCircle && (e = this.options.maxRadiusCircle);\n              var r = bt(bt({}, this.options.pathOptions), {}, {\n                  radius: e\n                }),\n                a = L.circle(i, r);\n              this._setPane(a, \"layerPane\"), this._finishLayer(a), a.addTo(this._map.pm._getContainingLayer()), a.pm && a.pm._updateHiddenPolyCircle(), this._fireCreate(a), this.disable(), this.options.continueDrawing && this.enable();\n            }\n          },\n          _getNewDestinationOfHintMarker: function () {\n            var t = this._hintMarker.getLatLng();\n            if (!this._layerGroup.hasLayer(this._centerMarker)) return t;\n            var e = this._centerMarker.getLatLng(),\n              i = e.distanceTo(t);\n            return this.options.minRadiusCircle && i < this.options.minRadiusCircle ? t = z(this._map, e, t, this.options.minRadiusCircle) : this.options.maxRadiusCircle && i > this.options.maxRadiusCircle && (t = z(this._map, e, t, this.options.maxRadiusCircle)), t;\n          },\n          _handleHintMarkerSnapping: function () {\n            if (this._hintMarker._snapped) {\n              var t = this._centerMarker.getLatLng(),\n                e = this._hintMarker.getLatLng(),\n                i = t.distanceTo(e);\n              this._layerGroup.hasLayer(this._centerMarker) && (this.options.minRadiusCircle && i < this.options.minRadiusCircle || this.options.maxRadiusCircle && i > this.options.maxRadiusCircle) && this._hintMarker.setLatLng(this._hintMarker._orgLatLng);\n            }\n            this._hintMarker.setLatLng(this._getNewDestinationOfHintMarker());\n          },\n          setStyle: function () {\n            var t, e;\n            null === (t = this._layer) || void 0 === t || t.setStyle(this.options.templineStyle), null === (e = this._hintline) || void 0 === e || e.setStyle(this.options.hintlineStyle);\n          }\n        }), nt.CircleMarker = nt.Marker.extend({\n          initialize: function (t) {\n            this._map = t, this._shape = \"CircleMarker\", this.toolbarButtonName = \"drawCircleMarker\", this._layerIsDragging = !1;\n          },\n          enable: function (t) {\n            var e = this;\n            if (L.Util.setOptions(this, t), this._enabled = !0, this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !0), this.options.editable) {\n              var i = {};\n              L.extend(i, this.options.templineStyle), i.radius = 0, this._layerGroup = new L.FeatureGroup(), this._layerGroup._pmTempLayer = !0, this._layerGroup.addTo(this._map), this._layer = L.circleMarker(this._map.getCenter(), i), this._setPane(this._layer, \"layerPane\"), this._layer._pmTempLayer = !0, this._centerMarker = L.marker(this._map.getCenter(), {\n                icon: L.divIcon({\n                  className: \"marker-icon\"\n                }),\n                draggable: !1,\n                zIndexOffset: 100\n              }), this._setPane(this._centerMarker, \"vertexPane\"), this._centerMarker._pmTempLayer = !0, this._hintMarker = L.marker(this._map.getCenter(), {\n                zIndexOffset: 110,\n                icon: L.divIcon({\n                  className: \"marker-icon cursor-marker\"\n                })\n              }), this._setPane(this._hintMarker, \"vertexPane\"), this._hintMarker._pmTempLayer = !0, this._layerGroup.addLayer(this._hintMarker), this.options.cursorMarker && L.DomUtil.addClass(this._hintMarker._icon, \"visible\"), this.options.tooltips && this._hintMarker.bindTooltip(I(\"tooltips.startCircle\"), {\n                permanent: !0,\n                offset: L.point(0, 10),\n                direction: \"bottom\",\n                opacity: .8\n              }).openTooltip(), this._hintline = L.polyline([], this.options.hintlineStyle), this._setPane(this._hintline, \"layerPane\"), this._hintline._pmTempLayer = !0, this._layerGroup.addLayer(this._hintline), this._map.on(\"click\", this._placeCenterMarker, this), this._map._container.style.cursor = \"crosshair\";\n            } else this._map.on(\"click\", this._createMarker, this), this._hintMarker = L.circleMarker(this._map.getCenter(), this.options.templineStyle), this._setPane(this._hintMarker, \"layerPane\"), this._hintMarker._pmTempLayer = !0, this._hintMarker.addTo(this._map), this._layer = this._hintMarker, this.options.tooltips && this._hintMarker.bindTooltip(I(\"tooltips.placeCircleMarker\"), {\n              permanent: !0,\n              offset: L.point(0, 10),\n              direction: \"bottom\",\n              opacity: .8\n            }).openTooltip();\n            this._map.on(\"mousemove\", this._syncHintMarker, this), !this.options.editable && this.options.markerEditable && this._map.eachLayer(function (t) {\n              e.isRelevantMarker(t) && t.pm.enable();\n            }), this._layer.bringToBack(), this._fireDrawStart(), this._setGlobalDrawMode();\n          },\n          disable: function () {\n            var t = this;\n            this._enabled && (this._enabled = !1, this.options.editable ? (this._map._container.style.cursor = \"\", this._map.off(\"click\", this._finishShape, this), this._map.off(\"click\", this._placeCenterMarker, this), this._map.removeLayer(this._layerGroup)) : (this._map.off(\"click\", this._createMarker, this), this._map.eachLayer(function (e) {\n              t.isRelevantMarker(e) && e.pm.disable();\n            }), this._hintMarker.remove()), this._map.off(\"mousemove\", this._syncHintMarker, this), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !1), this.options.snappable && this._cleanupSnapping(), this._fireDrawEnd(), this._setGlobalDrawMode());\n          },\n          _placeCenterMarker: function (t) {\n            this._layerGroup.addLayer(this._layer), this._layerGroup.addLayer(this._centerMarker), this._hintMarker._snapped || this._hintMarker.setLatLng(t.latlng);\n            var e = this._hintMarker.getLatLng();\n            this._layerGroup.addLayer(this._layer), this._centerMarker.setLatLng(e), this._map.off(\"click\", this._placeCenterMarker, this), this._map.on(\"click\", this._finishShape, this), this._placeCircleCenter();\n          },\n          _placeCircleCenter: function () {\n            var t = this._centerMarker.getLatLng();\n            t && (this._layer.setLatLng(t), this._hintMarker.on(\"move\", this._syncHintLine, this), this._hintMarker.on(\"move\", this._syncCircleRadius, this), this._hintMarker.setTooltipContent(I(\"tooltips.finishCircle\")), this._fireCenterPlaced(), this._fireChange(this._layer.getLatLng(), \"Draw\"));\n          },\n          _syncHintLine: function () {\n            var t = this._centerMarker.getLatLng(),\n              e = this._getNewDestinationOfHintMarker();\n            this._hintline.setLatLngs([t, e]);\n          },\n          _syncCircleRadius: function () {\n            var t = this._centerMarker.getLatLng(),\n              e = this._hintMarker.getLatLng(),\n              i = this._map.project(t).distanceTo(this._map.project(e));\n            this.options.minRadiusCircleMarker && i < this.options.minRadiusCircleMarker ? this._layer.setRadius(this.options.minRadiusCircleMarker) : this.options.maxRadiusCircleMarker && i > this.options.maxRadiusCircleMarker ? this._layer.setRadius(this.options.maxRadiusCircleMarker) : this._layer.setRadius(i);\n          },\n          _syncHintMarker: function (t) {\n            if (this._hintMarker.setLatLng(t.latlng), this._hintMarker.setLatLng(this._getNewDestinationOfHintMarker()), this.options.snappable) {\n              var e = t;\n              e.target = this._hintMarker, this._handleSnapping(e);\n            }\n            this._handleHintMarkerSnapping();\n            var i = this._layerGroup && this._layerGroup.hasLayer(this._centerMarker) ? this._centerMarker.getLatLng() : this._hintMarker.getLatLng();\n            this._fireChange(i, \"Draw\");\n          },\n          isRelevantMarker: function (t) {\n            return t instanceof L.CircleMarker && !(t instanceof L.Circle) && t.pm && !t._pmTempLayer;\n          },\n          _createMarker: function (t) {\n            if ((!this.options.requireSnapToFinish || this._hintMarker._snapped || this._isFirstLayer()) && t.latlng && !this._layerIsDragging) {\n              this._hintMarker._snapped || this._hintMarker.setLatLng(t.latlng);\n              var e = this._hintMarker.getLatLng(),\n                i = L.circleMarker(e, this.options.pathOptions);\n              this._setPane(i, \"layerPane\"), this._finishLayer(i), i.addTo(this._map.pm._getContainingLayer()), i.pm && this.options.markerEditable && i.pm.enable(), this._fireCreate(i), this._cleanupSnapping(), this.options.continueDrawing || this.disable();\n            }\n          },\n          _finishShape: function (t) {\n            if (!this.options.requireSnapToFinish || this._hintMarker._snapped || this._isFirstLayer()) {\n              this._hintMarker._snapped || this._hintMarker.setLatLng(t.latlng);\n              var e = this._centerMarker.getLatLng(),\n                i = this._hintMarker.getLatLng(),\n                n = this._map.project(e).distanceTo(this._map.project(i));\n              this.options.editable && (this.options.minRadiusCircleMarker && n < this.options.minRadiusCircleMarker ? n = this.options.minRadiusCircleMarker : this.options.maxRadiusCircleMarker && n > this.options.maxRadiusCircleMarker && (n = this.options.maxRadiusCircleMarker));\n              var r = xt(xt({}, this.options.pathOptions), {}, {\n                  radius: n\n                }),\n                a = L.circleMarker(e, r);\n              this._setPane(a, \"layerPane\"), this._finishLayer(a), a.addTo(this._map.pm._getContainingLayer()), a.pm && a.pm._updateHiddenPolyCircle(), this._fireCreate(a), this.disable(), this.options.continueDrawing && this.enable();\n            }\n          },\n          _getNewDestinationOfHintMarker: function () {\n            var t = this._hintMarker.getLatLng();\n            if (this.options.editable) {\n              if (!this._layerGroup.hasLayer(this._centerMarker)) return t;\n              var e = this._centerMarker.getLatLng(),\n                i = this._map.project(e).distanceTo(this._map.project(t));\n              this.options.minRadiusCircleMarker && i < this.options.minRadiusCircleMarker ? t = z(this._map, e, t, this._pxRadiusToMeter(this.options.minRadiusCircleMarker)) : this.options.maxRadiusCircleMarker && i > this.options.maxRadiusCircleMarker && (t = z(this._map, e, t, this._pxRadiusToMeter(this.options.maxRadiusCircleMarker)));\n            }\n            return t;\n          },\n          _handleHintMarkerSnapping: function () {\n            if (this.options.editable) {\n              if (this._hintMarker._snapped) {\n                var t = this._centerMarker.getLatLng(),\n                  e = this._hintMarker.getLatLng(),\n                  i = this._map.project(t).distanceTo(this._map.project(e));\n                this._layerGroup.hasLayer(this._centerMarker) && (this.options.minRadiusCircleMarker && i < this.options.minRadiusCircleMarker || this.options.maxRadiusCircleMarker && i > this.options.maxRadiusCircleMarker) && this._hintMarker.setLatLng(this._hintMarker._orgLatLng);\n              }\n              this._hintMarker.setLatLng(this._getNewDestinationOfHintMarker());\n            }\n          },\n          _pxRadiusToMeter: function (t) {\n            var e = this._centerMarker.getLatLng(),\n              i = this._map.project(e),\n              n = L.point(i.x + t, i.y);\n            return this._map.unproject(n).distanceTo(e);\n          },\n          setStyle: function () {\n            var t,\n              e,\n              i = {};\n            L.extend(i, this.options.templineStyle), this.options.editable && (i.radius = 0), null === (t = this._layer) || void 0 === t || t.setStyle(i), null === (e = this._hintline) || void 0 === e || e.setStyle(this.options.hintlineStyle);\n          }\n        });\n        const Tt = function (t) {\n          if (!t) throw new Error(\"geojson is required\");\n          var e = [];\n          return Rt(t, function (t) {\n            !function (t, e) {\n              var i = [],\n                n = t.geometry;\n              if (null !== n) {\n                switch (n.type) {\n                  case \"Polygon\":\n                    i = Pt(n);\n                    break;\n                  case \"LineString\":\n                    i = [Pt(n)];\n                }\n                i.forEach(function (i) {\n                  var n = function (t, e) {\n                    var i = [];\n                    return t.reduce(function (t, n) {\n                      var r,\n                        a,\n                        o,\n                        s,\n                        l,\n                        h,\n                        u = lt([t, n], e);\n                      return u.bbox = (a = n, o = (r = t)[0], s = r[1], l = a[0], h = a[1], [o < l ? o : l, s < h ? s : h, o > l ? o : l, s > h ? s : h]), i.push(u), n;\n                    }), i;\n                  }(i, t.properties);\n                  n.forEach(function (t) {\n                    t.id = e.length, e.push(t);\n                  });\n                });\n              }\n            }(t, e);\n          }), ht(e);\n        };\n        var It = i(1787);\n        function jt(t, e) {\n          var i = Pt(t),\n            n = Pt(e);\n          if (2 !== i.length) throw new Error(\"<intersects> line1 must only contain 2 coordinates\");\n          if (2 !== n.length) throw new Error(\"<intersects> line2 must only contain 2 coordinates\");\n          var r = i[0][0],\n            a = i[0][1],\n            o = i[1][0],\n            s = i[1][1],\n            l = n[0][0],\n            h = n[0][1],\n            u = n[1][0],\n            c = n[1][1],\n            p = (c - h) * (o - r) - (u - l) * (s - a),\n            d = (u - l) * (a - h) - (c - h) * (r - l),\n            f = (o - r) * (a - h) - (s - a) * (r - l);\n          if (0 === p) return null;\n          var g = d / p,\n            _ = f / p;\n          return g >= 0 && g <= 1 && _ >= 0 && _ <= 1 ? st([r + g * (o - r), a + g * (s - a)]) : null;\n        }\n        const At = function (t, e) {\n          var i = {},\n            n = [];\n          if (\"LineString\" === t.type && (t = ot(t)), \"LineString\" === e.type && (e = ot(e)), \"Feature\" === t.type && \"Feature\" === e.type && null !== t.geometry && null !== e.geometry && \"LineString\" === t.geometry.type && \"LineString\" === e.geometry.type && 2 === t.geometry.coordinates.length && 2 === e.geometry.coordinates.length) {\n            var r = jt(t, e);\n            return r && n.push(r), ht(n);\n          }\n          var a = It();\n          return a.load(Tt(e)), Dt(Tt(t), function (t) {\n            Dt(a.search(t), function (e) {\n              var r = jt(t, e);\n              if (r) {\n                var a = Pt(r).join(\",\");\n                i[a] || (i[a] = !0, n.push(r));\n              }\n            });\n          }), ht(n);\n        };\n        const Gt = function (t, e, i) {\n          void 0 === i && (i = {});\n          var n = Ct(t),\n            r = Ct(e),\n            a = dt(r[1] - n[1]),\n            o = dt(r[0] - n[0]),\n            s = dt(n[1]),\n            l = dt(r[1]),\n            h = Math.pow(Math.sin(a / 2), 2) + Math.pow(Math.sin(o / 2), 2) * Math.cos(s) * Math.cos(l);\n          return ut(2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h)), i.units);\n        };\n        const Nt = function (t) {\n          var e = t[0],\n            i = t[1],\n            n = t[2],\n            r = t[3];\n          if (Gt(t.slice(0, 2), [n, i]) >= Gt(t.slice(0, 2), [e, r])) {\n            var a = (i + r) / 2;\n            return [e, a - (n - e) / 2, n, a + (n - e) / 2];\n          }\n          var o = (e + n) / 2;\n          return [o - (r - i) / 2, i, o + (r - i) / 2, r];\n        };\n        function zt(t) {\n          var e = [Infinity, Infinity, -Infinity, -Infinity];\n          return Ot(t, function (t) {\n            e[0] > t[0] && (e[0] = t[0]), e[1] > t[1] && (e[1] = t[1]), e[2] < t[0] && (e[2] = t[0]), e[3] < t[1] && (e[3] = t[1]);\n          }), e;\n        }\n        zt[\"default\"] = zt;\n        const Ft = zt;\n        const Ut = function (t, e) {\n          void 0 === e && (e = {});\n          var i = e.precision,\n            n = e.coordinates,\n            r = e.mutate;\n          if (i = i === undefined || null === i || isNaN(i) ? 6 : i, n = n === undefined || null === n || isNaN(n) ? 3 : n, !t) throw new Error(\"<geojson> is required\");\n          if (\"number\" != typeof i) throw new Error(\"<precision> must be a number\");\n          if (\"number\" != typeof n) throw new Error(\"<coordinates> must be a number\");\n          !1 !== r && r !== undefined || (t = JSON.parse(JSON.stringify(t)));\n          var a = Math.pow(10, i);\n          return Ot(t, function (t) {\n            !function (t, e, i) {\n              t.length > i && t.splice(i, t.length);\n              for (var n = 0; n < t.length; n++) t[n] = Math.round(t[n] * e) / e;\n            }(t, a, n);\n          }), t;\n        };\n        function Vt(t, e, i) {\n          if (void 0 === i && (i = {}), !0 === i.final) return function (t, e) {\n            var i = Vt(e, t);\n            return i = (i + 180) % 360;\n          }(t, e);\n          var n = Ct(t),\n            r = Ct(e),\n            a = dt(n[0]),\n            o = dt(r[0]),\n            s = dt(n[1]),\n            l = dt(r[1]),\n            h = Math.sin(o - a) * Math.cos(l),\n            u = Math.cos(s) * Math.sin(l) - Math.sin(s) * Math.cos(l) * Math.cos(o - a);\n          return pt(Math.atan2(h, u));\n        }\n        function Kt(t, e, i, n) {\n          void 0 === n && (n = {});\n          var r = Ct(t),\n            a = dt(r[0]),\n            o = dt(r[1]),\n            s = dt(i),\n            l = ct(e, n.units),\n            h = Math.asin(Math.sin(o) * Math.cos(l) + Math.cos(o) * Math.sin(l) * Math.cos(s));\n          return st([pt(a + Math.atan2(Math.sin(s) * Math.sin(l) * Math.cos(o), Math.cos(l) - Math.sin(o) * Math.sin(h))), pt(h)], n.properties);\n        }\n        const Ht = function (t, e, i) {\n          void 0 === i && (i = {});\n          var n = st([Infinity, Infinity], {\n              dist: Infinity\n            }),\n            r = 0;\n          return Rt(t, function (t) {\n            for (var a = Pt(t), o = 0; o < a.length - 1; o++) {\n              var s = st(a[o]);\n              s.properties.dist = Gt(e, s, i);\n              var l = st(a[o + 1]);\n              l.properties.dist = Gt(e, l, i);\n              var h = Gt(s, l, i),\n                u = Math.max(s.properties.dist, l.properties.dist),\n                c = Vt(s, l),\n                p = Kt(e, u, c + 90, i),\n                d = Kt(e, u, c - 90, i),\n                f = At(lt([p.geometry.coordinates, d.geometry.coordinates]), lt([s.geometry.coordinates, l.geometry.coordinates])),\n                g = null;\n              f.features.length > 0 && ((g = f.features[0]).properties.dist = Gt(e, g, i), g.properties.location = r + Gt(s, g, i)), s.properties.dist < n.properties.dist && ((n = s).properties.index = o, n.properties.location = r), l.properties.dist < n.properties.dist && ((n = l).properties.index = o + 1, n.properties.location = r + h), g && g.properties.dist < n.properties.dist && ((n = g).properties.index = o), r += h;\n            }\n          }), n;\n        };\n        function qt(t, e) {\n          var i = [],\n            n = It();\n          return Rt(e, function (e) {\n            if (i.forEach(function (t, e) {\n              t.id = e;\n            }), i.length) {\n              var r = n.search(e);\n              if (r.features.length) {\n                var a = Yt(e, r);\n                i = i.filter(function (t) {\n                  return t.id !== a.id;\n                }), n.remove(a), Dt(Jt(a, e), function (t) {\n                  i.push(t), n.insert(t);\n                });\n              }\n            } else (i = Jt(t, e).features).forEach(function (t) {\n              t.bbox || (t.bbox = Nt(Ft(t)));\n            }), n.load(ht(i));\n          }), ht(i);\n        }\n        function Jt(t, e) {\n          var i = [],\n            n = Pt(t)[0],\n            r = Pt(t)[t.geometry.coordinates.length - 1];\n          if (Xt(n, Ct(e)) || Xt(r, Ct(e))) return ht([t]);\n          var a = It(),\n            o = Tt(t);\n          a.load(o);\n          var s = a.search(e);\n          if (!s.features.length) return ht([t]);\n          var l = Yt(e, s),\n            h = function (t, e, i) {\n              var n = i;\n              return Dt(t, function (t, r) {\n                n = 0 === r && i === undefined ? t : e(n, t, r);\n              }), n;\n            }(o, function (t, n, r) {\n              var a = Pt(n)[1],\n                o = Ct(e);\n              return r === l.id ? (t.push(o), i.push(lt(t)), Xt(o, a) ? [o] : [o, a]) : (t.push(a), t);\n            }, [n]);\n          return h.length > 1 && i.push(lt(h)), ht(i);\n        }\n        function Yt(t, e) {\n          if (!e.features.length) throw new Error(\"lines must contain features\");\n          if (1 === e.features.length) return e.features[0];\n          var i,\n            n = Infinity;\n          return Dt(e, function (e) {\n            var r = Ht(e, t).properties.dist;\n            r < n && (i = e, n = r);\n          }), i;\n        }\n        function Xt(t, e) {\n          return t[0] === e[0] && t[1] === e[1];\n        }\n        const Zt = function (t, e) {\n          if (!t) throw new Error(\"line is required\");\n          if (!e) throw new Error(\"splitter is required\");\n          var i = St(t),\n            n = St(e);\n          if (\"LineString\" !== i) throw new Error(\"line must be LineString\");\n          if (\"FeatureCollection\" === n) throw new Error(\"splitter cannot be a FeatureCollection\");\n          if (\"GeometryCollection\" === n) throw new Error(\"splitter cannot be a GeometryCollection\");\n          var r = Ut(e, {\n            precision: 7\n          });\n          switch (n) {\n            case \"Point\":\n              return Jt(t, r);\n            case \"MultiPoint\":\n              return qt(t, r);\n            case \"LineString\":\n            case \"MultiLineString\":\n            case \"Polygon\":\n            case \"MultiPolygon\":\n              return qt(t, At(t, r));\n          }\n        };\n        function $t(t, e, i) {\n          if (void 0 === i && (i = {}), !t) throw new Error(\"point is required\");\n          if (!e) throw new Error(\"polygon is required\");\n          var n = Ct(t),\n            r = Et(e),\n            a = r.type,\n            o = e.bbox,\n            s = r.coordinates;\n          if (o && !1 === function (t, e) {\n            return e[0] <= t[0] && e[1] <= t[1] && e[2] >= t[0] && e[3] >= t[1];\n          }(n, o)) return !1;\n          \"Polygon\" === a && (s = [s]);\n          for (var l = !1, h = 0; h < s.length && !l; h++) if (Wt(n, s[h][0], i.ignoreBoundary)) {\n            for (var u = !1, c = 1; c < s[h].length && !u;) Wt(n, s[h][c], !i.ignoreBoundary) && (u = !0), c++;\n            u || (l = !0);\n          }\n          return l;\n        }\n        function Wt(t, e, i) {\n          var n = !1;\n          e[0][0] === e[e.length - 1][0] && e[0][1] === e[e.length - 1][1] && (e = e.slice(0, e.length - 1));\n          for (var r = 0, a = e.length - 1; r < e.length; a = r++) {\n            var o = e[r][0],\n              s = e[r][1],\n              l = e[a][0],\n              h = e[a][1];\n            if (t[1] * (o - l) + s * (l - t[0]) + h * (t[0] - o) == 0 && (o - t[0]) * (l - t[0]) <= 0 && (s - t[1]) * (h - t[1]) <= 0) return !i;\n            s > t[1] != h > t[1] && t[0] < (l - o) * (t[1] - s) / (h - s) + o && (n = !n);\n          }\n          return n;\n        }\n        function Qt(t, e, i, n, r) {\n          var a = i[0],\n            o = i[1],\n            s = t[0],\n            l = t[1],\n            h = e[0],\n            u = e[1],\n            c = h - s,\n            p = u - l,\n            d = (i[0] - s) * p - (i[1] - l) * c;\n          if (null !== r) {\n            if (Math.abs(d) > r) return !1;\n          } else if (0 !== d) return !1;\n          return n ? \"start\" === n ? Math.abs(c) >= Math.abs(p) ? c > 0 ? s < a && a <= h : h <= a && a < s : p > 0 ? l < o && o <= u : u <= o && o < l : \"end\" === n ? Math.abs(c) >= Math.abs(p) ? c > 0 ? s <= a && a < h : h < a && a <= s : p > 0 ? l <= o && o < u : u < o && o <= l : \"both\" === n && (Math.abs(c) >= Math.abs(p) ? c > 0 ? s < a && a < h : h < a && a < s : p > 0 ? l < o && o < u : u < o && o < l) : Math.abs(c) >= Math.abs(p) ? c > 0 ? s <= a && a <= h : h <= a && a <= s : p > 0 ? l <= o && o <= u : u <= o && o <= l;\n        }\n        const te = function (t, e, i) {\n          void 0 === i && (i = {});\n          for (var n = Ct(t), r = Pt(e), a = 0; a < r.length - 1; a++) {\n            var o = !1;\n            if (i.ignoreEndVertices && (0 === a && (o = \"start\"), a === r.length - 2 && (o = \"end\"), 0 === a && a + 1 === r.length - 1 && (o = \"both\")), Qt(r[a], r[a + 1], n, o, \"undefined\" == typeof i.epsilon ? null : i.epsilon)) return !0;\n          }\n          return !1;\n        };\n        function ee(t, e) {\n          var i = Et(t),\n            n = Et(e),\n            r = i.type,\n            a = n.type,\n            o = i.coordinates,\n            s = n.coordinates;\n          switch (r) {\n            case \"Point\":\n              if (\"Point\" === a) return ne(o, s);\n              throw new Error(\"feature2 \" + a + \" geometry not supported\");\n            case \"MultiPoint\":\n              switch (a) {\n                case \"Point\":\n                  return function (t, e) {\n                    var i,\n                      n = !1;\n                    for (i = 0; i < t.coordinates.length; i++) if (ne(t.coordinates[i], e.coordinates)) {\n                      n = !0;\n                      break;\n                    }\n                    return n;\n                  }(i, n);\n                case \"MultiPoint\":\n                  return function (t, e) {\n                    for (var i = 0, n = e.coordinates; i < n.length; i++) {\n                      for (var r = n[i], a = !1, o = 0, s = t.coordinates; o < s.length; o++) {\n                        if (ne(r, s[o])) {\n                          a = !0;\n                          break;\n                        }\n                      }\n                      if (!a) return !1;\n                    }\n                    return !0;\n                  }(i, n);\n                default:\n                  throw new Error(\"feature2 \" + a + \" geometry not supported\");\n              }\n            case \"LineString\":\n              switch (a) {\n                case \"Point\":\n                  return te(n, i, {\n                    ignoreEndVertices: !0\n                  });\n                case \"LineString\":\n                  return function (t, e) {\n                    for (var i = !1, n = 0, r = e.coordinates; n < r.length; n++) {\n                      var a = r[n];\n                      if (te({\n                        type: \"Point\",\n                        coordinates: a\n                      }, t, {\n                        ignoreEndVertices: !0\n                      }) && (i = !0), !te({\n                        type: \"Point\",\n                        coordinates: a\n                      }, t, {\n                        ignoreEndVertices: !1\n                      })) return !1;\n                    }\n                    return i;\n                  }(i, n);\n                case \"MultiPoint\":\n                  return function (t, e) {\n                    for (var i = !1, n = 0, r = e.coordinates; n < r.length; n++) {\n                      var a = r[n];\n                      if (te(a, t, {\n                        ignoreEndVertices: !0\n                      }) && (i = !0), !te(a, t)) return !1;\n                    }\n                    if (i) return !0;\n                    return !1;\n                  }(i, n);\n                default:\n                  throw new Error(\"feature2 \" + a + \" geometry not supported\");\n              }\n            case \"Polygon\":\n              switch (a) {\n                case \"Point\":\n                  return $t(n, i, {\n                    ignoreBoundary: !0\n                  });\n                case \"LineString\":\n                  return function (t, e) {\n                    var i = !1,\n                      n = 0,\n                      r = Ft(t),\n                      a = Ft(e);\n                    if (!ie(r, a)) return !1;\n                    for (; n < e.coordinates.length - 1; n++) {\n                      if ($t({\n                        type: \"Point\",\n                        coordinates: re(e.coordinates[n], e.coordinates[n + 1])\n                      }, t, {\n                        ignoreBoundary: !0\n                      })) {\n                        i = !0;\n                        break;\n                      }\n                    }\n                    return i;\n                  }(i, n);\n                case \"Polygon\":\n                  return function (t, e) {\n                    if (\"Feature\" === t.type && null === t.geometry) return !1;\n                    if (\"Feature\" === e.type && null === e.geometry) return !1;\n                    var i = Ft(t),\n                      n = Ft(e);\n                    if (!ie(i, n)) return !1;\n                    for (var r = Et(e).coordinates, a = 0, o = r; a < o.length; a++) for (var s = 0, l = o[a]; s < l.length; s++) {\n                      if (!$t(l[s], t)) return !1;\n                    }\n                    return !0;\n                  }(i, n);\n                case \"MultiPoint\":\n                  return function (t, e) {\n                    for (var i = 0, n = e.coordinates; i < n.length; i++) {\n                      if (!$t(n[i], t, {\n                        ignoreBoundary: !0\n                      })) return !1;\n                    }\n                    return !0;\n                  }(i, n);\n                default:\n                  throw new Error(\"feature2 \" + a + \" geometry not supported\");\n              }\n            default:\n              throw new Error(\"feature1 \" + r + \" geometry not supported\");\n          }\n        }\n        function ie(t, e) {\n          return !(t[0] > e[0]) && !(t[2] < e[2]) && !(t[1] > e[1]) && !(t[3] < e[3]);\n        }\n        function ne(t, e) {\n          return t[0] === e[0] && t[1] === e[1];\n        }\n        function re(t, e) {\n          return [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2];\n        }\n        var ae = i(2676),\n          oe = i.n(ae);\n        function se(t) {\n          var e = {\n            type: \"Feature\"\n          };\n          return e.geometry = t, e;\n        }\n        function le(t) {\n          return \"Feature\" === t.type ? t.geometry : t;\n        }\n        function he(t) {\n          return t && t.geometry && t.geometry.coordinates ? t.geometry.coordinates : t;\n        }\n        function ue(t) {\n          return se({\n            type: \"Polygon\",\n            coordinates: t\n          });\n        }\n        function ce(t) {\n          return se({\n            type: \"MultiPolygon\",\n            coordinates: t\n          });\n        }\n        function pe(t) {\n          return Array.isArray(t) ? 1 + pe(t[0]) : -1;\n        }\n        function de(t) {\n          t instanceof L.Polyline && (t = t.toGeoJSON(15));\n          var e = he(t),\n            i = pe(e),\n            n = [];\n          return i > 1 ? e.forEach(function (t) {\n            n.push(function (t) {\n              return se({\n                type: \"LineString\",\n                coordinates: t\n              });\n            }(t));\n          }) : n.push(t), n;\n        }\n        function fe(t) {\n          var e = [];\n          return t.eachLayer(function (t) {\n            e.push(he(t.toGeoJSON(15)));\n          }), function (t) {\n            return se({\n              type: \"MultiLineString\",\n              coordinates: t\n            });\n          }(e);\n        }\n        function ge(t, e) {\n          return function (t) {\n            if (Array.isArray(t)) return t;\n          }(t) || function (t, e) {\n            var i = null == t ? null : \"undefined\" != typeof Symbol && t[Symbol.iterator] || t[\"@@iterator\"];\n            if (null == i) return;\n            var n,\n              r,\n              a = [],\n              o = !0,\n              s = !1;\n            try {\n              for (i = i.call(t); !(o = (n = i.next()).done) && (a.push(n.value), !e || a.length !== e); o = !0);\n            } catch (l) {\n              s = !0, r = l;\n            } finally {\n              try {\n                o || null == i[\"return\"] || i[\"return\"]();\n              } finally {\n                if (s) throw r;\n              }\n            }\n            return a;\n          }(t, e) || function (t, e) {\n            if (!t) return;\n            if (\"string\" == typeof t) return _e(t, e);\n            var i = Object.prototype.toString.call(t).slice(8, -1);\n            \"Object\" === i && t.constructor && (i = t.constructor.name);\n            if (\"Map\" === i || \"Set\" === i) return Array.from(t);\n            if (\"Arguments\" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return _e(t, e);\n          }(t, e) || function () {\n            throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n          }();\n        }\n        function _e(t, e) {\n          (null == e || e > t.length) && (e = t.length);\n          for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];\n          return n;\n        }\n        function me(t) {\n          return function (t) {\n            if (Array.isArray(t)) return ye(t);\n          }(t) || function (t) {\n            if (\"undefined\" != typeof Symbol && null != t[Symbol.iterator] || null != t[\"@@iterator\"]) return Array.from(t);\n          }(t) || function (t, e) {\n            if (!t) return;\n            if (\"string\" == typeof t) return ye(t, e);\n            var i = Object.prototype.toString.call(t).slice(8, -1);\n            \"Object\" === i && t.constructor && (i = t.constructor.name);\n            if (\"Map\" === i || \"Set\" === i) return Array.from(t);\n            if (\"Arguments\" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return ye(t, e);\n          }(t) || function () {\n            throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n          }();\n        }\n        function ye(t, e) {\n          (null == e || e > t.length) && (e = t.length);\n          for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];\n          return n;\n        }\n        nt.Cut = nt.Polygon.extend({\n          initialize: function (t) {\n            this._map = t, this._shape = \"Cut\", this.toolbarButtonName = \"cutPolygon\";\n          },\n          _finishShape: function () {\n            var t = this;\n            if (this._editedLayers = [], (this.options.allowSelfIntersection || (this._handleSelfIntersection(!0, this._layer.getLatLngs()[0]), !this._doesSelfIntersect)) && (!this.options.requireSnapToFinish || this._hintMarker._snapped || this._isFirstLayer())) {\n              var e = this._layer.getLatLngs();\n              if (!(e.length <= 2)) {\n                var i = L.polygon(e, this.options.pathOptions);\n                i._latlngInfos = this._layer._latlngInfo, this.cut(i), this._cleanupSnapping(), this._otherSnapLayers.splice(this._tempSnapLayerIndex, 1), delete this._tempSnapLayerIndex, this._editedLayers.forEach(function (e) {\n                  var i = e.layer,\n                    n = e.originalLayer;\n                  t._fireCut(n, i, n), t._fireCut(t._map, i, n), n.pm._fireEdit();\n                }), this._editedLayers = [], this.disable(), this.options.continueDrawing && this.enable();\n              }\n            }\n          },\n          cut: function (t) {\n            var e = this,\n              i = this._map._layers,\n              n = t._latlngInfos || [];\n            Object.keys(i).map(function (t) {\n              return i[t];\n            }).filter(function (t) {\n              return t.pm;\n            }).filter(function (t) {\n              return !t._pmTempLayer;\n            }).filter(function (t) {\n              return !L.PM.optIn && !t.options.pmIgnore || L.PM.optIn && !1 === t.options.pmIgnore;\n            }).filter(function (t) {\n              return t instanceof L.Polyline;\n            }).filter(function (e) {\n              return e !== t;\n            }).filter(function (t) {\n              return t.pm.options.allowCutting;\n            }).filter(function (t) {\n              return !(e.options.layersToCut && L.Util.isArray(e.options.layersToCut) && e.options.layersToCut.length > 0) || e.options.layersToCut.indexOf(t) > -1;\n            }).filter(function (t) {\n              return !e._layerGroup.hasLayer(t);\n            }).filter(function (e) {\n              try {\n                var i = !!At(t.toGeoJSON(15), e.toGeoJSON(15)).features.length > 0;\n                return i || e instanceof L.Polyline && !(e instanceof L.Polygon) ? i : (n = t.toGeoJSON(15), r = e.toGeoJSON(15), a = le(n), o = le(r), !(0 === (s = oe().intersection(a.coordinates, o.coordinates)).length || !(1 === s.length ? ue(s[0]) : ce(s))));\n              } catch (l) {\n                return e instanceof L.Polygon && console.error(\"You can't cut polygons with self-intersections\"), !1;\n              }\n              var n, r, a, o, s;\n            }).forEach(function (i) {\n              var r;\n              if (i instanceof L.Polygon) {\n                var a = (r = L.polygon(i.getLatLngs())).getLatLngs();\n                n.forEach(function (t) {\n                  if (t && t.snapInfo) {\n                    var i = t.latlng,\n                      n = e._calcClosestLayer(i, [r]);\n                    if (n && n.segment && n.distance < e.options.snapDistance) {\n                      var o = n.segment;\n                      if (o && 2 === o.length) {\n                        var s = L.PM.Utils._getIndexFromSegment(a, o),\n                          l = s.indexPath,\n                          h = s.parentPath,\n                          u = s.newIndex;\n                        (l.length > 1 ? B()(a, h) : a).splice(u, 0, i);\n                      }\n                    }\n                  }\n                });\n              } else r = i;\n              var o = e._cutLayer(t, r),\n                s = L.geoJSON(o, i.options);\n              if (1 === s.getLayers().length) {\n                var l = s.getLayers();\n                s = ge(l, 1)[0];\n              }\n              e._setPane(s, \"layerPane\");\n              var h = s.addTo(e._map.pm._getContainingLayer());\n              if (h.pm.enable(i.pm.options), h.pm.disable(), i._pmTempLayer = !0, t._pmTempLayer = !0, i.remove(), i.removeFrom(e._map.pm._getContainingLayer()), t.remove(), t.removeFrom(e._map.pm._getContainingLayer()), h.getLayers && 0 === h.getLayers().length && e._map.pm.removeLayer({\n                target: h\n              }), h instanceof L.LayerGroup ? (h.eachLayer(function (t) {\n                e._addDrawnLayerProp(t);\n              }), e._addDrawnLayerProp(h)) : e._addDrawnLayerProp(h), e.options.layersToCut && L.Util.isArray(e.options.layersToCut) && e.options.layersToCut.length > 0) {\n                var u = e.options.layersToCut.indexOf(i);\n                u > -1 && e.options.layersToCut.splice(u, 1);\n              }\n              e._editedLayers.push({\n                layer: h,\n                originalLayer: i\n              });\n            });\n          },\n          _cutLayer: function (t, e) {\n            var i,\n              n,\n              r,\n              a,\n              o,\n              s,\n              l = L.geoJSON();\n            if (e instanceof L.Polygon) n = e.toGeoJSON(15), r = t.toGeoJSON(15), a = le(n), o = le(r), i = 0 === (s = oe().difference(a.coordinates, o.coordinates)).length ? null : 1 === s.length ? ue(s[0]) : ce(s);else {\n              var h = de(e);\n              h.forEach(function (e) {\n                var i = Zt(e, t.toGeoJSON(15));\n                (i && i.features.length > 0 ? L.geoJSON(i) : L.geoJSON(e)).getLayers().forEach(function (e) {\n                  ee(t.toGeoJSON(15), e.toGeoJSON(15)) || e.addTo(l);\n                });\n              }), i = h.length > 1 ? fe(l) : l.toGeoJSON(15);\n            }\n            return i;\n          },\n          _change: L.Util.falseFn\n        }), nt.Text = nt.extend({\n          initialize: function (t) {\n            this._map = t, this._shape = \"Text\", this.toolbarButtonName = \"drawText\";\n          },\n          enable: function (t) {\n            L.Util.setOptions(this, t), this._enabled = !0, this._map.on(\"click\", this._createMarker, this), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !0), this._hintMarker = L.marker(this._map.getCenter(), {\n              interactive: !1,\n              zIndexOffset: 100,\n              icon: L.divIcon({\n                className: \"marker-icon cursor-marker\"\n              })\n            }), this._setPane(this._hintMarker, \"vertexPane\"), this._hintMarker._pmTempLayer = !0, this._hintMarker.addTo(this._map), this.options.cursorMarker && L.DomUtil.addClass(this._hintMarker._icon, \"visible\"), this.options.tooltips && this._hintMarker.bindTooltip(I(\"tooltips.placeText\"), {\n              permanent: !0,\n              offset: L.point(0, 10),\n              direction: \"bottom\",\n              opacity: .8\n            }).openTooltip(), this._layer = this._hintMarker, this._map.on(\"mousemove\", this._syncHintMarker, this), this._fireDrawStart(), this._setGlobalDrawMode();\n          },\n          disable: function () {\n            this._enabled && (this._enabled = !1, this._map.off(\"click\", this._createMarker, this), this._hintMarker.remove(), this._map.off(\"mousemove\", this._syncHintMarker, this), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !1), this.options.snappable && this._cleanupSnapping(), this._fireDrawEnd(), this._setGlobalDrawMode());\n          },\n          enabled: function () {\n            return this._enabled;\n          },\n          toggle: function (t) {\n            this.enabled() ? this.disable() : this.enable(t);\n          },\n          _syncHintMarker: function (t) {\n            if (this._hintMarker.setLatLng(t.latlng), this.options.snappable) {\n              var e = t;\n              e.target = this._hintMarker, this._handleSnapping(e);\n            }\n          },\n          _createMarker: function (t) {\n            var e;\n            if (t.latlng && (!this.options.requireSnapToFinish || this._hintMarker._snapped || this._isFirstLayer())) {\n              this._hintMarker._snapped || this._hintMarker.setLatLng(t.latlng);\n              var i = this._hintMarker.getLatLng();\n              if (this.textArea = this._createTextArea(), null !== (e = this.options.textOptions) && void 0 !== e && e.className) {\n                var n,\n                  r = this.options.textOptions.className.split(\" \");\n                (n = this.textArea.classList).add.apply(n, me(r));\n              }\n              var a = this._createTextIcon(this.textArea),\n                o = new L.Marker(i, {\n                  textMarker: !0,\n                  _textMarkerOverPM: !0,\n                  icon: a\n                });\n              if (this._setPane(o, \"markerPane\"), this._finishLayer(o), o.pm || (o.options.draggable = !1), o.addTo(this._map.pm._getContainingLayer()), o.pm) {\n                var s, l, h, u, c;\n                o.pm.textArea = this.textArea, L.setOptions(o.pm, {\n                  removeIfEmpty: null === (s = null === (l = this.options.textOptions) || void 0 === l ? void 0 : l.removeIfEmpty) || void 0 === s || s\n                });\n                var p = null === (h = null === (u = this.options.textOptions) || void 0 === u ? void 0 : u.focusAfterDraw) || void 0 === h || h;\n                o.pm._createTextMarker(p), null !== (c = this.options.textOptions) && void 0 !== c && c.text && o.pm.setText(this.options.textOptions.text);\n              }\n              this._fireCreate(o), this._cleanupSnapping(), this.disable(), this.options.continueDrawing && this.enable();\n            }\n          },\n          _createTextArea: function () {\n            var t = document.createElement(\"textarea\");\n            return t.autofocus = !0, t.readOnly = !0, t.classList.add(\"pm-textarea\", \"pm-disabled\"), t;\n          },\n          _createTextIcon: function (t) {\n            return L.divIcon({\n              className: \"pm-text-marker\",\n              html: t\n            });\n          }\n        });\n        const ve = {\n          enableLayerDrag: function () {\n            if (this.options.draggable && this._layer._map) {\n              this.disable(), this._layerDragEnabled = !0, this._map || (this._map = this._layer._map), (this._layer instanceof L.Marker || this._layer instanceof L.ImageOverlay) && L.DomEvent.on(this._getDOMElem(), \"dragstart\", this._stopDOMImageDrag), this._layer.dragging && this._layer.dragging.disable(), this._tempDragCoord = null, K(this._layer) instanceof L.Canvas ? (this._layer.on(\"mouseout\", this.removeDraggingClass, this), this._layer.on(\"mouseover\", this.addDraggingClass, this)) : this.addDraggingClass(), this._originalMapDragState = this._layer._map.dragging._enabled, this._safeToCacheDragState = !0;\n              var t = this._getDOMElem();\n              t && (K(this._layer) instanceof L.Canvas ? (this._layer.on(\"touchstart mousedown\", this._dragMixinOnMouseDown, this), this._map.pm._addTouchEvents(t)) : L.DomEvent.on(t, \"touchstart mousedown\", this._simulateMouseDownEvent, this)), this._fireDragEnable();\n            }\n          },\n          disableLayerDrag: function () {\n            this._layerDragEnabled = !1, K(this._layer) instanceof L.Canvas ? (this._layer.off(\"mouseout\", this.removeDraggingClass, this), this._layer.off(\"mouseover\", this.addDraggingClass, this)) : this.removeDraggingClass(), this._originalMapDragState && this._dragging && this._map.dragging.enable(), this._safeToCacheDragState = !1, this._layer.dragging && this._layer.dragging.disable();\n            var t = this._getDOMElem();\n            t && (K(this._layer) instanceof L.Canvas ? (this._layer.off(\"touchstart mousedown\", this._dragMixinOnMouseDown, this), this._map.pm._removeTouchEvents(t)) : L.DomEvent.off(t, \"touchstart mousedown\", this._simulateMouseDownEvent, this)), this._layerDragged && this._fireUpdate(), this._layerDragged = !1, this._fireDragDisable();\n          },\n          dragging: function () {\n            return this._dragging;\n          },\n          layerDragEnabled: function () {\n            return !!this._layerDragEnabled;\n          },\n          _simulateMouseDownEvent: function (t) {\n            var e = t.touches ? t.touches[0] : t,\n              i = {\n                originalEvent: e,\n                target: this._layer\n              };\n            return i.containerPoint = this._map.mouseEventToContainerPoint(e), i.latlng = this._map.containerPointToLatLng(i.containerPoint), this._dragMixinOnMouseDown(i), !1;\n          },\n          _simulateMouseMoveEvent: function (t) {\n            var e = t.touches ? t.touches[0] : t,\n              i = {\n                originalEvent: e,\n                target: this._layer\n              };\n            return i.containerPoint = this._map.mouseEventToContainerPoint(e), i.latlng = this._map.containerPointToLatLng(i.containerPoint), this._dragMixinOnMouseMove(i), !1;\n          },\n          _simulateMouseUpEvent: function (t) {\n            var e = {\n              originalEvent: t.touches ? t.touches[0] : t,\n              target: this._layer\n            };\n            return -1 === t.type.indexOf(\"touch\") && (e.containerPoint = this._map.mouseEventToContainerPoint(t), e.latlng = this._map.containerPointToLatLng(e.containerPoint)), this._dragMixinOnMouseUp(e), !1;\n          },\n          _dragMixinOnMouseDown: function (t) {\n            if (!(t.originalEvent.button > 0)) {\n              this._overwriteEventIfItComesFromMarker(t);\n              var e = t._fromLayerSync,\n                i = this._syncLayers(\"_dragMixinOnMouseDown\", t);\n              this._layer instanceof L.Marker && (!this.options.snappable || e || i ? this._disableSnapping() : this._initSnappableMarkers()), this._layer instanceof L.CircleMarker && !(this._layer instanceof L.Circle) && (!this.options.snappable || e || i ? this._layer.pm.options.editable ? this._layer.pm._disableSnapping() : this._layer.pm._disableSnappingDrag() : this._layer.pm.options.editable || this._initSnappableMarkersDrag()), this._safeToCacheDragState && (this._originalMapDragState = this._layer._map.dragging._enabled, this._safeToCacheDragState = !1), this._tempDragCoord = t.latlng, L.DomEvent.on(this._map.getContainer(), \"touchend mouseup\", this._simulateMouseUpEvent, this), L.DomEvent.on(this._map.getContainer(), \"touchmove mousemove\", this._simulateMouseMoveEvent, this);\n            }\n          },\n          _dragMixinOnMouseMove: function (t) {\n            this._overwriteEventIfItComesFromMarker(t);\n            var e = this._getDOMElem();\n            this._syncLayers(\"_dragMixinOnMouseMove\", t), this._dragging || (this._dragging = !0, L.DomUtil.addClass(e, \"leaflet-pm-dragging\"), this._layer instanceof L.Marker || this._layer.bringToFront(), this._originalMapDragState && this._map.dragging.disable(), this._fireDragStart()), this._tempDragCoord || (this._tempDragCoord = t.latlng), this._onLayerDrag(t), this._layer instanceof L.CircleMarker && this._layer.pm._updateHiddenPolyCircle();\n          },\n          _dragMixinOnMouseUp: function (t) {\n            var e = this,\n              i = this._getDOMElem();\n            return this._syncLayers(\"_dragMixinOnMouseUp\", t), this._originalMapDragState && this._map.dragging.enable(), this._safeToCacheDragState = !0, L.DomEvent.off(this._map.getContainer(), \"touchmove mousemove\", this._simulateMouseMoveEvent, this), L.DomEvent.off(this._map.getContainer(), \"touchend mouseup\", this._simulateMouseUpEvent, this), !!this._dragging && (this._layer instanceof L.CircleMarker && this._layer.pm._updateHiddenPolyCircle(), this._layerDragged = !0, window.setTimeout(function () {\n              e._dragging = !1, i && L.DomUtil.removeClass(i, \"leaflet-pm-dragging\"), e._fireDragEnd(), e._fireEdit(), e._layerEdited = !0;\n            }, 10), !0);\n          },\n          _onLayerDrag: function (t) {\n            var e = t.latlng,\n              i = e.lat - this._tempDragCoord.lat,\n              n = e.lng - this._tempDragCoord.lng,\n              r = function u(t) {\n                return t.map(function (t) {\n                  if (Array.isArray(t)) return u(t);\n                  var e = {\n                    lat: t.lat + i,\n                    lng: t.lng + n\n                  };\n                  return (t.alt || 0 === t.alt) && (e.alt = t.alt), e;\n                });\n              };\n            if (this._layer instanceof L.Circle || this._layer instanceof L.CircleMarker && this._layer.options.editable) {\n              var a = r([this._layer.getLatLng()]);\n              this._layer.setLatLng(a[0]), this._fireChange(this._layer.getLatLng(), \"Edit\");\n            } else if (this._layer instanceof L.CircleMarker || this._layer instanceof L.Marker) {\n              var o = this._layer.getLatLng();\n              this._layer._snapped && (o = this._layer._orgLatLng);\n              var s = r([o]);\n              this._layer.setLatLng(s[0]), this._fireChange(this._layer.getLatLng(), \"Edit\");\n            } else if (this._layer instanceof L.ImageOverlay) {\n              var l = r([this._layer.getBounds().getNorthWest(), this._layer.getBounds().getSouthEast()]);\n              this._layer.setBounds(l), this._fireChange(this._layer.getBounds(), \"Edit\");\n            } else {\n              var h = r(this._layer.getLatLngs());\n              this._layer.setLatLngs(h), this._fireChange(this._layer.getLatLngs(), \"Edit\");\n            }\n            this._tempDragCoord = e, t.layer = this._layer, this._fireDrag(t);\n          },\n          addDraggingClass: function () {\n            var t = this._getDOMElem();\n            t && L.DomUtil.addClass(t, \"leaflet-pm-draggable\");\n          },\n          removeDraggingClass: function () {\n            var t = this._getDOMElem();\n            t && L.DomUtil.removeClass(t, \"leaflet-pm-draggable\");\n          },\n          _getDOMElem: function () {\n            var t = null;\n            return this._layer._path ? t = this._layer._path : this._layer._renderer && this._layer._renderer._container ? t = this._layer._renderer._container : this._layer._image ? t = this._layer._image : this._layer._icon && (t = this._layer._icon), t;\n          },\n          _overwriteEventIfItComesFromMarker: function (t) {\n            t.target.getLatLng && (!t.target._radius || t.target._radius <= 10) && (t.containerPoint = this._map.mouseEventToContainerPoint(t.originalEvent), t.latlng = this._map.containerPointToLatLng(t.containerPoint));\n          },\n          _syncLayers: function (t, e) {\n            var i = this;\n            if (this.enabled()) return !1;\n            if (!e._fromLayerSync && this._layer === e.target && this.options.syncLayersOnDrag) {\n              e._fromLayerSync = !0;\n              var n = [];\n              if (L.Util.isArray(this.options.syncLayersOnDrag)) n = this.options.syncLayersOnDrag, this.options.syncLayersOnDrag.forEach(function (t) {\n                t instanceof L.LayerGroup && (n = n.concat(t.pm.getLayers(!0)));\n              });else if (!0 === this.options.syncLayersOnDrag && this._parentLayerGroup) for (var r in this._parentLayerGroup) {\n                var a = this._parentLayerGroup[r];\n                a.pm && (n = a.pm.getLayers(!0));\n              }\n              return L.Util.isArray(n) && n.length > 0 && (n = n.filter(function (t) {\n                return !!t.pm;\n              }).filter(function (t) {\n                return !!t.pm.options.draggable;\n              })).forEach(function (n) {\n                n !== i._layer && n.pm[t] && (n._snapped = !1, n.pm[t](e));\n              }), n.length > 0;\n            }\n            return !1;\n          },\n          _stopDOMImageDrag: function (t) {\n            return t.preventDefault(), !1;\n          }\n        };\n        function Le(t, e, i) {\n          var n = i.getMaxZoom();\n          if (n === Infinity && (n = i.getZoom()), L.Util.isArray(t)) {\n            var r = [];\n            return t.forEach(function (t) {\n              r.push(Le(t, e, i));\n            }), r;\n          }\n          return t instanceof L.LatLng ? function (t, e, i, n) {\n            return i.unproject(e.transform(i.project(t, n)), n);\n          }(t, e, i, n) : null;\n        }\n        function be(t, e) {\n          e instanceof L.Layer && (e = e.getLatLng());\n          var i = t.getMaxZoom();\n          return i === Infinity && (i = t.getZoom()), t.project(e, i);\n        }\n        function ke(t, e) {\n          var i = t.getMaxZoom();\n          return i === Infinity && (i = t.getZoom()), t.unproject(e, i);\n        }\n        var Me = {\n          _onRotateStart: function (t) {\n            this._preventRenderingMarkers(!0), this._rotationOriginLatLng = this._getRotationCenter().clone(), this._rotationOriginPoint = be(this._map, this._rotationOriginLatLng), this._rotationStartPoint = be(this._map, t.target.getLatLng()), this._initialRotateLatLng = U(this._layer), this._startAngle = this.getAngle();\n            var e = U(this._rotationLayer, this._rotationLayer.pm._rotateOrgLatLng);\n            this._fireRotationStart(this._rotationLayer, e), this._fireRotationStart(this._map, e);\n          },\n          _onRotate: function (t) {\n            var e = be(this._map, t.target.getLatLng()),\n              i = this._rotationStartPoint,\n              n = this._rotationOriginPoint,\n              r = Math.atan2(e.y - n.y, e.x - n.x) - Math.atan2(i.y - n.y, i.x - n.x);\n            this._layer.setLatLngs(this._rotateLayer(r, this._initialRotateLatLng, this._rotationOriginLatLng, L.PM.Matrix.init(), this._map));\n            var a = this;\n            !function h(t) {\n              var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [],\n                i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n              if (i > -1 && e.push(i), L.Util.isArray(t[0])) t.forEach(function (t, i) {\n                return h(t, e.slice(), i);\n              });else {\n                var n = B()(a._markers, e);\n                t.forEach(function (t, e) {\n                  n[e].setLatLng(t);\n                });\n              }\n            }(this._layer.getLatLngs());\n            var o = U(this._rotationLayer);\n            this._rotationLayer.setLatLngs(this._rotateLayer(r, this._rotationLayer.pm._rotateOrgLatLng, this._rotationOriginLatLng, L.PM.Matrix.init(), this._map));\n            var s = 180 * r / Math.PI,\n              l = (s = s < 0 ? s + 360 : s) + this._startAngle;\n            this._setAngle(l), this._rotationLayer.pm._setAngle(l), this._fireRotation(this._rotationLayer, s, o), this._fireRotation(this._map, s, o), this._rotationLayer.pm._fireChange(this._rotationLayer.getLatLngs(), \"Rotation\");\n          },\n          _onRotateEnd: function () {\n            var t = this._startAngle;\n            delete this._rotationOriginLatLng, delete this._rotationOriginPoint, delete this._rotationStartPoint, delete this._initialRotateLatLng, delete this._startAngle;\n            var e = U(this._rotationLayer, this._rotationLayer.pm._rotateOrgLatLng);\n            this._rotationLayer.pm._rotateOrgLatLng = U(this._rotationLayer), this._fireRotationEnd(this._rotationLayer, t, e), this._fireRotationEnd(this._map, t, e), this._rotationLayer.pm._fireEdit(this._rotationLayer, \"Rotation\"), this._preventRenderingMarkers(!1), this._layerRotated = !0;\n          },\n          _rotateLayer: function (t, e, i, n, r) {\n            var a = be(r, i);\n            return this._matrix = n.clone().rotate(t, a).flip(), Le(e, this._matrix, r);\n          },\n          _setAngle: function (t) {\n            t = t < 0 ? t + 360 : t, this._angle = t % 360;\n          },\n          _getRotationCenter: function () {\n            var t = L.polygon(this._layer.getLatLngs(), {\n                stroke: !1,\n                fill: !1,\n                pmIgnore: !0\n              }).addTo(this._layer._map),\n              e = t.getCenter();\n            return t.removeFrom(this._layer._map), e;\n          },\n          enableRotate: function () {\n            if (this.options.allowRotation) {\n              this.rotateEnabled() && this.disableRotate();\n              this._rotatePoly = L.polygon(this._layer.getLatLngs(), {\n                fill: !1,\n                stroke: !1,\n                pmIgnore: !1,\n                snapIgnore: !0\n              }), this._rotatePoly._pmTempLayer = !0, this._rotatePoly.addTo(this._layer._map), this._rotatePoly.pm._setAngle(this.getAngle()), this._rotatePoly.pm.setOptions(this._layer._map.pm.getGlobalOptions()), this._rotatePoly.pm.setOptions({\n                rotate: !0,\n                snappable: !1,\n                hideMiddleMarkers: !0\n              }), this._rotatePoly.pm._rotationLayer = this._layer, this._rotatePoly.pm.enable(), this._rotateOrgLatLng = U(this._layer), this._rotateEnabled = !0, this._layer.on(\"remove\", this.disableRotate, this), this._fireRotationEnable(this._layer), this._fireRotationEnable(this._layer._map);\n            } else this.disableRotate();\n          },\n          disableRotate: function () {\n            this.rotateEnabled() && (this._rotatePoly.pm._layerRotated && this._fireUpdate(), this._rotatePoly.pm._layerRotated = !1, this._rotatePoly.pm.disable(), this._rotatePoly.remove(), this._rotatePoly.pm.setOptions({\n              rotate: !1\n            }), this._rotatePoly = undefined, this._rotateOrgLatLng = undefined, this._layer.off(\"remove\", this.disableRotate, this), this._rotateEnabled = !1, this._fireRotationDisable(this._layer), this._fireRotationDisable(this._layer._map));\n          },\n          rotateEnabled: function () {\n            return this._rotateEnabled;\n          },\n          rotateLayer: function (t) {\n            var e = this.getAngle(),\n              i = this._layer.getLatLngs(),\n              n = t * (Math.PI / 180);\n            this._layer.setLatLngs(this._rotateLayer(n, this._layer.getLatLngs(), this._getRotationCenter(), L.PM.Matrix.init(), this._layer._map)), this._rotateOrgLatLng = L.polygon(this._layer.getLatLngs()).getLatLngs(), this._setAngle(this.getAngle() + t), this.rotateEnabled() && this._rotatePoly && this._rotatePoly.pm.enabled() && (this._rotatePoly.setLatLngs(this._rotateLayer(n, this._rotatePoly.getLatLngs(), this._getRotationCenter(), L.PM.Matrix.init(), this._rotatePoly._map)), this._rotatePoly.pm._initMarkers());\n            var r = this.getAngle() - e;\n            r = r < 0 ? r + 360 : r, this._startAngle = e, this._fireRotation(this._layer, r, i, this._layer), this._fireRotation(this._map || this._layer._map, r, i, this._layer), delete this._startAngle, this._fireChange(this._layer.getLatLngs(), \"Rotation\");\n          },\n          rotateLayerToAngle: function (t) {\n            var e = t - this.getAngle();\n            this.rotateLayer(e);\n          },\n          getAngle: function () {\n            return this._angle || 0;\n          },\n          setInitAngle: function (t) {\n            this._setAngle(t);\n          }\n        };\n        const xe = Me;\n        const we = L.Class.extend({\n          includes: [ve, it, xe, S],\n          options: {\n            snappable: !0,\n            snapDistance: 20,\n            allowSelfIntersection: !0,\n            allowSelfIntersectionEdit: !1,\n            preventMarkerRemoval: !1,\n            removeLayerBelowMinVertexCount: !0,\n            limitMarkersToCount: -1,\n            hideMiddleMarkers: !1,\n            snapSegment: !0,\n            syncLayersOnDrag: !1,\n            draggable: !0,\n            allowEditing: !0,\n            allowRemoval: !0,\n            allowCutting: !0,\n            allowRotation: !0,\n            addVertexOn: \"click\",\n            removeVertexOn: \"contextmenu\",\n            removeVertexValidation: undefined,\n            addVertexValidation: undefined,\n            moveVertexValidation: undefined\n          },\n          setOptions: function (t) {\n            L.Util.setOptions(this, t);\n          },\n          getOptions: function () {\n            return this.options;\n          },\n          applyOptions: function () {},\n          isPolygon: function () {\n            return this._layer instanceof L.Polygon;\n          },\n          getShape: function () {\n            return this._shape;\n          },\n          _setPane: function (t, e) {\n            \"layerPane\" === e ? t.options.pane = this._map.pm.globalOptions.panes && this._map.pm.globalOptions.panes.layerPane || \"overlayPane\" : \"vertexPane\" === e ? t.options.pane = this._map.pm.globalOptions.panes && this._map.pm.globalOptions.panes.vertexPane || \"markerPane\" : \"markerPane\" === e && (t.options.pane = this._map.pm.globalOptions.panes && this._map.pm.globalOptions.panes.markerPane || \"markerPane\");\n          },\n          remove: function () {\n            (this._map || this._layer._map).pm.removeLayer({\n              target: this._layer\n            });\n          },\n          _vertexValidation: function (t, e) {\n            var i = e.target,\n              n = {\n                layer: this._layer,\n                marker: i,\n                event: e\n              },\n              r = \"\";\n            return \"move\" === t ? r = \"moveVertexValidation\" : \"add\" === t ? r = \"addVertexValidation\" : \"remove\" === t && (r = \"removeVertexValidation\"), this.options[r] && \"function\" == typeof this.options[r] && !this.options[r](n) ? (\"move\" === t && (i._cancelDragEventChain = i.getLatLng()), !1) : (i._cancelDragEventChain = null, !0);\n          },\n          _vertexValidationDrag: function (t) {\n            return !t._cancelDragEventChain || (t._latlng = t._cancelDragEventChain, t.update(), !1);\n          },\n          _vertexValidationDragEnd: function (t) {\n            return !t._cancelDragEventChain || (t._cancelDragEventChain = null, !1);\n          }\n        });\n        function Ce(t) {\n          return function (t) {\n            if (Array.isArray(t)) return Pe(t);\n          }(t) || function (t) {\n            if (\"undefined\" != typeof Symbol && null != t[Symbol.iterator] || null != t[\"@@iterator\"]) return Array.from(t);\n          }(t) || function (t, e) {\n            if (!t) return;\n            if (\"string\" == typeof t) return Pe(t, e);\n            var i = Object.prototype.toString.call(t).slice(8, -1);\n            \"Object\" === i && t.constructor && (i = t.constructor.name);\n            if (\"Map\" === i || \"Set\" === i) return Array.from(t);\n            if (\"Arguments\" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return Pe(t, e);\n          }(t) || function () {\n            throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n          }();\n        }\n        function Pe(t, e) {\n          (null == e || e > t.length) && (e = t.length);\n          for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];\n          return n;\n        }\n        we.LayerGroup = L.Class.extend({\n          initialize: function (t) {\n            var e = this;\n            this._layerGroup = t, this._layers = this.getLayers(), this._getMap(), this._layers.forEach(function (t) {\n              return e._initLayer(t);\n            });\n            this._layerGroup.on(\"layeradd\", L.Util.throttle(function (t) {\n              if (!t.layer._pmTempLayer) {\n                e._layers = e.getLayers();\n                var i = e._layers.filter(function (t) {\n                  return !t.pm._parentLayerGroup || !(e._layerGroup._leaflet_id in t.pm._parentLayerGroup);\n                });\n                i.forEach(function (t) {\n                  e._initLayer(t);\n                }), i.length > 0 && e._getMap() && e._getMap().pm.globalEditModeEnabled() && e.enabled() && e.enable(e.getOptions());\n              }\n            }, 100, this), this), this._layerGroup.on(\"layerremove\", function (t) {\n              e._removeLayerFromGroup(t.target);\n            }, this);\n            this._layerGroup.on(\"layerremove\", L.Util.throttle(function (t) {\n              t.target._pmTempLayer || (e._layers = e.getLayers());\n            }, 100, this), this);\n          },\n          enable: function (t) {\n            var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n            0 === e.length && (this._layers = this.getLayers()), this._options = t, this._layers.forEach(function (i) {\n              i instanceof L.LayerGroup ? -1 === e.indexOf(i._leaflet_id) && (e.push(i._leaflet_id), i.pm.enable(t, e)) : i.pm.enable(t);\n            });\n          },\n          disable: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n            0 === t.length && (this._layers = this.getLayers()), this._layers.forEach(function (e) {\n              e instanceof L.LayerGroup ? -1 === t.indexOf(e._leaflet_id) && (t.push(e._leaflet_id), e.pm.disable(t)) : e.pm.disable();\n            });\n          },\n          enabled: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n            0 === t.length && (this._layers = this.getLayers());\n            var e = this._layers.find(function (e) {\n              return e instanceof L.LayerGroup ? -1 === t.indexOf(e._leaflet_id) && (t.push(e._leaflet_id), e.pm.enabled(t)) : e.pm.enabled();\n            });\n            return !!e;\n          },\n          toggleEdit: function (t) {\n            var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n            0 === e.length && (this._layers = this.getLayers()), this._options = t, this._layers.forEach(function (i) {\n              i instanceof L.LayerGroup ? -1 === e.indexOf(i._leaflet_id) && (e.push(i._leaflet_id), i.pm.toggleEdit(t, e)) : i.pm.toggleEdit(t);\n            });\n          },\n          _initLayer: function (t) {\n            var e = L.Util.stamp(this._layerGroup);\n            t.pm._parentLayerGroup || (t.pm._parentLayerGroup = {}), t.pm._parentLayerGroup[e] = this._layerGroup;\n          },\n          _removeLayerFromGroup: function (t) {\n            if (t.pm && t.pm._layerGroup) {\n              var e = L.Util.stamp(this._layerGroup);\n              delete t.pm._layerGroup[e];\n            }\n          },\n          dragging: function () {\n            if (this._layers = this.getLayers(), this._layers) {\n              var t = this._layers.find(function (t) {\n                return t.pm.dragging();\n              });\n              return !!t;\n            }\n            return !1;\n          },\n          getOptions: function () {\n            return this.options;\n          },\n          _getMap: function () {\n            var t;\n            return this._map || (null === (t = this._layers.find(function (t) {\n              return !!t._map;\n            })) || void 0 === t ? void 0 : t._map) || null;\n          },\n          getLayers: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined && arguments[0],\n              e = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1],\n              i = !(arguments.length > 2 && arguments[2] !== undefined) || arguments[2],\n              n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [],\n              r = [];\n            return t ? this._layerGroup.getLayers().forEach(function (t) {\n              r.push(t), t instanceof L.LayerGroup && -1 === n.indexOf(t._leaflet_id) && (n.push(t._leaflet_id), r = r.concat(t.pm.getLayers(!0, !0, !0, n)));\n            }) : r = this._layerGroup.getLayers(), i && (r = r.filter(function (t) {\n              return !(t instanceof L.LayerGroup);\n            })), e && (r = (r = (r = r.filter(function (t) {\n              return !!t.pm;\n            })).filter(function (t) {\n              return !t._pmTempLayer;\n            })).filter(function (t) {\n              return !L.PM.optIn && !t.options.pmIgnore || L.PM.optIn && !1 === t.options.pmIgnore;\n            })), r;\n          },\n          setOptions: function (t) {\n            var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n            0 === e.length && (this._layers = this.getLayers()), this.options = t, this._layers.forEach(function (i) {\n              i.pm && (i instanceof L.LayerGroup ? -1 === e.indexOf(i._leaflet_id) && (e.push(i._leaflet_id), i.pm.setOptions(t, e)) : i.pm.setOptions(t));\n            });\n          }\n        }), we.Marker = we.extend({\n          _shape: \"Marker\",\n          initialize: function (t) {\n            this._layer = t, this._enabled = !1, this._layer.on(\"dragend\", this._onDragEnd, this);\n          },\n          enable: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n              draggable: !0\n            };\n            L.Util.setOptions(this, t), this.options.allowEditing && this._layer._map ? (this._map = this._layer._map, this.enabled() && this.disable(), this.applyOptions(), this._layer.on(\"remove\", this.disable, this), this._enabled = !0, this._fireEnable()) : this.disable();\n          },\n          disable: function () {\n            this.enabled() && (this.disableLayerDrag(), this._layer.off(\"remove\", this.disable, this), this._layer.off(\"contextmenu\", this._removeMarker, this), this._layerEdited && this._fireUpdate(), this._layerEdited = !1, this._fireDisable(), this._enabled = !1);\n          },\n          enabled: function () {\n            return this._enabled;\n          },\n          toggleEdit: function (t) {\n            this.enabled() ? this.disable() : this.enable(t);\n          },\n          applyOptions: function () {\n            this.options.snappable ? this._initSnappableMarkers() : this._disableSnapping(), this.options.draggable ? this.enableLayerDrag() : this.disableLayerDrag(), this.options.preventMarkerRemoval || this._layer.on(\"contextmenu\", this._removeMarker, this);\n          },\n          _removeMarker: function (t) {\n            var e = t.target;\n            e.remove(), this._fireRemove(e), this._fireRemove(this._map, e);\n          },\n          _onDragEnd: function () {\n            this._fireEdit(), this._layerEdited = !0;\n          },\n          _initSnappableMarkers: function () {\n            var t = this._layer;\n            this.options.snapDistance = this.options.snapDistance || 30, this.options.snapSegment = this.options.snapSegment === undefined || this.options.snapSegment, t.off(\"pm:drag\", this._handleSnapping, this), t.on(\"pm:drag\", this._handleSnapping, this), t.off(\"pm:dragend\", this._cleanupSnapping, this), t.on(\"pm:dragend\", this._cleanupSnapping, this), t.off(\"pm:dragstart\", this._unsnap, this), t.on(\"pm:dragstart\", this._unsnap, this);\n          },\n          _disableSnapping: function () {\n            var t = this._layer;\n            t.off(\"pm:drag\", this._handleSnapping, this), t.off(\"pm:dragend\", this._cleanupSnapping, this), t.off(\"pm:dragstart\", this._unsnap, this);\n          }\n        });\n        const Ee = {\n          filterMarkerGroup: function () {\n            this.markerCache = [], this.createCache(), this._layer.on(\"pm:edit\", this.createCache, this), this.applyLimitFilters({}), this.throttledApplyLimitFilters || (this.throttledApplyLimitFilters = L.Util.throttle(this.applyLimitFilters, 100, this)), this._layer.on(\"pm:disable\", this._removeMarkerLimitEvents, this), this.options.limitMarkersToCount > -1 && (this._layer.on(\"pm:vertexremoved\", this._initMarkers, this), this._map.on(\"mousemove\", this.throttledApplyLimitFilters, this));\n          },\n          _removeMarkerLimitEvents: function () {\n            this._map.off(\"mousemove\", this.throttledApplyLimitFilters, this), this._layer.off(\"pm:edit\", this.createCache, this), this._layer.off(\"pm:disable\", this._removeMarkerLimitEvents, this), this._layer.off(\"pm:vertexremoved\", this._initMarkers, this);\n          },\n          createCache: function () {\n            var t = [].concat(Ce(this._markerGroup.getLayers()), Ce(this.markerCache));\n            this.markerCache = t.filter(function (t, e, i) {\n              return i.indexOf(t) === e;\n            });\n          },\n          renderLimits: function (t) {\n            var e = this;\n            this.markerCache.forEach(function (i) {\n              t.includes(i) ? e._markerGroup.addLayer(i) : e._markerGroup.removeLayer(i);\n            });\n          },\n          applyLimitFilters: function (t) {\n            var e = t.latlng,\n              i = void 0 === e ? {\n                lat: 0,\n                lng: 0\n              } : e;\n            if (!this._preventRenderMarkers) {\n              var n = Ce(this._filterClosestMarkers(i));\n              this.renderLimits(n);\n            }\n          },\n          _filterClosestMarkers: function (t) {\n            var e = Ce(this.markerCache),\n              i = this.options.limitMarkersToCount;\n            return -1 === i ? e : (e.sort(function (e, i) {\n              return e._latlng.distanceTo(t) - i._latlng.distanceTo(t);\n            }), e.filter(function (t, e) {\n              return !(i > -1) || e < i;\n            }));\n          },\n          _preventRenderMarkers: !1,\n          _preventRenderingMarkers: function (t) {\n            this._preventRenderMarkers = !!t;\n          }\n        };\n        function Se(t, e) {\n          return function (t) {\n            if (Array.isArray(t)) return t;\n          }(t) || function (t, e) {\n            var i = null == t ? null : \"undefined\" != typeof Symbol && t[Symbol.iterator] || t[\"@@iterator\"];\n            if (null == i) return;\n            var n,\n              r,\n              a = [],\n              o = !0,\n              s = !1;\n            try {\n              for (i = i.call(t); !(o = (n = i.next()).done) && (a.push(n.value), !e || a.length !== e); o = !0);\n            } catch (l) {\n              s = !0, r = l;\n            } finally {\n              try {\n                o || null == i[\"return\"] || i[\"return\"]();\n              } finally {\n                if (s) throw r;\n              }\n            }\n            return a;\n          }(t, e) || function (t, e) {\n            if (!t) return;\n            if (\"string\" == typeof t) return Oe(t, e);\n            var i = Object.prototype.toString.call(t).slice(8, -1);\n            \"Object\" === i && t.constructor && (i = t.constructor.name);\n            if (\"Map\" === i || \"Set\" === i) return Array.from(t);\n            if (\"Arguments\" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return Oe(t, e);\n          }(t, e) || function () {\n            throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n          }();\n        }\n        function Oe(t, e) {\n          (null == e || e > t.length) && (e = t.length);\n          for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];\n          return n;\n        }\n        function De(t) {\n          return function (t) {\n            if (Array.isArray(t)) return Be(t);\n          }(t) || function (t) {\n            if (\"undefined\" != typeof Symbol && null != t[Symbol.iterator] || null != t[\"@@iterator\"]) return Array.from(t);\n          }(t) || function (t, e) {\n            if (!t) return;\n            if (\"string\" == typeof t) return Be(t, e);\n            var i = Object.prototype.toString.call(t).slice(8, -1);\n            \"Object\" === i && t.constructor && (i = t.constructor.name);\n            if (\"Map\" === i || \"Set\" === i) return Array.from(t);\n            if (\"Arguments\" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return Be(t, e);\n          }(t) || function () {\n            throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n          }();\n        }\n        function Be(t, e) {\n          (null == e || e > t.length) && (e = t.length);\n          for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];\n          return n;\n        }\n        we.Line = we.extend({\n          includes: [Ee],\n          _shape: \"Line\",\n          initialize: function (t) {\n            this._layer = t, this._enabled = !1;\n          },\n          enable: function (t) {\n            L.Util.setOptions(this, t), this._map = this._layer._map, this._map && (this.options.allowEditing ? (this.enabled() && this.disable(), this._enabled = !0, this._initMarkers(), this.applyOptions(), this._layer.on(\"remove\", this.disable, this), this.options.allowSelfIntersection || this._layer.on(\"pm:vertexremoved\", this._handleSelfIntersectionOnVertexRemoval, this), this.options.allowSelfIntersection ? this.cachedColor = undefined : (\"#f00000ff\" !== this._layer.options.color ? (this.cachedColor = this._layer.options.color, this.isRed = !1) : this.isRed = !0, this._handleLayerStyle()), this._fireEnable()) : this.disable());\n          },\n          disable: function () {\n            if (this.enabled() && !this._dragging) {\n              this._enabled = !1, this._markerGroup.clearLayers(), this._markerGroup.removeFrom(this._map), this._layer.off(\"remove\", this.disable, this), this.options.allowSelfIntersection || this._layer.off(\"pm:vertexremoved\", this._handleSelfIntersectionOnVertexRemoval, this);\n              var t = this._layer._path ? this._layer._path : this._layer._renderer._container;\n              L.DomUtil.removeClass(t, \"leaflet-pm-draggable\"), this._map.hasLayer(this._layer) && !this.hasSelfIntersection() || L.DomUtil.removeClass(t, \"leaflet-pm-invalid\"), this._layerEdited && this._fireUpdate(), this._layerEdited = !1, this._fireDisable();\n            }\n          },\n          enabled: function () {\n            return this._enabled;\n          },\n          toggleEdit: function (t) {\n            return this.enabled() ? this.disable() : this.enable(t), this.enabled();\n          },\n          applyOptions: function () {\n            this.options.snappable ? this._initSnappableMarkers() : this._disableSnapping();\n          },\n          _initMarkers: function () {\n            var t = this,\n              e = this._map,\n              i = this._layer.getLatLngs();\n            this._markerGroup && this._markerGroup.clearLayers(), this._markerGroup = new L.FeatureGroup(), this._markerGroup._pmTempLayer = !0;\n            this._markers = function n(e) {\n              if (Array.isArray(e[0])) return e.map(n, t);\n              var i = e.map(t._createMarker, t);\n              return !0 !== t.options.hideMiddleMarkers && e.map(function (n, r) {\n                var a = t.isPolygon() ? (r + 1) % e.length : r + 1;\n                return t._createMiddleMarker(i[r], i[a]);\n              }), i;\n            }(i), this.filterMarkerGroup(), e.addLayer(this._markerGroup);\n          },\n          _createMarker: function (t) {\n            var e = new L.Marker(t, {\n              draggable: !0,\n              icon: L.divIcon({\n                className: \"marker-icon\"\n              })\n            });\n            return this._setPane(e, \"vertexPane\"), e._pmTempLayer = !0, this.options.rotate ? (e.on(\"dragstart\", this._onRotateStart, this), e.on(\"drag\", this._onRotate, this), e.on(\"dragend\", this._onRotateEnd, this)) : (e.on(\"click\", this._onVertexClick, this), e.on(\"dragstart\", this._onMarkerDragStart, this), e.on(\"move\", this._onMarkerDrag, this), e.on(\"dragend\", this._onMarkerDragEnd, this), this.options.preventMarkerRemoval || e.on(this.options.removeVertexOn, this._removeMarker, this)), this._markerGroup.addLayer(e), e;\n          },\n          _createMiddleMarker: function (t, e) {\n            if (!t || !e) return !1;\n            var i = L.PM.Utils.calcMiddleLatLng(this._map, t.getLatLng(), e.getLatLng()),\n              n = this._createMarker(i),\n              r = L.divIcon({\n                className: \"marker-icon marker-icon-middle\"\n              });\n            return n.setIcon(r), n.leftM = t, n.rightM = e, t._middleMarkerNext = n, e._middleMarkerPrev = n, n.on(this.options.addVertexOn, this._onMiddleMarkerClick, this), n.on(\"movestart\", this._onMiddleMarkerMoveStart, this), n;\n          },\n          _onMiddleMarkerClick: function (t) {\n            var e = t.target;\n            if (this._vertexValidation(\"add\", t)) {\n              var i = L.divIcon({\n                className: \"marker-icon\"\n              });\n              e.setIcon(i), this._addMarker(e, e.leftM, e.rightM);\n            }\n          },\n          _onMiddleMarkerMoveStart: function (t) {\n            var e = t.target;\n            e.on(\"moveend\", this._onMiddleMarkerMoveEnd, this), this._vertexValidation(\"add\", t) ? (e._dragging = !0, this._addMarker(e, e.leftM, e.rightM)) : e.on(\"move\", this._onMiddleMarkerMovePrevent, this);\n          },\n          _onMiddleMarkerMovePrevent: function (t) {\n            var e = t.target;\n            this._vertexValidationDrag(e);\n          },\n          _onMiddleMarkerMoveEnd: function (t) {\n            var e = t.target;\n            if (e.off(\"move\", this._onMiddleMarkerMovePrevent, this), e.off(\"moveend\", this._onMiddleMarkerMoveEnd, this), this._vertexValidationDragEnd(e)) {\n              var i = L.divIcon({\n                className: \"marker-icon\"\n              });\n              e.setIcon(i), setTimeout(function () {\n                delete e._dragging;\n              }, 100);\n            }\n          },\n          _addMarker: function (t, e, i) {\n            t.off(\"movestart\", this._onMiddleMarkerMoveStart, this), t.off(this.options.addVertexOn, this._onMiddleMarkerClick, this);\n            var n = t.getLatLng(),\n              r = this._layer._latlngs;\n            delete t.leftM, delete t.rightM;\n            var a = L.PM.Utils.findDeepMarkerIndex(this._markers, e),\n              o = a.indexPath,\n              s = a.index,\n              l = a.parentPath,\n              h = o.length > 1 ? B()(r, l) : r,\n              u = o.length > 1 ? B()(this._markers, l) : this._markers;\n            h.splice(s + 1, 0, n), u.splice(s + 1, 0, t), this._layer.setLatLngs(r), !0 !== this.options.hideMiddleMarkers && (this._createMiddleMarker(e, t), this._createMiddleMarker(t, i)), this._fireEdit(), this._layerEdited = !0, this._fireChange(this._layer.getLatLngs(), \"Edit\"), this._fireVertexAdded(t, L.PM.Utils.findDeepMarkerIndex(this._markers, t).indexPath, n), this.options.snappable && this._initSnappableMarkers();\n          },\n          hasSelfIntersection: function () {\n            return gt(this._layer.toGeoJSON(15)).features.length > 0;\n          },\n          _handleSelfIntersectionOnVertexRemoval: function () {\n            this._handleLayerStyle(!0), this.hasSelfIntersection() && (this._layer.setLatLngs(this._coordsBeforeEdit), this._coordsBeforeEdit = null, this._initMarkers());\n          },\n          _handleLayerStyle: function (t) {\n            var e = this._layer;\n            if (this.hasSelfIntersection()) {\n              if (!this.options.allowSelfIntersection && this.options.allowSelfIntersectionEdit && this._updateDisabledMarkerStyle(this._markers, !0), this.isRed) return;\n              t ? this._flashLayer() : (e.setStyle({\n                color: \"#f00000ff\"\n              }), this.isRed = !0), this._fireIntersect(gt(this._layer.toGeoJSON(15)));\n            } else e.setStyle({\n              color: this.cachedColor\n            }), this.isRed = !1, !this.options.allowSelfIntersection && this.options.allowSelfIntersectionEdit && this._updateDisabledMarkerStyle(this._markers, !1);\n          },\n          _flashLayer: function () {\n            var t = this;\n            this.cachedColor || (this.cachedColor = this._layer.options.color), this._layer.setStyle({\n              color: \"#f00000ff\"\n            }), this.isRed = !0, window.setTimeout(function () {\n              t._layer.setStyle({\n                color: t.cachedColor\n              }), t.isRed = !1;\n            }, 200);\n          },\n          _updateDisabledMarkerStyle: function (t, e) {\n            var i = this;\n            t.forEach(function (t) {\n              Array.isArray(t) ? i._updateDisabledMarkerStyle(t, e) : t._icon && (e && !i._checkMarkerAllowedToDrag(t) ? L.DomUtil.addClass(t._icon, \"vertexmarker-disabled\") : L.DomUtil.removeClass(t._icon, \"vertexmarker-disabled\"));\n            });\n          },\n          _removeMarker: function (t) {\n            var e = t.target;\n            if (this._vertexValidation(\"remove\", t)) {\n              this.options.allowSelfIntersection || (this._coordsBeforeEdit = U(this._layer, this._layer.getLatLngs()));\n              var i = this._layer.getLatLngs(),\n                n = L.PM.Utils.findDeepMarkerIndex(this._markers, e),\n                r = n.indexPath,\n                a = n.index,\n                o = n.parentPath;\n              if (r) {\n                var s = r.length > 1 ? B()(i, o) : i,\n                  l = r.length > 1 ? B()(this._markers, o) : this._markers;\n                if (this.options.removeLayerBelowMinVertexCount || !(s.length <= 2 || this.isPolygon() && s.length <= 3)) {\n                  s.splice(a, 1), this._layer.setLatLngs(i), this.isPolygon() && s.length <= 2 && s.splice(0, s.length);\n                  var h = !1;\n                  if (s.length <= 1 && (s.splice(0, s.length), o.length > 1 && r.length > 1 && (i = A(i)), this._layer.setLatLngs(i), this._initMarkers(), h = !0), j(i) || this._layer.remove(), i = A(i), this._layer.setLatLngs(i), this._markers = A(this._markers), !h && (l = r.length > 1 ? B()(this._markers, o) : this._markers, e._middleMarkerPrev && this._markerGroup.removeLayer(e._middleMarkerPrev), e._middleMarkerNext && this._markerGroup.removeLayer(e._middleMarkerNext), this._markerGroup.removeLayer(e), l)) {\n                    var u, c;\n                    if (this.isPolygon() ? (u = (a + 1) % l.length, c = (a + (l.length - 1)) % l.length) : (c = a - 1 < 0 ? undefined : a - 1, u = a + 1 >= l.length ? undefined : a + 1), u !== c) {\n                      var p = l[c],\n                        d = l[u];\n                      !0 !== this.options.hideMiddleMarkers && this._createMiddleMarker(p, d);\n                    }\n                    l.splice(a, 1);\n                  }\n                  this._fireEdit(), this._layerEdited = !0, this._fireVertexRemoved(e, r), this._fireChange(this._layer.getLatLngs(), \"Edit\");\n                } else this._flashLayer();\n              }\n            }\n          },\n          updatePolygonCoordsFromMarkerDrag: function (t) {\n            var e = this._layer.getLatLngs(),\n              i = t.getLatLng(),\n              n = L.PM.Utils.findDeepMarkerIndex(this._markers, t),\n              r = n.indexPath,\n              a = n.index,\n              o = n.parentPath;\n            (r.length > 1 ? B()(e, o) : e).splice(a, 1, i), this._layer.setLatLngs(e);\n          },\n          _getNeighborMarkers: function (t) {\n            var e = L.PM.Utils.findDeepMarkerIndex(this._markers, t),\n              i = e.indexPath,\n              n = e.index,\n              r = e.parentPath,\n              a = i.length > 1 ? B()(this._markers, r) : this._markers,\n              o = (n + 1) % a.length;\n            return {\n              prevMarker: a[(n + (a.length - 1)) % a.length],\n              nextMarker: a[o]\n            };\n          },\n          _checkMarkerAllowedToDrag: function (t) {\n            var e = this._getNeighborMarkers(t),\n              i = e.prevMarker,\n              n = e.nextMarker,\n              r = L.polyline([i.getLatLng(), t.getLatLng()]),\n              a = L.polyline([t.getLatLng(), n.getLatLng()]),\n              o = At(this._layer.toGeoJSON(15), r.toGeoJSON(15)).features.length,\n              s = At(this._layer.toGeoJSON(15), a.toGeoJSON(15)).features.length;\n            return t.getLatLng() === this._markers[0][0].getLatLng() ? s += 1 : t.getLatLng() === this._markers[0][this._markers[0].length - 1].getLatLng() && (o += 1), !(o <= 2 && s <= 2);\n          },\n          _onMarkerDragStart: function (t) {\n            var e = t.target;\n            if (this.cachedColor || (this.cachedColor = this._layer.options.color), this._vertexValidation(\"move\", t)) {\n              var i = L.PM.Utils.findDeepMarkerIndex(this._markers, e).indexPath;\n              this._fireMarkerDragStart(t, i), this.options.allowSelfIntersection || (this._coordsBeforeEdit = U(this._layer, this._layer.getLatLngs())), !this.options.allowSelfIntersection && this.options.allowSelfIntersectionEdit && this.hasSelfIntersection() ? this._markerAllowedToDrag = this._checkMarkerAllowedToDrag(e) : this._markerAllowedToDrag = null;\n            }\n          },\n          _onMarkerDrag: function (t) {\n            var e = t.target;\n            if (this._vertexValidationDrag(e)) {\n              var i = L.PM.Utils.findDeepMarkerIndex(this._markers, e),\n                n = i.indexPath,\n                r = i.index,\n                a = i.parentPath;\n              if (n) {\n                if (!this.options.allowSelfIntersection && this.options.allowSelfIntersectionEdit && this.hasSelfIntersection() && !1 === this._markerAllowedToDrag) return this._layer.setLatLngs(this._coordsBeforeEdit), this._initMarkers(), void this._handleLayerStyle();\n                this.updatePolygonCoordsFromMarkerDrag(e);\n                var o = n.length > 1 ? B()(this._markers, a) : this._markers,\n                  s = (r + 1) % o.length,\n                  l = (r + (o.length - 1)) % o.length,\n                  h = e.getLatLng(),\n                  u = o[l].getLatLng(),\n                  c = o[s].getLatLng();\n                if (e._middleMarkerNext) {\n                  var p = L.PM.Utils.calcMiddleLatLng(this._map, h, c);\n                  e._middleMarkerNext.setLatLng(p);\n                }\n                if (e._middleMarkerPrev) {\n                  var d = L.PM.Utils.calcMiddleLatLng(this._map, h, u);\n                  e._middleMarkerPrev.setLatLng(d);\n                }\n                this.options.allowSelfIntersection || this._handleLayerStyle(), this._fireMarkerDrag(t, n), this._fireChange(this._layer.getLatLngs(), \"Edit\");\n              }\n            }\n          },\n          _onMarkerDragEnd: function (t) {\n            var e = t.target;\n            if (this._vertexValidationDragEnd(e)) {\n              var i = L.PM.Utils.findDeepMarkerIndex(this._markers, e).indexPath,\n                n = this.hasSelfIntersection();\n              n && this.options.allowSelfIntersectionEdit && this._markerAllowedToDrag && (n = !1);\n              var r = !this.options.allowSelfIntersection && n;\n              if (this._fireMarkerDragEnd(t, i, r), r) return this._layer.setLatLngs(this._coordsBeforeEdit), this._coordsBeforeEdit = null, this._initMarkers(), this.options.snappable && this._initSnappableMarkers(), this._handleLayerStyle(), void this._fireLayerReset(t, i);\n              !this.options.allowSelfIntersection && this.options.allowSelfIntersectionEdit && this._handleLayerStyle(), this._fireEdit(), this._layerEdited = !0, this._fireChange(this._layer.getLatLngs(), \"Edit\");\n            }\n          },\n          _onVertexClick: function (t) {\n            var e = t.target;\n            if (!e._dragging) {\n              var i = L.PM.Utils.findDeepMarkerIndex(this._markers, e).indexPath;\n              this._fireVertexClick(t, i);\n            }\n          }\n        }), we.Polygon = we.Line.extend({\n          _shape: \"Polygon\",\n          _checkMarkerAllowedToDrag: function (t) {\n            var e = this._getNeighborMarkers(t),\n              i = e.prevMarker,\n              n = e.nextMarker,\n              r = L.polyline([i.getLatLng(), t.getLatLng()]),\n              a = L.polyline([t.getLatLng(), n.getLatLng()]),\n              o = At(this._layer.toGeoJSON(15), r.toGeoJSON(15)).features.length,\n              s = At(this._layer.toGeoJSON(15), a.toGeoJSON(15)).features.length;\n            return !(o <= 2 && s <= 2);\n          }\n        }), we.Rectangle = we.Polygon.extend({\n          _shape: \"Rectangle\",\n          _initMarkers: function () {\n            var t = this,\n              e = this._map,\n              i = this._findCorners();\n            this._markerGroup && this._markerGroup.clearLayers(), this._markerGroup = new L.FeatureGroup(), this._markerGroup._pmTempLayer = !0, e.addLayer(this._markerGroup), this._markers = [], this._markers[0] = i.map(this._createMarker, this);\n            var n = Se(this._markers, 1);\n            this._cornerMarkers = n[0], this._layer.getLatLngs()[0].forEach(function (e, i) {\n              var n = t._cornerMarkers.find(function (t) {\n                return t._index === i;\n              });\n              n && n.setLatLng(e);\n            });\n          },\n          applyOptions: function () {\n            this.options.snappable ? this._initSnappableMarkers() : this._disableSnapping(), this._addMarkerEvents();\n          },\n          _createMarker: function (t, e) {\n            var i = new L.Marker(t, {\n              draggable: !0,\n              icon: L.divIcon({\n                className: \"marker-icon\"\n              })\n            });\n            return this._setPane(i, \"vertexPane\"), i._origLatLng = t, i._index = e, i._pmTempLayer = !0, this._markerGroup.addLayer(i), i;\n          },\n          _addMarkerEvents: function () {\n            var t = this;\n            this._markers[0].forEach(function (e) {\n              e.on(\"dragstart\", t._onMarkerDragStart, t), e.on(\"drag\", t._onMarkerDrag, t), e.on(\"dragend\", t._onMarkerDragEnd, t), t.options.preventMarkerRemoval || e.on(\"contextmenu\", t._removeMarker, t);\n            });\n          },\n          _removeMarker: function () {\n            return null;\n          },\n          _onMarkerDragStart: function (t) {\n            if (this._vertexValidation(\"move\", t)) {\n              var e = t.target,\n                i = this._cornerMarkers;\n              e._oppositeCornerLatLng = i.find(function (t) {\n                return t._index === (e._index + 2) % 4;\n              }).getLatLng(), e._snapped = !1, this._fireMarkerDragStart(t);\n            }\n          },\n          _onMarkerDrag: function (t) {\n            var e = t.target;\n            this._vertexValidationDrag(e) && e._index !== undefined && (this._adjustRectangleForMarkerMove(e), this._fireMarkerDrag(t), this._fireChange(this._layer.getLatLngs(), \"Edit\"));\n          },\n          _onMarkerDragEnd: function (t) {\n            var e = t.target;\n            this._vertexValidationDragEnd(e) && (this._cornerMarkers.forEach(function (t) {\n              delete t._oppositeCornerLatLng;\n            }), this._fireMarkerDragEnd(t), this._fireEdit(), this._layerEdited = !0, this._fireChange(this._layer.getLatLngs(), \"Edit\"));\n          },\n          _adjustRectangleForMarkerMove: function (t) {\n            L.extend(t._origLatLng, t._latlng);\n            var e = L.PM.Utils._getRotatedRectangle(t.getLatLng(), t._oppositeCornerLatLng, this._angle || 0, this._map);\n            this._layer.setLatLngs(e), this._adjustAllMarkers(), this._layer.redraw();\n          },\n          _adjustAllMarkers: function () {\n            var t = this,\n              e = this._layer.getLatLngs()[0];\n            e && 4 !== e.length && e.length > 0 ? (e.forEach(function (e, i) {\n              t._cornerMarkers[i].setLatLng(e);\n            }), this._cornerMarkers.slice(e.length).forEach(function (t) {\n              t.setLatLng(e[0]);\n            })) : e && e.length ? this._cornerMarkers.forEach(function (t) {\n              t.setLatLng(e[t._index]);\n            }) : console.error(\"The layer has no LatLngs\");\n          },\n          _findCorners: function () {\n            var t = this._layer.getLatLngs()[0];\n            return L.PM.Utils._getRotatedRectangle(t[0], t[2], this._angle || 0, this._map);\n          }\n        }), we.Circle = we.extend({\n          _shape: \"Circle\",\n          initialize: function (t) {\n            this._layer = t, this._enabled = !1, this._updateHiddenPolyCircle();\n          },\n          enable: function (t) {\n            L.Util.setOptions(this, t), this._map = this._layer._map, this.options.allowEditing ? (this.enabled() || this.disable(), this._enabled = !0, this._initMarkers(), this.applyOptions(), this._layer.on(\"remove\", this.disable, this), this._updateHiddenPolyCircle(), this._fireEnable()) : this.disable();\n          },\n          disable: function () {\n            if (this.enabled() && !this._dragging) {\n              this._centerMarker.off(\"dragstart\", this._onCircleDragStart, this), this._centerMarker.off(\"drag\", this._onCircleDrag, this), this._centerMarker.off(\"dragend\", this._onCircleDragEnd, this), this._outerMarker.off(\"drag\", this._handleOuterMarkerSnapping, this), this._layer.off(\"remove\", this.disable, this), this._enabled = !1, this._helperLayers.clearLayers();\n              var t = this._layer._path ? this._layer._path : this._layer._renderer._container;\n              L.DomUtil.removeClass(t, \"leaflet-pm-draggable\"), this._layerEdited && this._fireUpdate(), this._layerEdited = !1, this._fireDisable();\n            }\n          },\n          enabled: function () {\n            return this._enabled;\n          },\n          toggleEdit: function (t) {\n            this.enabled() ? this.disable() : this.enable(t);\n          },\n          _initMarkers: function () {\n            var t = this._map;\n            this._helperLayers && this._helperLayers.clearLayers(), this._helperLayers = new L.FeatureGroup(), this._helperLayers._pmTempLayer = !0, this._helperLayers.addTo(t);\n            var e = this._layer.getLatLng(),\n              i = this._layer._radius,\n              n = this._getLatLngOnCircle(e, i);\n            this._centerMarker = this._createCenterMarker(e), this._outerMarker = this._createOuterMarker(n), this._markers = [this._centerMarker, this._outerMarker], this._createHintLine(this._centerMarker, this._outerMarker);\n          },\n          applyOptions: function () {\n            this.options.snappable ? (this._initSnappableMarkers(), this._outerMarker.on(\"drag\", this._handleOuterMarkerSnapping, this), this._outerMarker.on(\"move\", this._syncHintLine, this), this._outerMarker.on(\"move\", this._syncCircleRadius, this), this._centerMarker.on(\"move\", this._moveCircle, this)) : this._disableSnapping();\n          },\n          _createHintLine: function (t, e) {\n            var i = t.getLatLng(),\n              n = e.getLatLng();\n            this._hintline = L.polyline([i, n], this.options.hintlineStyle), this._setPane(this._hintline, \"layerPane\"), this._hintline._pmTempLayer = !0, this._helperLayers.addLayer(this._hintline);\n          },\n          _createCenterMarker: function (t) {\n            var e = this._createMarker(t);\n            return L.DomUtil.addClass(e._icon, \"leaflet-pm-draggable\"), e.on(\"drag\", this._moveCircle, this), e.on(\"dragstart\", this._onCircleDragStart, this), e.on(\"drag\", this._onCircleDrag, this), e.on(\"dragend\", this._onCircleDragEnd, this), e;\n          },\n          _createOuterMarker: function (t) {\n            var e = this._createMarker(t);\n            return e.on(\"drag\", this._resizeCircle, this), e;\n          },\n          _createMarker: function (t) {\n            var e = new L.Marker(t, {\n              draggable: !0,\n              icon: L.divIcon({\n                className: \"marker-icon\"\n              })\n            });\n            return this._setPane(e, \"vertexPane\"), e._origLatLng = t, e._pmTempLayer = !0, e.on(\"dragstart\", this._onMarkerDragStart, this), e.on(\"drag\", this._onMarkerDrag, this), e.on(\"dragend\", this._onMarkerDragEnd, this), this._helperLayers.addLayer(e), e;\n          },\n          _resizeCircle: function () {\n            this._outerMarker.setLatLng(this._getNewDestinationOfOuterMarker()), this._syncHintLine(), this._syncCircleRadius();\n          },\n          _moveCircle: function (t) {\n            if (!t.target._cancelDragEventChain) {\n              var e = t.latlng;\n              this._layer.setLatLng(e);\n              var i = this._layer._radius,\n                n = this._getLatLngOnCircle(e, i);\n              this._outerMarker._latlng = n, this._outerMarker.update(), this._syncHintLine(), this._updateHiddenPolyCircle(), this._fireCenterPlaced(\"Edit\"), this._fireChange(this._layer.getLatLng(), \"Edit\");\n            }\n          },\n          _syncCircleRadius: function () {\n            var t = this._centerMarker.getLatLng(),\n              e = this._outerMarker.getLatLng(),\n              i = this._map.distance(t, e);\n            this.options.minRadiusCircle && i < this.options.minRadiusCircle ? this._layer.setRadius(this.options.minRadiusCircle) : this.options.maxRadiusCircle && i > this.options.maxRadiusCircle ? this._layer.setRadius(this.options.maxRadiusCircle) : this._layer.setRadius(i), this._updateHiddenPolyCircle(), this._fireChange(this._layer.getLatLng(), \"Edit\");\n          },\n          _syncHintLine: function () {\n            var t = this._centerMarker.getLatLng(),\n              e = this._outerMarker.getLatLng();\n            this._hintline.setLatLngs([t, e]);\n          },\n          _disableSnapping: function () {\n            var t = this;\n            this._markers.forEach(function (e) {\n              e.off(\"move\", t._syncHintLine, t), e.off(\"move\", t._syncCircleRadius, t), e.off(\"drag\", t._handleSnapping, t), e.off(\"dragend\", t._cleanupSnapping, t);\n            }), this._layer.off(\"pm:dragstart\", this._unsnap, this);\n          },\n          _onMarkerDragStart: function (t) {\n            this._vertexValidation(\"move\", t) && this._fireMarkerDragStart(t);\n          },\n          _onMarkerDrag: function (t) {\n            var e = t.target;\n            this._vertexValidationDrag(e) && this._fireMarkerDrag(t);\n          },\n          _onMarkerDragEnd: function (t) {\n            var e = t.target;\n            this._vertexValidationDragEnd(e) && (this._fireEdit(), this._layerEdited = !0, this._fireMarkerDragEnd(t));\n          },\n          _onCircleDragStart: function (t) {\n            this._vertexValidationDrag(t.target) ? (delete this._vertexValidationReset, this._fireDragStart()) : this._vertexValidationReset = !0;\n          },\n          _onCircleDrag: function (t) {\n            this._vertexValidationReset || this._fireDrag(t);\n          },\n          _onCircleDragEnd: function () {\n            this._vertexValidationReset ? delete this._vertexValidationReset : this._fireDragEnd();\n          },\n          _updateHiddenPolyCircle: function () {\n            var t = this._map && this._map.pm._isCRSSimple();\n            this._hiddenPolyCircle ? this._hiddenPolyCircle.setLatLngs(L.PM.Utils.circleToPolygon(this._layer, 200, !t).getLatLngs()) : this._hiddenPolyCircle = L.PM.Utils.circleToPolygon(this._layer, 200, !t), this._hiddenPolyCircle._parentCopy || (this._hiddenPolyCircle._parentCopy = this._layer);\n          },\n          _getLatLngOnCircle: function (t, e) {\n            var i = this._map.project(t),\n              n = L.point(i.x + e, i.y);\n            return this._map.unproject(n);\n          },\n          _getNewDestinationOfOuterMarker: function () {\n            var t = this._centerMarker.getLatLng(),\n              e = this._outerMarker.getLatLng(),\n              i = this._map.distance(t, e);\n            return this.options.minRadiusCircle && i < this.options.minRadiusCircle ? e = z(this._map, t, e, this.options.minRadiusCircle) : this.options.maxRadiusCircle && i > this.options.maxRadiusCircle && (e = z(this._map, t, e, this.options.maxRadiusCircle)), e;\n          },\n          _handleOuterMarkerSnapping: function () {\n            if (this._outerMarker._snapped) {\n              var t = this._centerMarker.getLatLng(),\n                e = this._outerMarker.getLatLng(),\n                i = this._map.distance(t, e);\n              (this.options.minRadiusCircle && i < this.options.minRadiusCircle || this.options.maxRadiusCircle && i > this.options.maxRadiusCircle) && this._outerMarker.setLatLng(this._outerMarker._orgLatLng);\n            }\n            this._outerMarker.setLatLng(this._getNewDestinationOfOuterMarker());\n          }\n        }), we.CircleMarker = we.extend({\n          _shape: \"CircleMarker\",\n          initialize: function (t) {\n            this._layer = t, this._enabled = !1, this._updateHiddenPolyCircle();\n          },\n          enable: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n              draggable: !0,\n              snappable: !0\n            };\n            L.Util.setOptions(this, t), this.options.allowEditing && this._layer._map ? (this._map = this._layer._map, this.enabled() && this.disable(), this.applyOptions(), this._layer.on(\"remove\", this.disable, this), this._enabled = !0, this._layer.on(\"pm:dragstart\", this._onDragStart, this), this._layer.on(\"pm:drag\", this._onMarkerDrag, this), this._layer.on(\"pm:dragend\", this._onMarkerDragEnd, this), this._updateHiddenPolyCircle(), this._fireEnable()) : this.disable();\n          },\n          disable: function () {\n            this._dragging || (this._helperLayers && this._helperLayers.clearLayers(), this._map || (this._map = this._layer._map), this._map || (this.options.editable ? (this._map.off(\"move\", this._syncMarkers, this), this._outerMarker && this._outerMarker.on(\"drag\", this._handleOuterMarkerSnapping, this)) : this._map.off(\"move\", this._updateHiddenPolyCircle, this)), this.disableLayerDrag(), this._layer.off(\"contextmenu\", this._removeMarker, this), this._layer.off(\"remove\", this.disable, this), this.enabled() && (this._layerEdited && this._fireUpdate(), this._layerEdited = !1, this._fireDisable()), this._enabled = !1);\n          },\n          enabled: function () {\n            return this._enabled;\n          },\n          toggleEdit: function (t) {\n            this.enabled() ? this.disable() : this.enable(t);\n          },\n          applyOptions: function () {\n            !this.options.editable && this.options.draggable ? this.enableLayerDrag() : this.disableLayerDrag(), this.options.editable ? (this._initMarkers(), this._map.on(\"move\", this._syncMarkers, this)) : this._map.on(\"move\", this._updateHiddenPolyCircle, this), this.options.snappable ? this.options.editable ? (this._initSnappableMarkers(), this._centerMarker.on(\"drag\", this._moveCircle, this), this.options.editable && this._outerMarker.on(\"drag\", this._handleOuterMarkerSnapping, this), this._outerMarker.on(\"move\", this._syncHintLine, this), this._outerMarker.on(\"move\", this._syncCircleRadius, this)) : this._initSnappableMarkersDrag() : this.options.editable ? this._disableSnapping() : this._disableSnappingDrag(), this.options.preventMarkerRemoval || this._layer.on(\"contextmenu\", this._removeMarker, this);\n          },\n          _initMarkers: function () {\n            var t = this._map;\n            this._helperLayers && this._helperLayers.clearLayers(), this._helperLayers = new L.FeatureGroup(), this._helperLayers._pmTempLayer = !0, this._helperLayers.addTo(t);\n            var e = this._layer.getLatLng(),\n              i = this._layer._radius,\n              n = this._getLatLngOnCircle(e, i);\n            this._centerMarker = this._createCenterMarker(e), this._outerMarker = this._createOuterMarker(n), this._markers = [this._centerMarker, this._outerMarker], this._createHintLine(this._centerMarker, this._outerMarker);\n          },\n          _getLatLngOnCircle: function (t, e) {\n            var i = this._map.project(t),\n              n = L.point(i.x + e, i.y);\n            return this._map.unproject(n);\n          },\n          _createHintLine: function (t, e) {\n            var i = t.getLatLng(),\n              n = e.getLatLng();\n            this._hintline = L.polyline([i, n], this.options.hintlineStyle), this._setPane(this._hintline, \"layerPane\"), this._hintline._pmTempLayer = !0, this._helperLayers.addLayer(this._hintline);\n          },\n          _createCenterMarker: function (t) {\n            var e = this._createMarker(t);\n            return this.options.draggable ? L.DomUtil.addClass(e._icon, \"leaflet-pm-draggable\") : e.dragging.disable(), e;\n          },\n          _createOuterMarker: function (t) {\n            var e = this._createMarker(t);\n            return e.on(\"drag\", this._resizeCircle, this), e;\n          },\n          _createMarker: function (t) {\n            var e = new L.Marker(t, {\n              draggable: !0,\n              icon: L.divIcon({\n                className: \"marker-icon\"\n              })\n            });\n            return this._setPane(e, \"vertexPane\"), e._origLatLng = t, e._pmTempLayer = !0, e.on(\"dragstart\", this._onMarkerDragStart, this), e.on(\"drag\", this._onMarkerDrag, this), e.on(\"dragend\", this._onMarkerDragEnd, this), this._helperLayers.addLayer(e), e;\n          },\n          _moveCircle: function () {\n            var t = this._centerMarker.getLatLng();\n            this._layer.setLatLng(t);\n            var e = this._layer._radius,\n              i = this._getLatLngOnCircle(t, e);\n            this._outerMarker._latlng = i, this._outerMarker.update(), this._syncHintLine(), this._updateHiddenPolyCircle(), this._fireCenterPlaced(\"Edit\"), this._fireChange(this._layer.getLatLng(), \"Edit\");\n          },\n          _syncMarkers: function () {\n            var t = this._layer.getLatLng(),\n              e = this._layer._radius,\n              i = this._getLatLngOnCircle(t, e);\n            this._outerMarker.setLatLng(i), this._centerMarker.setLatLng(t), this._syncHintLine(), this._updateHiddenPolyCircle();\n          },\n          _resizeCircle: function () {\n            this._outerMarker.setLatLng(this._getNewDestinationOfOuterMarker()), this._syncHintLine(), this._syncCircleRadius();\n          },\n          _syncCircleRadius: function () {\n            var t = this._centerMarker.getLatLng(),\n              e = this._outerMarker.getLatLng(),\n              i = this._map.project(t).distanceTo(this._map.project(e));\n            this.options.minRadiusCircleMarker && i < this.options.minRadiusCircleMarker ? this._layer.setRadius(this.options.minRadiusCircleMarker) : this.options.maxRadiusCircleMarker && i > this.options.maxRadiusCircleMarker ? this._layer.setRadius(this.options.maxRadiusCircleMarker) : this._layer.setRadius(i), this._updateHiddenPolyCircle(), this._fireChange(this._layer.getLatLng(), \"Edit\");\n          },\n          _syncHintLine: function () {\n            var t = this._centerMarker.getLatLng(),\n              e = this._outerMarker.getLatLng();\n            this._hintline.setLatLngs([t, e]);\n          },\n          _removeMarker: function () {\n            this.options.editable && this.disable(), this._layer.remove(), this._fireRemove(this._layer), this._fireRemove(this._map, this._layer);\n          },\n          _onDragStart: function () {\n            this._map.pm.Draw.CircleMarker._layerIsDragging = !0;\n          },\n          _onMarkerDragStart: function (t) {\n            this._vertexValidation(\"move\", t) && this._fireMarkerDragStart(t);\n          },\n          _onMarkerDrag: function (t) {\n            var e = t.target;\n            e instanceof L.Marker && !this._vertexValidationDrag(e) || this._fireMarkerDrag(t);\n          },\n          _onMarkerDragEnd: function (t) {\n            this._map.pm.Draw.CircleMarker._layerIsDragging = !1;\n            var e = t.target;\n            this._vertexValidationDragEnd(e) && (this.options.editable && (this._fireEdit(), this._layerEdited = !0), this._fireMarkerDragEnd(t));\n          },\n          _initSnappableMarkersDrag: function () {\n            var t = this._layer;\n            this.options.snapDistance = this.options.snapDistance || 30, this.options.snapSegment = this.options.snapSegment === undefined || this.options.snapSegment, t.off(\"pm:drag\", this._handleSnapping, this), t.on(\"pm:drag\", this._handleSnapping, this), t.off(\"pm:dragend\", this._cleanupSnapping, this), t.on(\"pm:dragend\", this._cleanupSnapping, this), t.off(\"pm:dragstart\", this._unsnap, this), t.on(\"pm:dragstart\", this._unsnap, this);\n          },\n          _disableSnappingDrag: function () {\n            var t = this._layer;\n            t.off(\"pm:drag\", this._handleSnapping, this), t.off(\"pm:dragend\", this._cleanupSnapping, this), t.off(\"pm:dragstart\", this._unsnap, this);\n          },\n          _updateHiddenPolyCircle: function () {\n            var t = this._layer._map || this._map;\n            if (t) {\n              var e = L.PM.Utils.pxRadiusToMeterRadius(this._layer.getRadius(), t, this._layer.getLatLng()),\n                i = L.circle(this._layer.getLatLng(), this._layer.options);\n              i.setRadius(e);\n              var n = t && t.pm._isCRSSimple();\n              this._hiddenPolyCircle ? this._hiddenPolyCircle.setLatLngs(L.PM.Utils.circleToPolygon(i, 200, !n).getLatLngs()) : this._hiddenPolyCircle = L.PM.Utils.circleToPolygon(i, 200, !n), this._hiddenPolyCircle._parentCopy || (this._hiddenPolyCircle._parentCopy = this._layer);\n            }\n          },\n          _getNewDestinationOfOuterMarker: function () {\n            var t = this._centerMarker.getLatLng(),\n              e = this._outerMarker.getLatLng(),\n              i = this._map.project(t).distanceTo(this._map.project(e));\n            return this.options.minRadiusCircleMarker && i < this.options.minRadiusCircleMarker ? e = z(this._map, t, e, L.PM.Utils.pxRadiusToMeterRadius(this.options.minRadiusCircleMarker, this._map, t)) : this.options.maxRadiusCircleMarker && i > this.options.maxRadiusCircleMarker && (e = z(this._map, t, e, L.PM.Utils.pxRadiusToMeterRadius(this.options.maxRadiusCircleMarker, this._map, t))), e;\n          },\n          _handleOuterMarkerSnapping: function () {\n            if (this._outerMarker._snapped) {\n              var t = this._centerMarker.getLatLng(),\n                e = this._outerMarker.getLatLng(),\n                i = this._map.project(t).distanceTo(this._map.project(e));\n              (this.options.minRadiusCircleMarker && i < this.options.minRadiusCircleMarker || this.options.maxRadiusCircleMarker && i > this.options.maxRadiusCircleMarker) && this._outerMarker.setLatLng(this._outerMarker._orgLatLng);\n            }\n            this._outerMarker.setLatLng(this._getNewDestinationOfOuterMarker());\n          }\n        }), we.ImageOverlay = we.extend({\n          _shape: \"ImageOverlay\",\n          initialize: function (t) {\n            this._layer = t, this._enabled = !1;\n          },\n          toggleEdit: function (t) {\n            this.enabled() ? this.disable() : this.enable(t);\n          },\n          enabled: function () {\n            return this._enabled;\n          },\n          enable: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n              draggable: !0,\n              snappable: !0\n            };\n            L.Util.setOptions(this, t), this._map = this._layer._map, this._map && (this.options.allowEditing ? (this.enabled() || this.disable(), this.enableLayerDrag(), this._layer.on(\"remove\", this.disable, this), this._enabled = !0, this._otherSnapLayers = this._findCorners(), this._fireEnable()) : this.disable());\n          },\n          disable: function () {\n            this._dragging || (this._map || (this._map = this._layer._map), this.disableLayerDrag(), this._layer.off(\"remove\", this.disable, this), this.enabled() || (this._layerEdited && this._fireUpdate(), this._layerEdited = !1, this._fireDisable()), this._enabled = !1);\n          },\n          _findCorners: function () {\n            var t = this._layer.getBounds();\n            return [t.getNorthWest(), t.getNorthEast(), t.getSouthEast(), t.getSouthWest()];\n          }\n        }), we.Text = we.extend({\n          _shape: \"Text\",\n          initialize: function (t) {\n            this._layer = t, this._enabled = !1;\n          },\n          enable: function (t) {\n            L.Util.setOptions(this, t), this.textArea && (this.options.allowEditing && this._layer._map ? (this._map = this._layer._map, this.enabled() && this.disable(), this.applyOptions(), this._safeToCacheDragState = !0, this._focusChange(), this.textArea.readOnly = !1, this.textArea.classList.remove(\"pm-disabled\"), this._layer.on(\"remove\", this.disable, this), L.DomEvent.on(this.textArea, \"input\", this._autoResize, this), L.DomEvent.on(this.textArea, \"focus\", this._focusChange, this), L.DomEvent.on(this.textArea, \"blur\", this._focusChange, this), this._layer.on(\"dblclick\", L.DomEvent.stop), L.DomEvent.off(this.textArea, \"mousedown\", this._preventTextSelection), this._enabled = !0, this._fireEnable()) : this.disable());\n          },\n          disable: function () {\n            if (this.enabled()) {\n              this._layer.off(\"remove\", this.disable, this), L.DomEvent.off(this.textArea, \"input\", this._autoResize, this), L.DomEvent.off(this.textArea, \"focus\", this._focusChange, this), L.DomEvent.off(this.textArea, \"blur\", this._focusChange, this), L.DomEvent.off(document, \"click\", this._documentClick, this), this._focusChange(), this.textArea.readOnly = !0, this.textArea.classList.add(\"pm-disabled\");\n              var t = document.activeElement;\n              this.textArea.focus(), this.textArea.selectionStart = 0, this.textArea.selectionEnd = 0, L.DomEvent.on(this.textArea, \"mousedown\", this._preventTextSelection), t.focus(), this._disableOnBlurActive = !1, this._layerEdited && this._fireUpdate(), this._layerEdited = !1, this._fireDisable(), this._enabled = !1;\n            }\n          },\n          enabled: function () {\n            return this._enabled;\n          },\n          toggleEdit: function (t) {\n            this.enabled() ? this.disable() : this.enable(t);\n          },\n          applyOptions: function () {\n            this.options.snappable ? this._initSnappableMarkers() : this._disableSnapping();\n          },\n          _initSnappableMarkers: function () {\n            var t = this._layer;\n            this.options.snapDistance = this.options.snapDistance || 30, this.options.snapSegment = this.options.snapSegment === undefined || this.options.snapSegment, t.off(\"pm:drag\", this._handleSnapping, this), t.on(\"pm:drag\", this._handleSnapping, this), t.off(\"pm:dragend\", this._cleanupSnapping, this), t.on(\"pm:dragend\", this._cleanupSnapping, this), t.off(\"pm:dragstart\", this._unsnap, this), t.on(\"pm:dragstart\", this._unsnap, this);\n          },\n          _disableSnapping: function () {\n            var t = this._layer;\n            t.off(\"pm:drag\", this._handleSnapping, this), t.off(\"pm:dragend\", this._cleanupSnapping, this), t.off(\"pm:dragstart\", this._unsnap, this);\n          },\n          _autoResize: function () {\n            this.textArea.style.height = \"1px\", this.textArea.style.width = \"1px\";\n            var t = this.textArea.scrollHeight > 21 ? this.textArea.scrollHeight : 21,\n              e = this.textArea.scrollWidth > 16 ? this.textArea.scrollWidth : 16;\n            this.textArea.style.height = \"\".concat(t, \"px\"), this.textArea.style.width = \"\".concat(e, \"px\"), this._layer.options.text = this.getText(), this._fireTextChange(this.getText());\n          },\n          _disableOnBlur: function () {\n            var t = this;\n            this._disableOnBlurActive = !0, setTimeout(function () {\n              t.enabled() && L.DomEvent.on(document, \"click\", t._documentClick, t);\n            }, 100);\n          },\n          _documentClick: function (t) {\n            t.target !== this.textArea && (this.disable(), !this.getText() && this.options.removeIfEmpty && this.remove());\n          },\n          _focusChange: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n              e = this._hasFocus;\n            this._hasFocus = \"focus\" === t.type, !e != !this._hasFocus && (this._hasFocus ? (this._applyFocus(), this._focusText = this.getText(), this._fireTextFocus()) : (this._removeFocus(), this._fireTextBlur(), this._focusText !== this.getText() && (this._fireEdit(), this._layerEdited = !0)));\n          },\n          _applyFocus: function () {\n            this.textArea.classList.add(\"pm-hasfocus\"), this._map.dragging && (this._safeToCacheDragState && (this._originalMapDragState = this._map.dragging._enabled, this._safeToCacheDragState = !1), this._map.dragging.disable());\n          },\n          _removeFocus: function () {\n            this._map.dragging && (this._originalMapDragState && this._map.dragging.enable(), this._safeToCacheDragState = !0), this.textArea.classList.remove(\"pm-hasfocus\");\n          },\n          focus: function () {\n            if (!this.enabled()) throw new TypeError(\"Layer is not enabled\");\n            this.textArea.focus();\n          },\n          blur: function () {\n            if (!this.enabled()) throw new TypeError(\"Layer is not enabled\");\n            this.textArea.blur(), this._disableOnBlurActive && this.disable();\n          },\n          hasFocus: function () {\n            return this._hasFocus;\n          },\n          getElement: function () {\n            return this.textArea;\n          },\n          setText: function (t) {\n            this.textArea.value = t, this._autoResize();\n          },\n          getText: function () {\n            return this.textArea.value;\n          },\n          _initTextMarker: function () {\n            if (this.textArea = L.PM.Draw.Text.prototype._createTextArea.call(this), this.options.className) {\n              var t,\n                e = this.options.className.split(\" \");\n              (t = this.textArea.classList).add.apply(t, De(e));\n            }\n            var i = L.PM.Draw.Text.prototype._createTextIcon.call(this, this.textArea);\n            this._layer.setIcon(i), this._layer.once(\"add\", this._createTextMarker, this);\n          },\n          _createTextMarker: function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined && arguments[0];\n            this._layer.off(\"add\", this._createTextMarker, this), this._layer.getElement().tabIndex = -1, this.textArea.wrap = \"off\", this.textArea.style.overflow = \"hidden\", this.textArea.style.height = L.DomUtil.getStyle(this.textArea, \"font-size\"), this.textArea.style.width = \"1px\", this._layer.options.text && this.setText(this._layer.options.text), this._autoResize(), !0 === t && (this.enable(), this.focus(), this._disableOnBlur());\n          },\n          _preventTextSelection: function (t) {\n            t.preventDefault();\n          }\n        });\n        var Re = function (t, e, i, n, r, a) {\n          this._matrix = [t, e, i, n, r, a];\n        };\n        Re.init = function () {\n          return new L.PM.Matrix(1, 0, 0, 1, 0, 0);\n        }, Re.prototype = {\n          transform: function (t) {\n            return this._transform(t.clone());\n          },\n          _transform: function (t) {\n            var e = this._matrix,\n              i = t.x,\n              n = t.y;\n            return t.x = e[0] * i + e[1] * n + e[4], t.y = e[2] * i + e[3] * n + e[5], t;\n          },\n          untransform: function (t) {\n            var e = this._matrix;\n            return new L.Point((t.x / e[0] - e[4]) / e[0], (t.y / e[2] - e[5]) / e[2]);\n          },\n          clone: function () {\n            var t = this._matrix;\n            return new L.PM.Matrix(t[0], t[1], t[2], t[3], t[4], t[5]);\n          },\n          translate: function (t) {\n            return t === undefined ? new L.Point(this._matrix[4], this._matrix[5]) : (\"number\" == typeof t ? (e = t, i = t) : (e = t.x, i = t.y), this._add(1, 0, 0, 1, e, i));\n            var e, i;\n          },\n          scale: function (t, e) {\n            return t === undefined ? new L.Point(this._matrix[0], this._matrix[3]) : (e = e || L.point(0, 0), \"number\" == typeof t ? (i = t, n = t) : (i = t.x, n = t.y), this._add(i, 0, 0, n, e.x, e.y)._add(1, 0, 0, 1, -e.x, -e.y));\n            var i, n;\n          },\n          rotate: function (t, e) {\n            var i = Math.cos(t),\n              n = Math.sin(t);\n            return e = e || new L.Point(0, 0), this._add(i, n, -n, i, e.x, e.y)._add(1, 0, 0, 1, -e.x, -e.y);\n          },\n          flip: function () {\n            return this._matrix[1] *= -1, this._matrix[2] *= -1, this;\n          },\n          _add: function (t, e, i, n, r, a) {\n            var o,\n              s = [[], [], []],\n              l = this._matrix,\n              h = [[l[0], l[2], l[4]], [l[1], l[3], l[5]], [0, 0, 1]],\n              u = [[t, i, r], [e, n, a], [0, 0, 1]];\n            t && t instanceof L.PM.Matrix && (u = [[(l = t._matrix)[0], l[2], l[4]], [l[1], l[3], l[5]], [0, 0, 1]]);\n            for (var c = 0; c < 3; c += 1) for (var p = 0; p < 3; p += 1) {\n              o = 0;\n              for (var d = 0; d < 3; d += 1) o += h[c][d] * u[d][p];\n              s[c][p] = o;\n            }\n            return this._matrix = [s[0][0], s[1][0], s[0][1], s[1][1], s[0][2], s[1][2]], this;\n          }\n        };\n        const Te = Re;\n        var Ie = {\n          calcMiddleLatLng: function (t, e, i) {\n            var n = t.project(e),\n              r = t.project(i);\n            return t.unproject(n._add(r)._divideBy(2));\n          },\n          findLayers: function (t) {\n            var e = [];\n            return t.eachLayer(function (t) {\n              (t instanceof L.Polyline || t instanceof L.Marker || t instanceof L.Circle || t instanceof L.CircleMarker || t instanceof L.ImageOverlay) && e.push(t);\n            }), e = (e = (e = e.filter(function (t) {\n              return !!t.pm;\n            })).filter(function (t) {\n              return !t._pmTempLayer;\n            })).filter(function (t) {\n              return !L.PM.optIn && !t.options.pmIgnore || L.PM.optIn && !1 === t.options.pmIgnore;\n            });\n          },\n          circleToPolygon: function (t) {\n            for (var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 60, i = !(arguments.length > 2 && arguments[2] !== undefined) || arguments[2], n = t.getLatLng(), r = t.getRadius(), a = N(n, r, e, 0, i), o = [], s = 0; s < a.length; s += 1) {\n              var l = [a[s].lat, a[s].lng];\n              o.push(l);\n            }\n            return L.polygon(o, t.options);\n          },\n          disablePopup: function (t) {\n            t.getPopup() && (t._tempPopupCopy = t.getPopup(), t.unbindPopup());\n          },\n          enablePopup: function (t) {\n            t._tempPopupCopy && (t.bindPopup(t._tempPopupCopy), delete t._tempPopupCopy);\n          },\n          _fireEvent: function (t, e, i) {\n            var n = arguments.length > 3 && arguments[3] !== undefined && arguments[3];\n            t.fire(e, i, n);\n            var r = this.getAllParentGroups(t),\n              a = r.groups;\n            a.forEach(function (t) {\n              t.fire(e, i, n);\n            });\n          },\n          getAllParentGroups: function (t) {\n            var e = [],\n              i = [];\n            return !t._pmLastGroupFetch || !t._pmLastGroupFetch.time || new Date().getTime() - t._pmLastGroupFetch.time > 1e3 ? (function n(t) {\n              for (var r in t._eventParents) if (-1 === e.indexOf(r)) {\n                e.push(r);\n                var a = t._eventParents[r];\n                i.push(a), n(a);\n              }\n            }(t), t._pmLastGroupFetch = {\n              time: new Date().getTime(),\n              groups: i,\n              groupIds: e\n            }, {\n              groupIds: e,\n              groups: i\n            }) : {\n              groups: t._pmLastGroupFetch.groups,\n              groupIds: t._pmLastGroupFetch.groupIds\n            };\n          },\n          createGeodesicPolygon: N,\n          getTranslation: I,\n          findDeepCoordIndex: function (t, e) {\n            var i,\n              n = !(arguments.length > 2 && arguments[2] !== undefined) || arguments[2],\n              r = function o(t) {\n                return function (r, a) {\n                  var s = t.concat(a);\n                  if (n) {\n                    if (r.lat && r.lat === e.lat && r.lng === e.lng) return i = s, !0;\n                  } else if (r.lat && L.latLng(r).equals(e)) return i = s, !0;\n                  return Array.isArray(r) && r.some(o(s));\n                };\n              };\n            t.some(r([]));\n            var a = {};\n            return i && (a = {\n              indexPath: i,\n              index: i[i.length - 1],\n              parentPath: i.slice(0, i.length - 1)\n            }), a;\n          },\n          findDeepMarkerIndex: function (t, e) {\n            var i;\n            t.some(function r(t) {\n              return function (n, a) {\n                var o = t.concat(a);\n                return n._leaflet_id === e._leaflet_id ? (i = o, !0) : Array.isArray(n) && n.some(r(o));\n              };\n            }([]));\n            var n = {};\n            return i && (n = {\n              indexPath: i,\n              index: i[i.length - 1],\n              parentPath: i.slice(0, i.length - 1)\n            }), n;\n          },\n          _getIndexFromSegment: function (t, e) {\n            if (e && 2 === e.length) {\n              var i = this.findDeepCoordIndex(t, e[0]),\n                n = this.findDeepCoordIndex(t, e[1]),\n                r = Math.max(i.index, n.index);\n              return 0 !== i.index && 0 !== n.index || 1 === r || (r += 1), {\n                indexA: i,\n                indexB: n,\n                newIndex: r,\n                indexPath: i.indexPath,\n                parentPath: i.parentPath\n              };\n            }\n            return null;\n          },\n          _getRotatedRectangle: function (t, e, i, n) {\n            var r = be(n, t),\n              a = be(n, e),\n              o = i * Math.PI / 180,\n              s = Math.cos(o),\n              l = Math.sin(o),\n              h = (a.x - r.x) * s + (a.y - r.y) * l,\n              u = (a.y - r.y) * s - (a.x - r.x) * l,\n              c = h * s + r.x,\n              p = h * l + r.y,\n              d = -u * l + r.x,\n              f = u * s + r.y;\n            return [ke(n, r), ke(n, {\n              x: c,\n              y: p\n            }), ke(n, a), ke(n, {\n              x: d,\n              y: f\n            })];\n          },\n          pxRadiusToMeterRadius: function (t, e, i) {\n            var n = e.project(i),\n              r = L.point(n.x + t, n.y);\n            return e.distance(e.unproject(r), i);\n          }\n        };\n        const je = Ie;\n        L.PM = L.PM || {\n          version: \"2.14.2\",\n          Map: H,\n          Toolbar: $,\n          Draw: nt,\n          Edit: we,\n          Utils: je,\n          Matrix: Te,\n          activeLang: \"en\",\n          optIn: !1,\n          initialize: function (t) {\n            this.addInitHooks(t);\n          },\n          setOptIn: function (t) {\n            this.optIn = !!t;\n          },\n          addInitHooks: function () {\n            L.Map.addInitHook(function () {\n              this.pm = undefined, L.PM.optIn ? !1 === this.options.pmIgnore && (this.pm = new L.PM.Map(this)) : this.options.pmIgnore || (this.pm = new L.PM.Map(this)), this.pm && this.pm.setGlobalOptions({});\n            }), L.LayerGroup.addInitHook(function () {\n              this.pm = undefined, L.PM.optIn ? !1 === this.options.pmIgnore && (this.pm = new L.PM.Edit.LayerGroup(this)) : this.options.pmIgnore || (this.pm = new L.PM.Edit.LayerGroup(this));\n            }), L.Marker.addInitHook(function () {\n              this.pm = undefined, L.PM.optIn ? !1 === this.options.pmIgnore && (this.options.textMarker ? (this.pm = new L.PM.Edit.Text(this), this.options._textMarkerOverPM || this.pm._initTextMarker(), delete this.options._textMarkerOverPM) : this.pm = new L.PM.Edit.Marker(this)) : this.options.pmIgnore || (this.options.textMarker ? (this.pm = new L.PM.Edit.Text(this), this.options._textMarkerOverPM || this.pm._initTextMarker(), delete this.options._textMarkerOverPM) : this.pm = new L.PM.Edit.Marker(this));\n            }), L.CircleMarker.addInitHook(function () {\n              this.pm = undefined, L.PM.optIn ? !1 === this.options.pmIgnore && (this.pm = new L.PM.Edit.CircleMarker(this)) : this.options.pmIgnore || (this.pm = new L.PM.Edit.CircleMarker(this));\n            }), L.Polyline.addInitHook(function () {\n              this.pm = undefined, L.PM.optIn ? !1 === this.options.pmIgnore && (this.pm = new L.PM.Edit.Line(this)) : this.options.pmIgnore || (this.pm = new L.PM.Edit.Line(this));\n            }), L.Polygon.addInitHook(function () {\n              this.pm = undefined, L.PM.optIn ? !1 === this.options.pmIgnore && (this.pm = new L.PM.Edit.Polygon(this)) : this.options.pmIgnore || (this.pm = new L.PM.Edit.Polygon(this));\n            }), L.Rectangle.addInitHook(function () {\n              this.pm = undefined, L.PM.optIn ? !1 === this.options.pmIgnore && (this.pm = new L.PM.Edit.Rectangle(this)) : this.options.pmIgnore || (this.pm = new L.PM.Edit.Rectangle(this));\n            }), L.Circle.addInitHook(function () {\n              this.pm = undefined, L.PM.optIn ? !1 === this.options.pmIgnore && (this.pm = new L.PM.Edit.Circle(this)) : this.options.pmIgnore || (this.pm = new L.PM.Edit.Circle(this));\n            }), L.ImageOverlay.addInitHook(function () {\n              this.pm = undefined, L.PM.optIn ? !1 === this.options.pmIgnore && (this.pm = new L.PM.Edit.ImageOverlay(this)) : this.options.pmIgnore || (this.pm = new L.PM.Edit.ImageOverlay(this));\n            });\n          },\n          reInitLayer: function (t) {\n            var e = this;\n            t instanceof L.LayerGroup && t.eachLayer(function (t) {\n              e.reInitLayer(t);\n            }), t.pm || L.PM.optIn && !1 !== t.options.pmIgnore || t.options.pmIgnore || (t instanceof L.Map ? t.pm = new L.PM.Map(t) : t instanceof L.Marker ? t.options.textMarker ? (t.pm = new L.PM.Edit.Text(t), t.pm._initTextMarker(), t.pm._createTextMarker(!1)) : t.pm = new L.PM.Edit.Marker(t) : t instanceof L.Circle ? t.pm = new L.PM.Edit.Circle(t) : t instanceof L.CircleMarker ? t.pm = new L.PM.Edit.CircleMarker(t) : t instanceof L.Rectangle ? t.pm = new L.PM.Edit.Rectangle(t) : t instanceof L.Polygon ? t.pm = new L.PM.Edit.Polygon(t) : t instanceof L.Polyline ? t.pm = new L.PM.Edit.Line(t) : t instanceof L.LayerGroup ? t.pm = new L.PM.Edit.LayerGroup(t) : t instanceof L.ImageOverlay && (t.pm = new L.PM.Edit.ImageOverlay(t)));\n          }\n        }, \"1.7.1\" === L.version && L.Canvas.include({\n          _onClick: function (t) {\n            for (var e, i, n = this._map.mouseEventToLayerPoint(t), r = this._drawFirst; r; r = r.next) (e = r.layer).options.interactive && e._containsPoint(n) && (\"click\" !== t.type && \"preclick\" !== t.type || !this._map._draggableMoved(e)) && (i = e);\n            i && (L.DomEvent.fakeStop(t), this._fireEvent([i], t));\n          }\n        }), L.PM.initialize();\n      },\n      7107: () => {\n        Array.prototype.findIndex = Array.prototype.findIndex || function (t) {\n          if (null === this) throw new TypeError(\"Array.prototype.findIndex called on null or undefined\");\n          if (\"function\" != typeof t) throw new TypeError(\"callback must be a function\");\n          for (var e = Object(this), i = e.length >>> 0, n = arguments[1], r = 0; r < i; r++) if (t.call(n, e[r], r, e)) return r;\n          return -1;\n        }, Array.prototype.find = Array.prototype.find || function (t) {\n          if (null === this) throw new TypeError(\"Array.prototype.find called on null or undefined\");\n          if (\"function\" != typeof t) throw new TypeError(\"callback must be a function\");\n          for (var e = Object(this), i = e.length >>> 0, n = arguments[1], r = 0; r < i; r++) {\n            var a = e[r];\n            if (t.call(n, a, r, e)) return a;\n          }\n        }, \"function\" != typeof Object.assign && (Object.assign = function (t) {\n          \"use strict\";\n\n          if (null == t) throw new TypeError(\"Cannot convert undefined or null to object\");\n          t = Object(t);\n          for (var e = 1; e < arguments.length; e++) {\n            var i = arguments[e];\n            if (null != i) for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n]);\n          }\n          return t;\n        }), [Element.prototype, CharacterData.prototype, DocumentType.prototype].forEach(function (t) {\n          t.hasOwnProperty(\"remove\") || Object.defineProperty(t, \"remove\", {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0,\n            value: function () {\n              this.parentNode.removeChild(this);\n            }\n          });\n        }), Array.prototype.includes || Object.defineProperty(Array.prototype, \"includes\", {\n          value: function (t, e) {\n            if (null == this) throw new TypeError('\"this\" is null or not defined');\n            var i = Object(this),\n              n = i.length >>> 0;\n            if (0 === n) return !1;\n            var r,\n              a,\n              o = 0 | e,\n              s = Math.max(o >= 0 ? o : n - Math.abs(o), 0);\n            for (; s < n;) {\n              if ((r = i[s]) === (a = t) || \"number\" == typeof r && \"number\" == typeof a && isNaN(r) && isNaN(a)) return !0;\n              s++;\n            }\n            return !1;\n          }\n        });\n      },\n      1787: (t, e, i) => {\n        var n = i(2582),\n          r = i(4102),\n          a = i(1540),\n          o = i(9705).Z,\n          s = a.featureEach,\n          l = (a.coordEach, r.polygon, r.featureCollection);\n        function h(t) {\n          var e = new n(t);\n          return e.insert = function (t) {\n            if (\"Feature\" !== t.type) throw new Error(\"invalid feature\");\n            return t.bbox = t.bbox ? t.bbox : o(t), n.prototype.insert.call(this, t);\n          }, e.load = function (t) {\n            var e = [];\n            return Array.isArray(t) ? t.forEach(function (t) {\n              if (\"Feature\" !== t.type) throw new Error(\"invalid features\");\n              t.bbox = t.bbox ? t.bbox : o(t), e.push(t);\n            }) : s(t, function (t) {\n              if (\"Feature\" !== t.type) throw new Error(\"invalid features\");\n              t.bbox = t.bbox ? t.bbox : o(t), e.push(t);\n            }), n.prototype.load.call(this, e);\n          }, e.remove = function (t, e) {\n            if (\"Feature\" !== t.type) throw new Error(\"invalid feature\");\n            return t.bbox = t.bbox ? t.bbox : o(t), n.prototype.remove.call(this, t, e);\n          }, e.clear = function () {\n            return n.prototype.clear.call(this);\n          }, e.search = function (t) {\n            var e = n.prototype.search.call(this, this.toBBox(t));\n            return l(e);\n          }, e.collides = function (t) {\n            return n.prototype.collides.call(this, this.toBBox(t));\n          }, e.all = function () {\n            var t = n.prototype.all.call(this);\n            return l(t);\n          }, e.toJSON = function () {\n            return n.prototype.toJSON.call(this);\n          }, e.fromJSON = function (t) {\n            return n.prototype.fromJSON.call(this, t);\n          }, e.toBBox = function (t) {\n            var e;\n            if (t.bbox) e = t.bbox;else if (Array.isArray(t) && 4 === t.length) e = t;else if (Array.isArray(t) && 6 === t.length) e = [t[0], t[1], t[3], t[4]];else if (\"Feature\" === t.type) e = o(t);else {\n              if (\"FeatureCollection\" !== t.type) throw new Error(\"invalid geojson\");\n              e = o(t);\n            }\n            return {\n              minX: e[0],\n              minY: e[1],\n              maxX: e[2],\n              maxY: e[3]\n            };\n          }, e;\n        }\n        t.exports = h, t.exports[\"default\"] = h;\n      },\n      1989: (t, e, i) => {\n        var n = i(1789),\n          r = i(401),\n          a = i(7667),\n          o = i(1327),\n          s = i(1866);\n        function l(t) {\n          var e = -1,\n            i = null == t ? 0 : t.length;\n          for (this.clear(); ++e < i;) {\n            var n = t[e];\n            this.set(n[0], n[1]);\n          }\n        }\n        l.prototype.clear = n, l.prototype[\"delete\"] = r, l.prototype.get = a, l.prototype.has = o, l.prototype.set = s, t.exports = l;\n      },\n      8407: (t, e, i) => {\n        var n = i(7040),\n          r = i(4125),\n          a = i(2117),\n          o = i(7518),\n          s = i(4705);\n        function l(t) {\n          var e = -1,\n            i = null == t ? 0 : t.length;\n          for (this.clear(); ++e < i;) {\n            var n = t[e];\n            this.set(n[0], n[1]);\n          }\n        }\n        l.prototype.clear = n, l.prototype[\"delete\"] = r, l.prototype.get = a, l.prototype.has = o, l.prototype.set = s, t.exports = l;\n      },\n      7071: (t, e, i) => {\n        var n = i(852)(i(5639), \"Map\");\n        t.exports = n;\n      },\n      3369: (t, e, i) => {\n        var n = i(4785),\n          r = i(1285),\n          a = i(6e3),\n          o = i(9916),\n          s = i(5265);\n        function l(t) {\n          var e = -1,\n            i = null == t ? 0 : t.length;\n          for (this.clear(); ++e < i;) {\n            var n = t[e];\n            this.set(n[0], n[1]);\n          }\n        }\n        l.prototype.clear = n, l.prototype[\"delete\"] = r, l.prototype.get = a, l.prototype.has = o, l.prototype.set = s, t.exports = l;\n      },\n      6384: (t, e, i) => {\n        var n = i(8407),\n          r = i(7465),\n          a = i(3779),\n          o = i(7599),\n          s = i(4758),\n          l = i(4309);\n        function h(t) {\n          var e = this.__data__ = new n(t);\n          this.size = e.size;\n        }\n        h.prototype.clear = r, h.prototype[\"delete\"] = a, h.prototype.get = o, h.prototype.has = s, h.prototype.set = l, t.exports = h;\n      },\n      2705: (t, e, i) => {\n        var n = i(5639).Symbol;\n        t.exports = n;\n      },\n      1149: (t, e, i) => {\n        var n = i(5639).Uint8Array;\n        t.exports = n;\n      },\n      6874: t => {\n        t.exports = function (t, e, i) {\n          switch (i.length) {\n            case 0:\n              return t.call(e);\n            case 1:\n              return t.call(e, i[0]);\n            case 2:\n              return t.call(e, i[0], i[1]);\n            case 3:\n              return t.call(e, i[0], i[1], i[2]);\n          }\n          return t.apply(e, i);\n        };\n      },\n      4636: (t, e, i) => {\n        var n = i(2545),\n          r = i(5694),\n          a = i(1469),\n          o = i(4144),\n          s = i(5776),\n          l = i(6719),\n          h = Object.prototype.hasOwnProperty;\n        t.exports = function (t, e) {\n          var i = a(t),\n            u = !i && r(t),\n            c = !i && !u && o(t),\n            p = !i && !u && !c && l(t),\n            d = i || u || c || p,\n            f = d ? n(t.length, String) : [],\n            g = f.length;\n          for (var _ in t) !e && !h.call(t, _) || d && (\"length\" == _ || c && (\"offset\" == _ || \"parent\" == _) || p && (\"buffer\" == _ || \"byteLength\" == _ || \"byteOffset\" == _) || s(_, g)) || f.push(_);\n          return f;\n        };\n      },\n      9932: t => {\n        t.exports = function (t, e) {\n          for (var i = -1, n = null == t ? 0 : t.length, r = Array(n); ++i < n;) r[i] = e(t[i], i, t);\n          return r;\n        };\n      },\n      6556: (t, e, i) => {\n        var n = i(9465),\n          r = i(7813);\n        t.exports = function (t, e, i) {\n          (i !== undefined && !r(t[e], i) || i === undefined && !(e in t)) && n(t, e, i);\n        };\n      },\n      4865: (t, e, i) => {\n        var n = i(9465),\n          r = i(7813),\n          a = Object.prototype.hasOwnProperty;\n        t.exports = function (t, e, i) {\n          var o = t[e];\n          a.call(t, e) && r(o, i) && (i !== undefined || e in t) || n(t, e, i);\n        };\n      },\n      8470: (t, e, i) => {\n        var n = i(7813);\n        t.exports = function (t, e) {\n          for (var i = t.length; i--;) if (n(t[i][0], e)) return i;\n          return -1;\n        };\n      },\n      9465: (t, e, i) => {\n        var n = i(8777);\n        t.exports = function (t, e, i) {\n          \"__proto__\" == e && n ? n(t, e, {\n            configurable: !0,\n            enumerable: !0,\n            value: i,\n            writable: !0\n          }) : t[e] = i;\n        };\n      },\n      3118: (t, e, i) => {\n        var n = i(3218),\n          r = Object.create,\n          a = function () {\n            function t() {}\n            return function (e) {\n              if (!n(e)) return {};\n              if (r) return r(e);\n              t.prototype = e;\n              var i = new t();\n              return t.prototype = undefined, i;\n            };\n          }();\n        t.exports = a;\n      },\n      8483: (t, e, i) => {\n        var n = i(5063)();\n        t.exports = n;\n      },\n      7786: (t, e, i) => {\n        var n = i(1811),\n          r = i(327);\n        t.exports = function (t, e) {\n          for (var i = 0, a = (e = n(e, t)).length; null != t && i < a;) t = t[r(e[i++])];\n          return i && i == a ? t : undefined;\n        };\n      },\n      4239: (t, e, i) => {\n        var n = i(2705),\n          r = i(9607),\n          a = i(2333),\n          o = n ? n.toStringTag : undefined;\n        t.exports = function (t) {\n          return null == t ? t === undefined ? \"[object Undefined]\" : \"[object Null]\" : o && o in Object(t) ? r(t) : a(t);\n        };\n      },\n      8565: t => {\n        var e = Object.prototype.hasOwnProperty;\n        t.exports = function (t, i) {\n          return null != t && e.call(t, i);\n        };\n      },\n      9454: (t, e, i) => {\n        var n = i(4239),\n          r = i(7005);\n        t.exports = function (t) {\n          return r(t) && \"[object Arguments]\" == n(t);\n        };\n      },\n      8458: (t, e, i) => {\n        var n = i(3560),\n          r = i(5346),\n          a = i(3218),\n          o = i(346),\n          s = /^\\[object .+?Constructor\\]$/,\n          l = Function.prototype,\n          h = Object.prototype,\n          u = l.toString,\n          c = h.hasOwnProperty,\n          p = RegExp(\"^\" + u.call(c).replace(/[\\\\^$.*+?()[\\]{}|]/g, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\");\n        t.exports = function (t) {\n          return !(!a(t) || r(t)) && (n(t) ? p : s).test(o(t));\n        };\n      },\n      8749: (t, e, i) => {\n        var n = i(4239),\n          r = i(1780),\n          a = i(7005),\n          o = {};\n        o[\"[object Float32Array]\"] = o[\"[object Float64Array]\"] = o[\"[object Int8Array]\"] = o[\"[object Int16Array]\"] = o[\"[object Int32Array]\"] = o[\"[object Uint8Array]\"] = o[\"[object Uint8ClampedArray]\"] = o[\"[object Uint16Array]\"] = o[\"[object Uint32Array]\"] = !0, o[\"[object Arguments]\"] = o[\"[object Array]\"] = o[\"[object ArrayBuffer]\"] = o[\"[object Boolean]\"] = o[\"[object DataView]\"] = o[\"[object Date]\"] = o[\"[object Error]\"] = o[\"[object Function]\"] = o[\"[object Map]\"] = o[\"[object Number]\"] = o[\"[object Object]\"] = o[\"[object RegExp]\"] = o[\"[object Set]\"] = o[\"[object String]\"] = o[\"[object WeakMap]\"] = !1, t.exports = function (t) {\n          return a(t) && r(t.length) && !!o[n(t)];\n        };\n      },\n      313: (t, e, i) => {\n        var n = i(3218),\n          r = i(5726),\n          a = i(3498),\n          o = Object.prototype.hasOwnProperty;\n        t.exports = function (t) {\n          if (!n(t)) return a(t);\n          var e = r(t),\n            i = [];\n          for (var s in t) (\"constructor\" != s || !e && o.call(t, s)) && i.push(s);\n          return i;\n        };\n      },\n      2980: (t, e, i) => {\n        var n = i(6384),\n          r = i(6556),\n          a = i(8483),\n          o = i(9783),\n          s = i(3218),\n          l = i(1704),\n          h = i(6390);\n        t.exports = function u(t, e, i, c, p) {\n          t !== e && a(e, function (a, l) {\n            if (p || (p = new n()), s(a)) o(t, e, l, i, u, c, p);else {\n              var d = c ? c(h(t, l), a, l + \"\", t, e, p) : undefined;\n              d === undefined && (d = a), r(t, l, d);\n            }\n          }, l);\n        };\n      },\n      9783: (t, e, i) => {\n        var n = i(6556),\n          r = i(4626),\n          a = i(7133),\n          o = i(278),\n          s = i(8517),\n          l = i(5694),\n          h = i(1469),\n          u = i(9246),\n          c = i(4144),\n          p = i(3560),\n          d = i(3218),\n          f = i(8630),\n          g = i(6719),\n          _ = i(6390),\n          m = i(9881);\n        t.exports = function (t, e, i, y, v, L, b) {\n          var k = _(t, i),\n            M = _(e, i),\n            x = b.get(M);\n          if (x) n(t, i, x);else {\n            var w = L ? L(k, M, i + \"\", t, e, b) : undefined,\n              C = w === undefined;\n            if (C) {\n              var P = h(M),\n                E = !P && c(M),\n                S = !P && !E && g(M);\n              w = M, P || E || S ? h(k) ? w = k : u(k) ? w = o(k) : E ? (C = !1, w = r(M, !0)) : S ? (C = !1, w = a(M, !0)) : w = [] : f(M) || l(M) ? (w = k, l(k) ? w = m(k) : d(k) && !p(k) || (w = s(M))) : C = !1;\n            }\n            C && (b.set(M, w), v(w, M, y, L, b), b[\"delete\"](M)), n(t, i, w);\n          }\n        };\n      },\n      5976: (t, e, i) => {\n        var n = i(6557),\n          r = i(5357),\n          a = i(61);\n        t.exports = function (t, e) {\n          return a(r(t, e, n), t + \"\");\n        };\n      },\n      6560: (t, e, i) => {\n        var n = i(5703),\n          r = i(8777),\n          a = i(6557),\n          o = r ? function (t, e) {\n            return r(t, \"toString\", {\n              configurable: !0,\n              enumerable: !1,\n              value: n(e),\n              writable: !0\n            });\n          } : a;\n        t.exports = o;\n      },\n      2545: t => {\n        t.exports = function (t, e) {\n          for (var i = -1, n = Array(t); ++i < t;) n[i] = e(i);\n          return n;\n        };\n      },\n      531: (t, e, i) => {\n        var n = i(2705),\n          r = i(9932),\n          a = i(1469),\n          o = i(3448),\n          s = n ? n.prototype : undefined,\n          l = s ? s.toString : undefined;\n        t.exports = function h(t) {\n          if (\"string\" == typeof t) return t;\n          if (a(t)) return r(t, h) + \"\";\n          if (o(t)) return l ? l.call(t) : \"\";\n          var e = t + \"\";\n          return \"0\" == e && 1 / t == -Infinity ? \"-0\" : e;\n        };\n      },\n      1717: t => {\n        t.exports = function (t) {\n          return function (e) {\n            return t(e);\n          };\n        };\n      },\n      1811: (t, e, i) => {\n        var n = i(1469),\n          r = i(5403),\n          a = i(5514),\n          o = i(9833);\n        t.exports = function (t, e) {\n          return n(t) ? t : r(t, e) ? [t] : a(o(t));\n        };\n      },\n      4318: (t, e, i) => {\n        var n = i(1149);\n        t.exports = function (t) {\n          var e = new t.constructor(t.byteLength);\n          return new n(e).set(new n(t)), e;\n        };\n      },\n      4626: (t, e, i) => {\n        t = i.nmd(t);\n        var n = i(5639),\n          r = e && !e.nodeType && e,\n          a = r && t && !t.nodeType && t,\n          o = a && a.exports === r ? n.Buffer : undefined,\n          s = o ? o.allocUnsafe : undefined;\n        t.exports = function (t, e) {\n          if (e) return t.slice();\n          var i = t.length,\n            n = s ? s(i) : new t.constructor(i);\n          return t.copy(n), n;\n        };\n      },\n      7133: (t, e, i) => {\n        var n = i(4318);\n        t.exports = function (t, e) {\n          var i = e ? n(t.buffer) : t.buffer;\n          return new t.constructor(i, t.byteOffset, t.length);\n        };\n      },\n      278: t => {\n        t.exports = function (t, e) {\n          var i = -1,\n            n = t.length;\n          for (e || (e = Array(n)); ++i < n;) e[i] = t[i];\n          return e;\n        };\n      },\n      8363: (t, e, i) => {\n        var n = i(4865),\n          r = i(9465);\n        t.exports = function (t, e, i, a) {\n          var o = !i;\n          i || (i = {});\n          for (var s = -1, l = e.length; ++s < l;) {\n            var h = e[s],\n              u = a ? a(i[h], t[h], h, i, t) : undefined;\n            u === undefined && (u = t[h]), o ? r(i, h, u) : n(i, h, u);\n          }\n          return i;\n        };\n      },\n      4429: (t, e, i) => {\n        var n = i(5639)[\"__core-js_shared__\"];\n        t.exports = n;\n      },\n      1463: (t, e, i) => {\n        var n = i(5976),\n          r = i(6612);\n        t.exports = function (t) {\n          return n(function (e, i) {\n            var n = -1,\n              a = i.length,\n              o = a > 1 ? i[a - 1] : undefined,\n              s = a > 2 ? i[2] : undefined;\n            for (o = t.length > 3 && \"function\" == typeof o ? (a--, o) : undefined, s && r(i[0], i[1], s) && (o = a < 3 ? undefined : o, a = 1), e = Object(e); ++n < a;) {\n              var l = i[n];\n              l && t(e, l, n, o);\n            }\n            return e;\n          });\n        };\n      },\n      5063: t => {\n        t.exports = function (t) {\n          return function (e, i, n) {\n            for (var r = -1, a = Object(e), o = n(e), s = o.length; s--;) {\n              var l = o[t ? s : ++r];\n              if (!1 === i(a[l], l, a)) break;\n            }\n            return e;\n          };\n        };\n      },\n      8777: (t, e, i) => {\n        var n = i(852),\n          r = function () {\n            try {\n              var t = n(Object, \"defineProperty\");\n              return t({}, \"\", {}), t;\n            } catch (e) {}\n          }();\n        t.exports = r;\n      },\n      1957: (t, e, i) => {\n        var n = \"object\" == typeof i.g && i.g && i.g.Object === Object && i.g;\n        t.exports = n;\n      },\n      5050: (t, e, i) => {\n        var n = i(7019);\n        t.exports = function (t, e) {\n          var i = t.__data__;\n          return n(e) ? i[\"string\" == typeof e ? \"string\" : \"hash\"] : i.map;\n        };\n      },\n      852: (t, e, i) => {\n        var n = i(8458),\n          r = i(7801);\n        t.exports = function (t, e) {\n          var i = r(t, e);\n          return n(i) ? i : undefined;\n        };\n      },\n      5924: (t, e, i) => {\n        var n = i(5569)(Object.getPrototypeOf, Object);\n        t.exports = n;\n      },\n      9607: (t, e, i) => {\n        var n = i(2705),\n          r = Object.prototype,\n          a = r.hasOwnProperty,\n          o = r.toString,\n          s = n ? n.toStringTag : undefined;\n        t.exports = function (t) {\n          var e = a.call(t, s),\n            i = t[s];\n          try {\n            t[s] = undefined;\n            var n = !0;\n          } catch (l) {}\n          var r = o.call(t);\n          return n && (e ? t[s] = i : delete t[s]), r;\n        };\n      },\n      7801: t => {\n        t.exports = function (t, e) {\n          return null == t ? undefined : t[e];\n        };\n      },\n      222: (t, e, i) => {\n        var n = i(1811),\n          r = i(5694),\n          a = i(1469),\n          o = i(5776),\n          s = i(1780),\n          l = i(327);\n        t.exports = function (t, e, i) {\n          for (var h = -1, u = (e = n(e, t)).length, c = !1; ++h < u;) {\n            var p = l(e[h]);\n            if (!(c = null != t && i(t, p))) break;\n            t = t[p];\n          }\n          return c || ++h != u ? c : !!(u = null == t ? 0 : t.length) && s(u) && o(p, u) && (a(t) || r(t));\n        };\n      },\n      1789: (t, e, i) => {\n        var n = i(4536);\n        t.exports = function () {\n          this.__data__ = n ? n(null) : {}, this.size = 0;\n        };\n      },\n      401: t => {\n        t.exports = function (t) {\n          var e = this.has(t) && delete this.__data__[t];\n          return this.size -= e ? 1 : 0, e;\n        };\n      },\n      7667: (t, e, i) => {\n        var n = i(4536),\n          r = Object.prototype.hasOwnProperty;\n        t.exports = function (t) {\n          var e = this.__data__;\n          if (n) {\n            var i = e[t];\n            return \"__lodash_hash_undefined__\" === i ? undefined : i;\n          }\n          return r.call(e, t) ? e[t] : undefined;\n        };\n      },\n      1327: (t, e, i) => {\n        var n = i(4536),\n          r = Object.prototype.hasOwnProperty;\n        t.exports = function (t) {\n          var e = this.__data__;\n          return n ? e[t] !== undefined : r.call(e, t);\n        };\n      },\n      1866: (t, e, i) => {\n        var n = i(4536);\n        t.exports = function (t, e) {\n          var i = this.__data__;\n          return this.size += this.has(t) ? 0 : 1, i[t] = n && e === undefined ? \"__lodash_hash_undefined__\" : e, this;\n        };\n      },\n      8517: (t, e, i) => {\n        var n = i(3118),\n          r = i(5924),\n          a = i(5726);\n        t.exports = function (t) {\n          return \"function\" != typeof t.constructor || a(t) ? {} : n(r(t));\n        };\n      },\n      5776: t => {\n        var e = /^(?:0|[1-9]\\d*)$/;\n        t.exports = function (t, i) {\n          var n = typeof t;\n          return !!(i = null == i ? 9007199254740991 : i) && (\"number\" == n || \"symbol\" != n && e.test(t)) && t > -1 && t % 1 == 0 && t < i;\n        };\n      },\n      6612: (t, e, i) => {\n        var n = i(7813),\n          r = i(8612),\n          a = i(5776),\n          o = i(3218);\n        t.exports = function (t, e, i) {\n          if (!o(i)) return !1;\n          var s = typeof e;\n          return !!(\"number\" == s ? r(i) && a(e, i.length) : \"string\" == s && e in i) && n(i[e], t);\n        };\n      },\n      5403: (t, e, i) => {\n        var n = i(1469),\n          r = i(3448),\n          a = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n          o = /^\\w*$/;\n        t.exports = function (t, e) {\n          if (n(t)) return !1;\n          var i = typeof t;\n          return !(\"number\" != i && \"symbol\" != i && \"boolean\" != i && null != t && !r(t)) || o.test(t) || !a.test(t) || null != e && t in Object(e);\n        };\n      },\n      7019: t => {\n        t.exports = function (t) {\n          var e = typeof t;\n          return \"string\" == e || \"number\" == e || \"symbol\" == e || \"boolean\" == e ? \"__proto__\" !== t : null === t;\n        };\n      },\n      5346: (t, e, i) => {\n        var n,\n          r = i(4429),\n          a = (n = /[^.]+$/.exec(r && r.keys && r.keys.IE_PROTO || \"\")) ? \"Symbol(src)_1.\" + n : \"\";\n        t.exports = function (t) {\n          return !!a && a in t;\n        };\n      },\n      5726: t => {\n        var e = Object.prototype;\n        t.exports = function (t) {\n          var i = t && t.constructor;\n          return t === (\"function\" == typeof i && i.prototype || e);\n        };\n      },\n      7040: t => {\n        t.exports = function () {\n          this.__data__ = [], this.size = 0;\n        };\n      },\n      4125: (t, e, i) => {\n        var n = i(8470),\n          r = Array.prototype.splice;\n        t.exports = function (t) {\n          var e = this.__data__,\n            i = n(e, t);\n          return !(i < 0) && (i == e.length - 1 ? e.pop() : r.call(e, i, 1), --this.size, !0);\n        };\n      },\n      2117: (t, e, i) => {\n        var n = i(8470);\n        t.exports = function (t) {\n          var e = this.__data__,\n            i = n(e, t);\n          return i < 0 ? undefined : e[i][1];\n        };\n      },\n      7518: (t, e, i) => {\n        var n = i(8470);\n        t.exports = function (t) {\n          return n(this.__data__, t) > -1;\n        };\n      },\n      4705: (t, e, i) => {\n        var n = i(8470);\n        t.exports = function (t, e) {\n          var i = this.__data__,\n            r = n(i, t);\n          return r < 0 ? (++this.size, i.push([t, e])) : i[r][1] = e, this;\n        };\n      },\n      4785: (t, e, i) => {\n        var n = i(1989),\n          r = i(8407),\n          a = i(7071);\n        t.exports = function () {\n          this.size = 0, this.__data__ = {\n            hash: new n(),\n            map: new (a || r)(),\n            string: new n()\n          };\n        };\n      },\n      1285: (t, e, i) => {\n        var n = i(5050);\n        t.exports = function (t) {\n          var e = n(this, t)[\"delete\"](t);\n          return this.size -= e ? 1 : 0, e;\n        };\n      },\n      6e3: (t, e, i) => {\n        var n = i(5050);\n        t.exports = function (t) {\n          return n(this, t).get(t);\n        };\n      },\n      9916: (t, e, i) => {\n        var n = i(5050);\n        t.exports = function (t) {\n          return n(this, t).has(t);\n        };\n      },\n      5265: (t, e, i) => {\n        var n = i(5050);\n        t.exports = function (t, e) {\n          var i = n(this, t),\n            r = i.size;\n          return i.set(t, e), this.size += i.size == r ? 0 : 1, this;\n        };\n      },\n      4523: (t, e, i) => {\n        var n = i(8306);\n        t.exports = function (t) {\n          var e = n(t, function (t) {\n              return 500 === i.size && i.clear(), t;\n            }),\n            i = e.cache;\n          return e;\n        };\n      },\n      4536: (t, e, i) => {\n        var n = i(852)(Object, \"create\");\n        t.exports = n;\n      },\n      3498: t => {\n        t.exports = function (t) {\n          var e = [];\n          if (null != t) for (var i in Object(t)) e.push(i);\n          return e;\n        };\n      },\n      1167: (t, e, i) => {\n        t = i.nmd(t);\n        var n = i(1957),\n          r = e && !e.nodeType && e,\n          a = r && t && !t.nodeType && t,\n          o = a && a.exports === r && n.process,\n          s = function () {\n            try {\n              var t = a && a.require && a.require(\"util\").types;\n              return t || o && o.binding && o.binding(\"util\");\n            } catch (e) {}\n          }();\n        t.exports = s;\n      },\n      2333: t => {\n        var e = Object.prototype.toString;\n        t.exports = function (t) {\n          return e.call(t);\n        };\n      },\n      5569: t => {\n        t.exports = function (t, e) {\n          return function (i) {\n            return t(e(i));\n          };\n        };\n      },\n      5357: (t, e, i) => {\n        var n = i(6874),\n          r = Math.max;\n        t.exports = function (t, e, i) {\n          return e = r(e === undefined ? t.length - 1 : e, 0), function () {\n            for (var a = arguments, o = -1, s = r(a.length - e, 0), l = Array(s); ++o < s;) l[o] = a[e + o];\n            o = -1;\n            for (var h = Array(e + 1); ++o < e;) h[o] = a[o];\n            return h[e] = i(l), n(t, this, h);\n          };\n        };\n      },\n      5639: (t, e, i) => {\n        var n = i(1957),\n          r = \"object\" == typeof self && self && self.Object === Object && self,\n          a = n || r || Function(\"return this\")();\n        t.exports = a;\n      },\n      6390: t => {\n        t.exports = function (t, e) {\n          if ((\"constructor\" !== e || \"function\" != typeof t[e]) && \"__proto__\" != e) return t[e];\n        };\n      },\n      61: (t, e, i) => {\n        var n = i(6560),\n          r = i(1275)(n);\n        t.exports = r;\n      },\n      1275: t => {\n        var e = Date.now;\n        t.exports = function (t) {\n          var i = 0,\n            n = 0;\n          return function () {\n            var r = e(),\n              a = 16 - (r - n);\n            if (n = r, a > 0) {\n              if (++i >= 800) return arguments[0];\n            } else i = 0;\n            return t.apply(undefined, arguments);\n          };\n        };\n      },\n      7465: (t, e, i) => {\n        var n = i(8407);\n        t.exports = function () {\n          this.__data__ = new n(), this.size = 0;\n        };\n      },\n      3779: t => {\n        t.exports = function (t) {\n          var e = this.__data__,\n            i = e[\"delete\"](t);\n          return this.size = e.size, i;\n        };\n      },\n      7599: t => {\n        t.exports = function (t) {\n          return this.__data__.get(t);\n        };\n      },\n      4758: t => {\n        t.exports = function (t) {\n          return this.__data__.has(t);\n        };\n      },\n      4309: (t, e, i) => {\n        var n = i(8407),\n          r = i(7071),\n          a = i(3369);\n        t.exports = function (t, e) {\n          var i = this.__data__;\n          if (i instanceof n) {\n            var o = i.__data__;\n            if (!r || o.length < 199) return o.push([t, e]), this.size = ++i.size, this;\n            i = this.__data__ = new a(o);\n          }\n          return i.set(t, e), this.size = i.size, this;\n        };\n      },\n      5514: (t, e, i) => {\n        var n = i(4523),\n          r = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g,\n          a = /\\\\(\\\\)?/g,\n          o = n(function (t) {\n            var e = [];\n            return 46 === t.charCodeAt(0) && e.push(\"\"), t.replace(r, function (t, i, n, r) {\n              e.push(n ? r.replace(a, \"$1\") : i || t);\n            }), e;\n          });\n        t.exports = o;\n      },\n      327: (t, e, i) => {\n        var n = i(3448);\n        t.exports = function (t) {\n          if (\"string\" == typeof t || n(t)) return t;\n          var e = t + \"\";\n          return \"0\" == e && 1 / t == -Infinity ? \"-0\" : e;\n        };\n      },\n      346: t => {\n        var e = Function.prototype.toString;\n        t.exports = function (t) {\n          if (null != t) {\n            try {\n              return e.call(t);\n            } catch (i) {}\n            try {\n              return t + \"\";\n            } catch (i) {}\n          }\n          return \"\";\n        };\n      },\n      5703: t => {\n        t.exports = function (t) {\n          return function () {\n            return t;\n          };\n        };\n      },\n      7813: t => {\n        t.exports = function (t, e) {\n          return t === e || t != t && e != e;\n        };\n      },\n      7361: (t, e, i) => {\n        var n = i(7786);\n        t.exports = function (t, e, i) {\n          var r = null == t ? undefined : n(t, e);\n          return r === undefined ? i : r;\n        };\n      },\n      8721: (t, e, i) => {\n        var n = i(8565),\n          r = i(222);\n        t.exports = function (t, e) {\n          return null != t && r(t, e, n);\n        };\n      },\n      6557: t => {\n        t.exports = function (t) {\n          return t;\n        };\n      },\n      5694: (t, e, i) => {\n        var n = i(9454),\n          r = i(7005),\n          a = Object.prototype,\n          o = a.hasOwnProperty,\n          s = a.propertyIsEnumerable,\n          l = n(function () {\n            return arguments;\n          }()) ? n : function (t) {\n            return r(t) && o.call(t, \"callee\") && !s.call(t, \"callee\");\n          };\n        t.exports = l;\n      },\n      1469: t => {\n        var e = Array.isArray;\n        t.exports = e;\n      },\n      8612: (t, e, i) => {\n        var n = i(3560),\n          r = i(1780);\n        t.exports = function (t) {\n          return null != t && r(t.length) && !n(t);\n        };\n      },\n      9246: (t, e, i) => {\n        var n = i(8612),\n          r = i(7005);\n        t.exports = function (t) {\n          return r(t) && n(t);\n        };\n      },\n      4144: (t, e, i) => {\n        t = i.nmd(t);\n        var n = i(5639),\n          r = i(5062),\n          a = e && !e.nodeType && e,\n          o = a && t && !t.nodeType && t,\n          s = o && o.exports === a ? n.Buffer : undefined,\n          l = (s ? s.isBuffer : undefined) || r;\n        t.exports = l;\n      },\n      3560: (t, e, i) => {\n        var n = i(4239),\n          r = i(3218);\n        t.exports = function (t) {\n          if (!r(t)) return !1;\n          var e = n(t);\n          return \"[object Function]\" == e || \"[object GeneratorFunction]\" == e || \"[object AsyncFunction]\" == e || \"[object Proxy]\" == e;\n        };\n      },\n      1780: t => {\n        t.exports = function (t) {\n          return \"number\" == typeof t && t > -1 && t % 1 == 0 && t <= 9007199254740991;\n        };\n      },\n      3218: t => {\n        t.exports = function (t) {\n          var e = typeof t;\n          return null != t && (\"object\" == e || \"function\" == e);\n        };\n      },\n      7005: t => {\n        t.exports = function (t) {\n          return null != t && \"object\" == typeof t;\n        };\n      },\n      8630: (t, e, i) => {\n        var n = i(4239),\n          r = i(5924),\n          a = i(7005),\n          o = Function.prototype,\n          s = Object.prototype,\n          l = o.toString,\n          h = s.hasOwnProperty,\n          u = l.call(Object);\n        t.exports = function (t) {\n          if (!a(t) || \"[object Object]\" != n(t)) return !1;\n          var e = r(t);\n          if (null === e) return !0;\n          var i = h.call(e, \"constructor\") && e.constructor;\n          return \"function\" == typeof i && i instanceof i && l.call(i) == u;\n        };\n      },\n      3448: (t, e, i) => {\n        var n = i(4239),\n          r = i(7005);\n        t.exports = function (t) {\n          return \"symbol\" == typeof t || r(t) && \"[object Symbol]\" == n(t);\n        };\n      },\n      6719: (t, e, i) => {\n        var n = i(8749),\n          r = i(1717),\n          a = i(1167),\n          o = a && a.isTypedArray,\n          s = o ? r(o) : n;\n        t.exports = s;\n      },\n      1704: (t, e, i) => {\n        var n = i(4636),\n          r = i(313),\n          a = i(8612);\n        t.exports = function (t) {\n          return a(t) ? n(t, !0) : r(t);\n        };\n      },\n      8306: (t, e, i) => {\n        var n = i(3369);\n        function r(t, e) {\n          if (\"function\" != typeof t || null != e && \"function\" != typeof e) throw new TypeError(\"Expected a function\");\n          var i = function () {\n            var n = arguments,\n              r = e ? e.apply(this, n) : n[0],\n              a = i.cache;\n            if (a.has(r)) return a.get(r);\n            var o = t.apply(this, n);\n            return i.cache = a.set(r, o) || a, o;\n          };\n          return i.cache = new (r.Cache || n)(), i;\n        }\n        r.Cache = n, t.exports = r;\n      },\n      2492: (t, e, i) => {\n        var n = i(2980),\n          r = i(1463)(function (t, e, i) {\n            n(t, e, i);\n          });\n        t.exports = r;\n      },\n      5062: t => {\n        t.exports = function () {\n          return !1;\n        };\n      },\n      9881: (t, e, i) => {\n        var n = i(8363),\n          r = i(1704);\n        t.exports = function (t) {\n          return n(t, r(t));\n        };\n      },\n      9833: (t, e, i) => {\n        var n = i(531);\n        t.exports = function (t) {\n          return null == t ? \"\" : n(t);\n        };\n      },\n      2676: function (t) {\n        t.exports = function () {\n          \"use strict\";\n\n          function t(t, e) {\n            if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n          }\n          function e(t, e) {\n            for (var i = 0; i < e.length; i++) {\n              var n = e[i];\n              n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n            }\n          }\n          function i(t, i, n) {\n            return i && e(t.prototype, i), n && e(t, n), t;\n          }\n          var n = function () {\n            function t(t, e) {\n              this.next = null, this.key = t, this.data = e, this.left = null, this.right = null;\n            }\n            return t;\n          }();\n          function r(t, e) {\n            return t > e ? 1 : t < e ? -1 : 0;\n          }\n          function a(t, e, i) {\n            for (var r = new n(null, null), a = r, o = r;;) {\n              var s = i(t, e.key);\n              if (s < 0) {\n                if (null === e.left) break;\n                if (i(t, e.left.key) < 0) {\n                  var l = e.left;\n                  if (e.left = l.right, l.right = e, null === (e = l).left) break;\n                }\n                o.left = e, o = e, e = e.left;\n              } else {\n                if (!(s > 0)) break;\n                if (null === e.right) break;\n                if (i(t, e.right.key) > 0 && (l = e.right, e.right = l.left, l.left = e, null === (e = l).right)) break;\n                a.right = e, a = e, e = e.right;\n              }\n            }\n            return a.right = e.left, o.left = e.right, e.left = r.right, e.right = r.left, e;\n          }\n          function o(t, e, i, r) {\n            var o = new n(t, e);\n            if (null === i) return o.left = o.right = null, o;\n            var s = r(t, (i = a(t, i, r)).key);\n            return s < 0 ? (o.left = i.left, o.right = i, i.left = null) : s >= 0 && (o.right = i.right, o.left = i, i.right = null), o;\n          }\n          function s(t, e, i) {\n            var n = null,\n              r = null;\n            if (e) {\n              var o = i((e = a(t, e, i)).key, t);\n              0 === o ? (n = e.left, r = e.right) : o < 0 ? (r = e.right, e.right = null, n = e) : (n = e.left, e.left = null, r = e);\n            }\n            return {\n              left: n,\n              right: r\n            };\n          }\n          function l(t, e, i) {\n            return null === e ? t : (null === t || ((e = a(t.key, e, i)).left = t), e);\n          }\n          function h(t, e, i, n, r) {\n            if (t) {\n              n(e + (i ? \"└── \" : \"├── \") + r(t) + \"\\n\");\n              var a = e + (i ? \"    \" : \"│   \");\n              t.left && h(t.left, a, !1, n, r), t.right && h(t.right, a, !0, n, r);\n            }\n          }\n          var u = function () {\n            function t(t) {\n              void 0 === t && (t = r), this._root = null, this._size = 0, this._comparator = t;\n            }\n            return t.prototype.insert = function (t, e) {\n              return this._size++, this._root = o(t, e, this._root, this._comparator);\n            }, t.prototype.add = function (t, e) {\n              var i = new n(t, e);\n              null === this._root && (i.left = i.right = null, this._size++, this._root = i);\n              var r = this._comparator,\n                o = a(t, this._root, r),\n                s = r(t, o.key);\n              return 0 === s ? this._root = o : (s < 0 ? (i.left = o.left, i.right = o, o.left = null) : s > 0 && (i.right = o.right, i.left = o, o.right = null), this._size++, this._root = i), this._root;\n            }, t.prototype.remove = function (t) {\n              this._root = this._remove(t, this._root, this._comparator);\n            }, t.prototype._remove = function (t, e, i) {\n              var n;\n              return null === e ? null : 0 === i(t, (e = a(t, e, i)).key) ? (null === e.left ? n = e.right : (n = a(t, e.left, i)).right = e.right, this._size--, n) : e;\n            }, t.prototype.pop = function () {\n              var t = this._root;\n              if (t) {\n                for (; t.left;) t = t.left;\n                return this._root = a(t.key, this._root, this._comparator), this._root = this._remove(t.key, this._root, this._comparator), {\n                  key: t.key,\n                  data: t.data\n                };\n              }\n              return null;\n            }, t.prototype.findStatic = function (t) {\n              for (var e = this._root, i = this._comparator; e;) {\n                var n = i(t, e.key);\n                if (0 === n) return e;\n                e = n < 0 ? e.left : e.right;\n              }\n              return null;\n            }, t.prototype.find = function (t) {\n              return this._root && (this._root = a(t, this._root, this._comparator), 0 !== this._comparator(t, this._root.key)) ? null : this._root;\n            }, t.prototype.contains = function (t) {\n              for (var e = this._root, i = this._comparator; e;) {\n                var n = i(t, e.key);\n                if (0 === n) return !0;\n                e = n < 0 ? e.left : e.right;\n              }\n              return !1;\n            }, t.prototype.forEach = function (t, e) {\n              for (var i = this._root, n = [], r = !1; !r;) null !== i ? (n.push(i), i = i.left) : 0 !== n.length ? (i = n.pop(), t.call(e, i), i = i.right) : r = !0;\n              return this;\n            }, t.prototype.range = function (t, e, i, n) {\n              for (var r = [], a = this._comparator, o = this._root; 0 !== r.length || o;) if (o) r.push(o), o = o.left;else {\n                if (a((o = r.pop()).key, e) > 0) break;\n                if (a(o.key, t) >= 0 && i.call(n, o)) return this;\n                o = o.right;\n              }\n              return this;\n            }, t.prototype.keys = function () {\n              var t = [];\n              return this.forEach(function (e) {\n                var i = e.key;\n                return t.push(i);\n              }), t;\n            }, t.prototype.values = function () {\n              var t = [];\n              return this.forEach(function (e) {\n                var i = e.data;\n                return t.push(i);\n              }), t;\n            }, t.prototype.min = function () {\n              return this._root ? this.minNode(this._root).key : null;\n            }, t.prototype.max = function () {\n              return this._root ? this.maxNode(this._root).key : null;\n            }, t.prototype.minNode = function (t) {\n              if (void 0 === t && (t = this._root), t) for (; t.left;) t = t.left;\n              return t;\n            }, t.prototype.maxNode = function (t) {\n              if (void 0 === t && (t = this._root), t) for (; t.right;) t = t.right;\n              return t;\n            }, t.prototype.at = function (t) {\n              for (var e = this._root, i = !1, n = 0, r = []; !i;) if (e) r.push(e), e = e.left;else if (r.length > 0) {\n                if (e = r.pop(), n === t) return e;\n                n++, e = e.right;\n              } else i = !0;\n              return null;\n            }, t.prototype.next = function (t) {\n              var e = this._root,\n                i = null;\n              if (t.right) {\n                for (i = t.right; i.left;) i = i.left;\n                return i;\n              }\n              for (var n = this._comparator; e;) {\n                var r = n(t.key, e.key);\n                if (0 === r) break;\n                r < 0 ? (i = e, e = e.left) : e = e.right;\n              }\n              return i;\n            }, t.prototype.prev = function (t) {\n              var e = this._root,\n                i = null;\n              if (null !== t.left) {\n                for (i = t.left; i.right;) i = i.right;\n                return i;\n              }\n              for (var n = this._comparator; e;) {\n                var r = n(t.key, e.key);\n                if (0 === r) break;\n                r < 0 ? e = e.left : (i = e, e = e.right);\n              }\n              return i;\n            }, t.prototype.clear = function () {\n              return this._root = null, this._size = 0, this;\n            }, t.prototype.toList = function () {\n              return d(this._root);\n            }, t.prototype.load = function (t, e, i) {\n              void 0 === e && (e = []), void 0 === i && (i = !1);\n              var n = t.length,\n                r = this._comparator;\n              if (i && _(t, e, 0, n - 1, r), null === this._root) this._root = c(t, e, 0, n), this._size = n;else {\n                var a = g(this.toList(), p(t, e), r);\n                n = this._size + n, this._root = f({\n                  head: a\n                }, 0, n);\n              }\n              return this;\n            }, t.prototype.isEmpty = function () {\n              return null === this._root;\n            }, Object.defineProperty(t.prototype, \"size\", {\n              get: function () {\n                return this._size;\n              },\n              enumerable: !0,\n              configurable: !0\n            }), Object.defineProperty(t.prototype, \"root\", {\n              get: function () {\n                return this._root;\n              },\n              enumerable: !0,\n              configurable: !0\n            }), t.prototype.toString = function (t) {\n              void 0 === t && (t = function (t) {\n                return String(t.key);\n              });\n              var e = [];\n              return h(this._root, \"\", !0, function (t) {\n                return e.push(t);\n              }, t), e.join(\"\");\n            }, t.prototype.update = function (t, e, i) {\n              var n = this._comparator,\n                r = s(t, this._root, n),\n                a = r.left,\n                h = r.right;\n              n(t, e) < 0 ? h = o(e, i, h, n) : a = o(e, i, a, n), this._root = l(a, h, n);\n            }, t.prototype.split = function (t) {\n              return s(t, this._root, this._comparator);\n            }, t;\n          }();\n          function c(t, e, i, r) {\n            var a = r - i;\n            if (a > 0) {\n              var o = i + Math.floor(a / 2),\n                s = t[o],\n                l = e[o],\n                h = new n(s, l);\n              return h.left = c(t, e, i, o), h.right = c(t, e, o + 1, r), h;\n            }\n            return null;\n          }\n          function p(t, e) {\n            for (var i = new n(null, null), r = i, a = 0; a < t.length; a++) r = r.next = new n(t[a], e[a]);\n            return r.next = null, i.next;\n          }\n          function d(t) {\n            for (var e = t, i = [], r = !1, a = new n(null, null), o = a; !r;) e ? (i.push(e), e = e.left) : i.length > 0 ? e = (e = o = o.next = i.pop()).right : r = !0;\n            return o.next = null, a.next;\n          }\n          function f(t, e, i) {\n            var n = i - e;\n            if (n > 0) {\n              var r = e + Math.floor(n / 2),\n                a = f(t, e, r),\n                o = t.head;\n              return o.left = a, t.head = t.head.next, o.right = f(t, r + 1, i), o;\n            }\n            return null;\n          }\n          function g(t, e, i) {\n            for (var r = new n(null, null), a = r, o = t, s = e; null !== o && null !== s;) i(o.key, s.key) < 0 ? (a.next = o, o = o.next) : (a.next = s, s = s.next), a = a.next;\n            return null !== o ? a.next = o : null !== s && (a.next = s), r.next;\n          }\n          function _(t, e, i, n, r) {\n            if (!(i >= n)) {\n              for (var a = t[i + n >> 1], o = i - 1, s = n + 1;;) {\n                do {\n                  o++;\n                } while (r(t[o], a) < 0);\n                do {\n                  s--;\n                } while (r(t[s], a) > 0);\n                if (o >= s) break;\n                var l = t[o];\n                t[o] = t[s], t[s] = l, l = e[o], e[o] = e[s], e[s] = l;\n              }\n              _(t, e, i, s, r), _(t, e, s + 1, n, r);\n            }\n          }\n          var m = function (t, e) {\n              return t.ll.x <= e.x && e.x <= t.ur.x && t.ll.y <= e.y && e.y <= t.ur.y;\n            },\n            y = function (t, e) {\n              if (e.ur.x < t.ll.x || t.ur.x < e.ll.x || e.ur.y < t.ll.y || t.ur.y < e.ll.y) return null;\n              var i = t.ll.x < e.ll.x ? e.ll.x : t.ll.x,\n                n = t.ur.x < e.ur.x ? t.ur.x : e.ur.x;\n              return {\n                ll: {\n                  x: i,\n                  y: t.ll.y < e.ll.y ? e.ll.y : t.ll.y\n                },\n                ur: {\n                  x: n,\n                  y: t.ur.y < e.ur.y ? t.ur.y : e.ur.y\n                }\n              };\n            },\n            v = Number.EPSILON;\n          v === undefined && (v = Math.pow(2, -52));\n          var L = v * v,\n            b = function (t, e) {\n              if (-v < t && t < v && -v < e && e < v) return 0;\n              var i = t - e;\n              return i * i < L * t * e ? 0 : t < e ? -1 : 1;\n            },\n            k = function () {\n              function e() {\n                t(this, e), this.reset();\n              }\n              return i(e, [{\n                key: \"reset\",\n                value: function () {\n                  this.xRounder = new M(), this.yRounder = new M();\n                }\n              }, {\n                key: \"round\",\n                value: function (t, e) {\n                  return {\n                    x: this.xRounder.round(t),\n                    y: this.yRounder.round(e)\n                  };\n                }\n              }]), e;\n            }(),\n            M = function () {\n              function e() {\n                t(this, e), this.tree = new u(), this.round(0);\n              }\n              return i(e, [{\n                key: \"round\",\n                value: function (t) {\n                  var e = this.tree.add(t),\n                    i = this.tree.prev(e);\n                  if (null !== i && 0 === b(e.key, i.key)) return this.tree.remove(t), i.key;\n                  var n = this.tree.next(e);\n                  return null !== n && 0 === b(e.key, n.key) ? (this.tree.remove(t), n.key) : t;\n                }\n              }]), e;\n            }(),\n            x = new k(),\n            w = function (t, e) {\n              return t.x * e.y - t.y * e.x;\n            },\n            C = function (t, e) {\n              return t.x * e.x + t.y * e.y;\n            },\n            P = function (t, e, i) {\n              var n = {\n                  x: e.x - t.x,\n                  y: e.y - t.y\n                },\n                r = {\n                  x: i.x - t.x,\n                  y: i.y - t.y\n                },\n                a = w(n, r);\n              return b(a, 0);\n            },\n            E = function (t) {\n              return Math.sqrt(C(t, t));\n            },\n            S = function (t, e, i) {\n              var n = {\n                  x: e.x - t.x,\n                  y: e.y - t.y\n                },\n                r = {\n                  x: i.x - t.x,\n                  y: i.y - t.y\n                };\n              return w(r, n) / E(r) / E(n);\n            },\n            O = function (t, e, i) {\n              var n = {\n                  x: e.x - t.x,\n                  y: e.y - t.y\n                },\n                r = {\n                  x: i.x - t.x,\n                  y: i.y - t.y\n                };\n              return C(r, n) / E(r) / E(n);\n            },\n            D = function (t, e, i) {\n              return 0 === e.y ? null : {\n                x: t.x + e.x / e.y * (i - t.y),\n                y: i\n              };\n            },\n            B = function (t, e, i) {\n              return 0 === e.x ? null : {\n                x: i,\n                y: t.y + e.y / e.x * (i - t.x)\n              };\n            },\n            R = function (t, e, i, n) {\n              if (0 === e.x) return B(i, n, t.x);\n              if (0 === n.x) return B(t, e, i.x);\n              if (0 === e.y) return D(i, n, t.y);\n              if (0 === n.y) return D(t, e, i.y);\n              var r = w(e, n);\n              if (0 == r) return null;\n              var a = {\n                  x: i.x - t.x,\n                  y: i.y - t.y\n                },\n                o = w(a, e) / r,\n                s = w(a, n) / r;\n              return {\n                x: (t.x + s * e.x + (i.x + o * n.x)) / 2,\n                y: (t.y + s * e.y + (i.y + o * n.y)) / 2\n              };\n            },\n            T = function () {\n              function e(i, n) {\n                t(this, e), i.events === undefined ? i.events = [this] : i.events.push(this), this.point = i, this.isLeft = n;\n              }\n              return i(e, null, [{\n                key: \"compare\",\n                value: function (t, i) {\n                  var n = e.comparePoints(t.point, i.point);\n                  return 0 !== n ? n : (t.point !== i.point && t.link(i), t.isLeft !== i.isLeft ? t.isLeft ? 1 : -1 : j.compare(t.segment, i.segment));\n                }\n              }, {\n                key: \"comparePoints\",\n                value: function (t, e) {\n                  return t.x < e.x ? -1 : t.x > e.x ? 1 : t.y < e.y ? -1 : t.y > e.y ? 1 : 0;\n                }\n              }]), i(e, [{\n                key: \"link\",\n                value: function (t) {\n                  if (t.point === this.point) throw new Error(\"Tried to link already linked events\");\n                  for (var e = t.point.events, i = 0, n = e.length; i < n; i++) {\n                    var r = e[i];\n                    this.point.events.push(r), r.point = this.point;\n                  }\n                  this.checkForConsuming();\n                }\n              }, {\n                key: \"checkForConsuming\",\n                value: function () {\n                  for (var t = this.point.events.length, e = 0; e < t; e++) {\n                    var i = this.point.events[e];\n                    if (i.segment.consumedBy === undefined) for (var n = e + 1; n < t; n++) {\n                      var r = this.point.events[n];\n                      r.consumedBy === undefined && i.otherSE.point.events === r.otherSE.point.events && i.segment.consume(r.segment);\n                    }\n                  }\n                }\n              }, {\n                key: \"getAvailableLinkedEvents\",\n                value: function () {\n                  for (var t = [], e = 0, i = this.point.events.length; e < i; e++) {\n                    var n = this.point.events[e];\n                    n !== this && !n.segment.ringOut && n.segment.isInResult() && t.push(n);\n                  }\n                  return t;\n                }\n              }, {\n                key: \"getLeftmostComparator\",\n                value: function (t) {\n                  var e = this,\n                    i = new Map(),\n                    n = function (n) {\n                      var r = n.otherSE;\n                      i.set(n, {\n                        sine: S(e.point, t.point, r.point),\n                        cosine: O(e.point, t.point, r.point)\n                      });\n                    };\n                  return function (t, e) {\n                    i.has(t) || n(t), i.has(e) || n(e);\n                    var r = i.get(t),\n                      a = r.sine,\n                      o = r.cosine,\n                      s = i.get(e),\n                      l = s.sine,\n                      h = s.cosine;\n                    return a >= 0 && l >= 0 ? o < h ? 1 : o > h ? -1 : 0 : a < 0 && l < 0 ? o < h ? -1 : o > h ? 1 : 0 : l < a ? -1 : l > a ? 1 : 0;\n                  };\n                }\n              }]), e;\n            }(),\n            I = 0,\n            j = function () {\n              function e(i, n, r, a) {\n                t(this, e), this.id = ++I, this.leftSE = i, i.segment = this, i.otherSE = n, this.rightSE = n, n.segment = this, n.otherSE = i, this.rings = r, this.windings = a;\n              }\n              return i(e, null, [{\n                key: \"compare\",\n                value: function (t, e) {\n                  var i = t.leftSE.point.x,\n                    n = e.leftSE.point.x,\n                    r = t.rightSE.point.x,\n                    a = e.rightSE.point.x;\n                  if (a < i) return 1;\n                  if (r < n) return -1;\n                  var o = t.leftSE.point.y,\n                    s = e.leftSE.point.y,\n                    l = t.rightSE.point.y,\n                    h = e.rightSE.point.y;\n                  if (i < n) {\n                    if (s < o && s < l) return 1;\n                    if (s > o && s > l) return -1;\n                    var u = t.comparePoint(e.leftSE.point);\n                    if (u < 0) return 1;\n                    if (u > 0) return -1;\n                    var c = e.comparePoint(t.rightSE.point);\n                    return 0 !== c ? c : -1;\n                  }\n                  if (i > n) {\n                    if (o < s && o < h) return -1;\n                    if (o > s && o > h) return 1;\n                    var p = e.comparePoint(t.leftSE.point);\n                    if (0 !== p) return p;\n                    var d = t.comparePoint(e.rightSE.point);\n                    return d < 0 ? 1 : d > 0 ? -1 : 1;\n                  }\n                  if (o < s) return -1;\n                  if (o > s) return 1;\n                  if (r < a) {\n                    var f = e.comparePoint(t.rightSE.point);\n                    if (0 !== f) return f;\n                  }\n                  if (r > a) {\n                    var g = t.comparePoint(e.rightSE.point);\n                    if (g < 0) return 1;\n                    if (g > 0) return -1;\n                  }\n                  if (r !== a) {\n                    var _ = l - o,\n                      m = r - i,\n                      y = h - s,\n                      v = a - n;\n                    if (_ > m && y < v) return 1;\n                    if (_ < m && y > v) return -1;\n                  }\n                  return r > a ? 1 : r < a || l < h ? -1 : l > h ? 1 : t.id < e.id ? -1 : t.id > e.id ? 1 : 0;\n                }\n              }]), i(e, [{\n                key: \"replaceRightSE\",\n                value: function (t) {\n                  this.rightSE = t, this.rightSE.segment = this, this.rightSE.otherSE = this.leftSE, this.leftSE.otherSE = this.rightSE;\n                }\n              }, {\n                key: \"bbox\",\n                value: function () {\n                  var t = this.leftSE.point.y,\n                    e = this.rightSE.point.y;\n                  return {\n                    ll: {\n                      x: this.leftSE.point.x,\n                      y: t < e ? t : e\n                    },\n                    ur: {\n                      x: this.rightSE.point.x,\n                      y: t > e ? t : e\n                    }\n                  };\n                }\n              }, {\n                key: \"vector\",\n                value: function () {\n                  return {\n                    x: this.rightSE.point.x - this.leftSE.point.x,\n                    y: this.rightSE.point.y - this.leftSE.point.y\n                  };\n                }\n              }, {\n                key: \"isAnEndpoint\",\n                value: function (t) {\n                  return t.x === this.leftSE.point.x && t.y === this.leftSE.point.y || t.x === this.rightSE.point.x && t.y === this.rightSE.point.y;\n                }\n              }, {\n                key: \"comparePoint\",\n                value: function (t) {\n                  if (this.isAnEndpoint(t)) return 0;\n                  var e = this.leftSE.point,\n                    i = this.rightSE.point,\n                    n = this.vector();\n                  if (e.x === i.x) return t.x === e.x ? 0 : t.x < e.x ? 1 : -1;\n                  var r = (t.y - e.y) / n.y,\n                    a = e.x + r * n.x;\n                  if (t.x === a) return 0;\n                  var o = (t.x - e.x) / n.x,\n                    s = e.y + o * n.y;\n                  return t.y === s ? 0 : t.y < s ? -1 : 1;\n                }\n              }, {\n                key: \"getIntersection\",\n                value: function (t) {\n                  var e = this.bbox(),\n                    i = t.bbox(),\n                    n = y(e, i);\n                  if (null === n) return null;\n                  var r = this.leftSE.point,\n                    a = this.rightSE.point,\n                    o = t.leftSE.point,\n                    s = t.rightSE.point,\n                    l = m(e, o) && 0 === this.comparePoint(o),\n                    h = m(i, r) && 0 === t.comparePoint(r),\n                    u = m(e, s) && 0 === this.comparePoint(s),\n                    c = m(i, a) && 0 === t.comparePoint(a);\n                  if (h && l) return c && !u ? a : !c && u ? s : null;\n                  if (h) return u && r.x === s.x && r.y === s.y ? null : r;\n                  if (l) return c && a.x === o.x && a.y === o.y ? null : o;\n                  if (c && u) return null;\n                  if (c) return a;\n                  if (u) return s;\n                  var p = R(r, this.vector(), o, t.vector());\n                  return null === p ? null : m(n, p) ? x.round(p.x, p.y) : null;\n                }\n              }, {\n                key: \"split\",\n                value: function (t) {\n                  var i = [],\n                    n = t.events !== undefined,\n                    r = new T(t, !0),\n                    a = new T(t, !1),\n                    o = this.rightSE;\n                  this.replaceRightSE(a), i.push(a), i.push(r);\n                  var s = new e(r, o, this.rings.slice(), this.windings.slice());\n                  return T.comparePoints(s.leftSE.point, s.rightSE.point) > 0 && s.swapEvents(), T.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(), n && (r.checkForConsuming(), a.checkForConsuming()), i;\n                }\n              }, {\n                key: \"swapEvents\",\n                value: function () {\n                  var t = this.rightSE;\n                  this.rightSE = this.leftSE, this.leftSE = t, this.leftSE.isLeft = !0, this.rightSE.isLeft = !1;\n                  for (var e = 0, i = this.windings.length; e < i; e++) this.windings[e] *= -1;\n                }\n              }, {\n                key: \"consume\",\n                value: function (t) {\n                  for (var i = this, n = t; i.consumedBy;) i = i.consumedBy;\n                  for (; n.consumedBy;) n = n.consumedBy;\n                  var r = e.compare(i, n);\n                  if (0 !== r) {\n                    if (r > 0) {\n                      var a = i;\n                      i = n, n = a;\n                    }\n                    if (i.prev === n) {\n                      var o = i;\n                      i = n, n = o;\n                    }\n                    for (var s = 0, l = n.rings.length; s < l; s++) {\n                      var h = n.rings[s],\n                        u = n.windings[s],\n                        c = i.rings.indexOf(h);\n                      -1 === c ? (i.rings.push(h), i.windings.push(u)) : i.windings[c] += u;\n                    }\n                    n.rings = null, n.windings = null, n.consumedBy = i, n.leftSE.consumedBy = i.leftSE, n.rightSE.consumedBy = i.rightSE;\n                  }\n                }\n              }, {\n                key: \"prevInResult\",\n                value: function () {\n                  return this._prevInResult !== undefined || (this.prev ? this.prev.isInResult() ? this._prevInResult = this.prev : this._prevInResult = this.prev.prevInResult() : this._prevInResult = null), this._prevInResult;\n                }\n              }, {\n                key: \"beforeState\",\n                value: function () {\n                  if (this._beforeState !== undefined) return this._beforeState;\n                  if (this.prev) {\n                    var t = this.prev.consumedBy || this.prev;\n                    this._beforeState = t.afterState();\n                  } else this._beforeState = {\n                    rings: [],\n                    windings: [],\n                    multiPolys: []\n                  };\n                  return this._beforeState;\n                }\n              }, {\n                key: \"afterState\",\n                value: function () {\n                  if (this._afterState !== undefined) return this._afterState;\n                  var t = this.beforeState();\n                  this._afterState = {\n                    rings: t.rings.slice(0),\n                    windings: t.windings.slice(0),\n                    multiPolys: []\n                  };\n                  for (var e = this._afterState.rings, i = this._afterState.windings, n = this._afterState.multiPolys, r = 0, a = this.rings.length; r < a; r++) {\n                    var o = this.rings[r],\n                      s = this.windings[r],\n                      l = e.indexOf(o);\n                    -1 === l ? (e.push(o), i.push(s)) : i[l] += s;\n                  }\n                  for (var h = [], u = [], c = 0, p = e.length; c < p; c++) if (0 !== i[c]) {\n                    var d = e[c],\n                      f = d.poly;\n                    if (-1 === u.indexOf(f)) if (d.isExterior) h.push(f);else {\n                      -1 === u.indexOf(f) && u.push(f);\n                      var g = h.indexOf(d.poly);\n                      -1 !== g && h.splice(g, 1);\n                    }\n                  }\n                  for (var _ = 0, m = h.length; _ < m; _++) {\n                    var y = h[_].multiPoly;\n                    -1 === n.indexOf(y) && n.push(y);\n                  }\n                  return this._afterState;\n                }\n              }, {\n                key: \"isInResult\",\n                value: function () {\n                  if (this.consumedBy) return !1;\n                  if (this._isInResult !== undefined) return this._isInResult;\n                  var t = this.beforeState().multiPolys,\n                    e = this.afterState().multiPolys;\n                  switch (q.type) {\n                    case \"union\":\n                      var i = 0 === t.length,\n                        n = 0 === e.length;\n                      this._isInResult = i !== n;\n                      break;\n                    case \"intersection\":\n                      var r, a;\n                      t.length < e.length ? (r = t.length, a = e.length) : (r = e.length, a = t.length), this._isInResult = a === q.numMultiPolys && r < a;\n                      break;\n                    case \"xor\":\n                      var o = Math.abs(t.length - e.length);\n                      this._isInResult = o % 2 == 1;\n                      break;\n                    case \"difference\":\n                      var s = function (t) {\n                        return 1 === t.length && t[0].isSubject;\n                      };\n                      this._isInResult = s(t) !== s(e);\n                      break;\n                    default:\n                      throw new Error(\"Unrecognized operation type found \".concat(q.type));\n                  }\n                  return this._isInResult;\n                }\n              }], [{\n                key: \"fromRing\",\n                value: function (t, i, n) {\n                  var r,\n                    a,\n                    o,\n                    s = T.comparePoints(t, i);\n                  if (s < 0) r = t, a = i, o = 1;else {\n                    if (!(s > 0)) throw new Error(\"Tried to create degenerate segment at [\".concat(t.x, \", \").concat(t.y, \"]\"));\n                    r = i, a = t, o = -1;\n                  }\n                  return new e(new T(r, !0), new T(a, !1), [n], [o]);\n                }\n              }]), e;\n            }(),\n            A = function () {\n              function e(i, n, r) {\n                if (t(this, e), !Array.isArray(i) || 0 === i.length) throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n                if (this.poly = n, this.isExterior = r, this.segments = [], \"number\" != typeof i[0][0] || \"number\" != typeof i[0][1]) throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n                var a = x.round(i[0][0], i[0][1]);\n                this.bbox = {\n                  ll: {\n                    x: a.x,\n                    y: a.y\n                  },\n                  ur: {\n                    x: a.x,\n                    y: a.y\n                  }\n                };\n                for (var o = a, s = 1, l = i.length; s < l; s++) {\n                  if (\"number\" != typeof i[s][0] || \"number\" != typeof i[s][1]) throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n                  var h = x.round(i[s][0], i[s][1]);\n                  h.x === o.x && h.y === o.y || (this.segments.push(j.fromRing(o, h, this)), h.x < this.bbox.ll.x && (this.bbox.ll.x = h.x), h.y < this.bbox.ll.y && (this.bbox.ll.y = h.y), h.x > this.bbox.ur.x && (this.bbox.ur.x = h.x), h.y > this.bbox.ur.y && (this.bbox.ur.y = h.y), o = h);\n                }\n                a.x === o.x && a.y === o.y || this.segments.push(j.fromRing(o, a, this));\n              }\n              return i(e, [{\n                key: \"getSweepEvents\",\n                value: function () {\n                  for (var t = [], e = 0, i = this.segments.length; e < i; e++) {\n                    var n = this.segments[e];\n                    t.push(n.leftSE), t.push(n.rightSE);\n                  }\n                  return t;\n                }\n              }]), e;\n            }(),\n            G = function () {\n              function e(i, n) {\n                if (t(this, e), !Array.isArray(i)) throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n                this.exteriorRing = new A(i[0], this, !0), this.bbox = {\n                  ll: {\n                    x: this.exteriorRing.bbox.ll.x,\n                    y: this.exteriorRing.bbox.ll.y\n                  },\n                  ur: {\n                    x: this.exteriorRing.bbox.ur.x,\n                    y: this.exteriorRing.bbox.ur.y\n                  }\n                }, this.interiorRings = [];\n                for (var r = 1, a = i.length; r < a; r++) {\n                  var o = new A(i[r], this, !1);\n                  o.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = o.bbox.ll.x), o.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = o.bbox.ll.y), o.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = o.bbox.ur.x), o.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = o.bbox.ur.y), this.interiorRings.push(o);\n                }\n                this.multiPoly = n;\n              }\n              return i(e, [{\n                key: \"getSweepEvents\",\n                value: function () {\n                  for (var t = this.exteriorRing.getSweepEvents(), e = 0, i = this.interiorRings.length; e < i; e++) for (var n = this.interiorRings[e].getSweepEvents(), r = 0, a = n.length; r < a; r++) t.push(n[r]);\n                  return t;\n                }\n              }]), e;\n            }(),\n            N = function () {\n              function e(i, n) {\n                if (t(this, e), !Array.isArray(i)) throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n                try {\n                  \"number\" == typeof i[0][0][0] && (i = [i]);\n                } catch (s) {}\n                this.polys = [], this.bbox = {\n                  ll: {\n                    x: Number.POSITIVE_INFINITY,\n                    y: Number.POSITIVE_INFINITY\n                  },\n                  ur: {\n                    x: Number.NEGATIVE_INFINITY,\n                    y: Number.NEGATIVE_INFINITY\n                  }\n                };\n                for (var r = 0, a = i.length; r < a; r++) {\n                  var o = new G(i[r], this);\n                  o.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = o.bbox.ll.x), o.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = o.bbox.ll.y), o.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = o.bbox.ur.x), o.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = o.bbox.ur.y), this.polys.push(o);\n                }\n                this.isSubject = n;\n              }\n              return i(e, [{\n                key: \"getSweepEvents\",\n                value: function () {\n                  for (var t = [], e = 0, i = this.polys.length; e < i; e++) for (var n = this.polys[e].getSweepEvents(), r = 0, a = n.length; r < a; r++) t.push(n[r]);\n                  return t;\n                }\n              }]), e;\n            }(),\n            z = function () {\n              function e(i) {\n                t(this, e), this.events = i;\n                for (var n = 0, r = i.length; n < r; n++) i[n].segment.ringOut = this;\n                this.poly = null;\n              }\n              return i(e, null, [{\n                key: \"factory\",\n                value: function (t) {\n                  for (var i = [], n = 0, r = t.length; n < r; n++) {\n                    var a = t[n];\n                    if (a.isInResult() && !a.ringOut) {\n                      for (var o = null, s = a.leftSE, l = a.rightSE, h = [s], u = s.point, c = []; o = s, s = l, h.push(s), s.point !== u;) for (;;) {\n                        var p = s.getAvailableLinkedEvents();\n                        if (0 === p.length) {\n                          var d = h[0].point,\n                            f = h[h.length - 1].point;\n                          throw new Error(\"Unable to complete output ring starting at [\".concat(d.x, \",\") + \" \".concat(d.y, \"]. Last matching segment found ends at\") + \" [\".concat(f.x, \", \").concat(f.y, \"].\"));\n                        }\n                        if (1 === p.length) {\n                          l = p[0].otherSE;\n                          break;\n                        }\n                        for (var g = null, _ = 0, m = c.length; _ < m; _++) if (c[_].point === s.point) {\n                          g = _;\n                          break;\n                        }\n                        if (null === g) {\n                          c.push({\n                            index: h.length,\n                            point: s.point\n                          });\n                          var y = s.getLeftmostComparator(o);\n                          l = p.sort(y)[0].otherSE;\n                          break;\n                        }\n                        var v = c.splice(g)[0],\n                          L = h.splice(v.index);\n                        L.unshift(L[0].otherSE), i.push(new e(L.reverse()));\n                      }\n                      i.push(new e(h));\n                    }\n                  }\n                  return i;\n                }\n              }]), i(e, [{\n                key: \"getGeom\",\n                value: function () {\n                  for (var t = this.events[0].point, e = [t], i = 1, n = this.events.length - 1; i < n; i++) {\n                    var r = this.events[i].point,\n                      a = this.events[i + 1].point;\n                    0 !== P(r, t, a) && (e.push(r), t = r);\n                  }\n                  if (1 === e.length) return null;\n                  var o = e[0],\n                    s = e[1];\n                  0 === P(o, t, s) && e.shift(), e.push(e[0]);\n                  for (var l = this.isExteriorRing() ? 1 : -1, h = this.isExteriorRing() ? 0 : e.length - 1, u = this.isExteriorRing() ? e.length : -1, c = [], p = h; p != u; p += l) c.push([e[p].x, e[p].y]);\n                  return c;\n                }\n              }, {\n                key: \"isExteriorRing\",\n                value: function () {\n                  if (this._isExteriorRing === undefined) {\n                    var t = this.enclosingRing();\n                    this._isExteriorRing = !t || !t.isExteriorRing();\n                  }\n                  return this._isExteriorRing;\n                }\n              }, {\n                key: \"enclosingRing\",\n                value: function () {\n                  return this._enclosingRing === undefined && (this._enclosingRing = this._calcEnclosingRing()), this._enclosingRing;\n                }\n              }, {\n                key: \"_calcEnclosingRing\",\n                value: function () {\n                  for (var t = this.events[0], e = 1, i = this.events.length; e < i; e++) {\n                    var n = this.events[e];\n                    T.compare(t, n) > 0 && (t = n);\n                  }\n                  for (var r = t.segment.prevInResult(), a = r ? r.prevInResult() : null;;) {\n                    if (!r) return null;\n                    if (!a) return r.ringOut;\n                    if (a.ringOut !== r.ringOut) return a.ringOut.enclosingRing() !== r.ringOut ? r.ringOut : r.ringOut.enclosingRing();\n                    r = a.prevInResult(), a = r ? r.prevInResult() : null;\n                  }\n                }\n              }]), e;\n            }(),\n            F = function () {\n              function e(i) {\n                t(this, e), this.exteriorRing = i, i.poly = this, this.interiorRings = [];\n              }\n              return i(e, [{\n                key: \"addInterior\",\n                value: function (t) {\n                  this.interiorRings.push(t), t.poly = this;\n                }\n              }, {\n                key: \"getGeom\",\n                value: function () {\n                  var t = [this.exteriorRing.getGeom()];\n                  if (null === t[0]) return null;\n                  for (var e = 0, i = this.interiorRings.length; e < i; e++) {\n                    var n = this.interiorRings[e].getGeom();\n                    null !== n && t.push(n);\n                  }\n                  return t;\n                }\n              }]), e;\n            }(),\n            U = function () {\n              function e(i) {\n                t(this, e), this.rings = i, this.polys = this._composePolys(i);\n              }\n              return i(e, [{\n                key: \"getGeom\",\n                value: function () {\n                  for (var t = [], e = 0, i = this.polys.length; e < i; e++) {\n                    var n = this.polys[e].getGeom();\n                    null !== n && t.push(n);\n                  }\n                  return t;\n                }\n              }, {\n                key: \"_composePolys\",\n                value: function (t) {\n                  for (var e = [], i = 0, n = t.length; i < n; i++) {\n                    var r = t[i];\n                    if (!r.poly) if (r.isExteriorRing()) e.push(new F(r));else {\n                      var a = r.enclosingRing();\n                      a.poly || e.push(new F(a)), a.poly.addInterior(r);\n                    }\n                  }\n                  return e;\n                }\n              }]), e;\n            }(),\n            V = function () {\n              function e(i) {\n                var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : j.compare;\n                t(this, e), this.queue = i, this.tree = new u(n), this.segments = [];\n              }\n              return i(e, [{\n                key: \"process\",\n                value: function (t) {\n                  var e = t.segment,\n                    i = [];\n                  if (t.consumedBy) return t.isLeft ? this.queue.remove(t.otherSE) : this.tree.remove(e), i;\n                  var n = t.isLeft ? this.tree.insert(e) : this.tree.find(e);\n                  if (!n) throw new Error(\"Unable to find segment #\".concat(e.id, \" \") + \"[\".concat(e.leftSE.point.x, \", \").concat(e.leftSE.point.y, \"] -> \") + \"[\".concat(e.rightSE.point.x, \", \").concat(e.rightSE.point.y, \"] \") + \"in SweepLine tree. Please submit a bug report.\");\n                  for (var r = n, a = n, o = undefined, s = undefined; o === undefined;) null === (r = this.tree.prev(r)) ? o = null : r.key.consumedBy === undefined && (o = r.key);\n                  for (; s === undefined;) null === (a = this.tree.next(a)) ? s = null : a.key.consumedBy === undefined && (s = a.key);\n                  if (t.isLeft) {\n                    var l = null;\n                    if (o) {\n                      var h = o.getIntersection(e);\n                      if (null !== h && (e.isAnEndpoint(h) || (l = h), !o.isAnEndpoint(h))) for (var u = this._splitSafely(o, h), c = 0, p = u.length; c < p; c++) i.push(u[c]);\n                    }\n                    var d = null;\n                    if (s) {\n                      var f = s.getIntersection(e);\n                      if (null !== f && (e.isAnEndpoint(f) || (d = f), !s.isAnEndpoint(f))) for (var g = this._splitSafely(s, f), _ = 0, m = g.length; _ < m; _++) i.push(g[_]);\n                    }\n                    if (null !== l || null !== d) {\n                      var y = null;\n                      y = null === l ? d : null === d || T.comparePoints(l, d) <= 0 ? l : d, this.queue.remove(e.rightSE), i.push(e.rightSE);\n                      for (var v = e.split(y), L = 0, b = v.length; L < b; L++) i.push(v[L]);\n                    }\n                    i.length > 0 ? (this.tree.remove(e), i.push(t)) : (this.segments.push(e), e.prev = o);\n                  } else {\n                    if (o && s) {\n                      var k = o.getIntersection(s);\n                      if (null !== k) {\n                        if (!o.isAnEndpoint(k)) for (var M = this._splitSafely(o, k), x = 0, w = M.length; x < w; x++) i.push(M[x]);\n                        if (!s.isAnEndpoint(k)) for (var C = this._splitSafely(s, k), P = 0, E = C.length; P < E; P++) i.push(C[P]);\n                      }\n                    }\n                    this.tree.remove(e);\n                  }\n                  return i;\n                }\n              }, {\n                key: \"_splitSafely\",\n                value: function (t, e) {\n                  this.tree.remove(t);\n                  var i = t.rightSE;\n                  this.queue.remove(i);\n                  var n = t.split(e);\n                  return n.push(i), t.consumedBy === undefined && this.tree.insert(t), n;\n                }\n              }]), e;\n            }(),\n            K = \"undefined\" != typeof process && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6,\n            H = \"undefined\" != typeof process && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6,\n            q = new (function () {\n              function e() {\n                t(this, e);\n              }\n              return i(e, [{\n                key: \"run\",\n                value: function (t, e, i) {\n                  q.type = t, x.reset();\n                  for (var n = [new N(e, !0)], r = 0, a = i.length; r < a; r++) n.push(new N(i[r], !1));\n                  if (q.numMultiPolys = n.length, \"difference\" === q.type) for (var o = n[0], s = 1; s < n.length;) null !== y(n[s].bbox, o.bbox) ? s++ : n.splice(s, 1);\n                  if (\"intersection\" === q.type) for (var l = 0, h = n.length; l < h; l++) for (var c = n[l], p = l + 1, d = n.length; p < d; p++) if (null === y(c.bbox, n[p].bbox)) return [];\n                  for (var f = new u(T.compare), g = 0, _ = n.length; g < _; g++) for (var m = n[g].getSweepEvents(), v = 0, L = m.length; v < L; v++) if (f.insert(m[v]), f.size > K) throw new Error(\"Infinite loop when putting segment endpoints in a priority queue (queue size too big). Please file a bug report.\");\n                  for (var b = new V(f), k = f.size, M = f.pop(); M;) {\n                    var w = M.key;\n                    if (f.size === k) {\n                      var C = w.segment;\n                      throw new Error(\"Unable to pop() \".concat(w.isLeft ? \"left\" : \"right\", \" SweepEvent \") + \"[\".concat(w.point.x, \", \").concat(w.point.y, \"] from segment #\").concat(C.id, \" \") + \"[\".concat(C.leftSE.point.x, \", \").concat(C.leftSE.point.y, \"] -> \") + \"[\".concat(C.rightSE.point.x, \", \").concat(C.rightSE.point.y, \"] from queue. \") + \"Please file a bug report.\");\n                    }\n                    if (f.size > K) throw new Error(\"Infinite loop when passing sweep line over endpoints (queue size too big). Please file a bug report.\");\n                    if (b.segments.length > H) throw new Error(\"Infinite loop when passing sweep line over endpoints (too many sweep line segments). Please file a bug report.\");\n                    for (var P = b.process(w), E = 0, S = P.length; E < S; E++) {\n                      var O = P[E];\n                      O.consumedBy === undefined && f.insert(O);\n                    }\n                    k = f.size, M = f.pop();\n                  }\n                  x.reset();\n                  var D = z.factory(b.segments);\n                  return new U(D).getGeom();\n                }\n              }]), e;\n            }())(),\n            J = function (t) {\n              for (var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) i[n - 1] = arguments[n];\n              return q.run(\"union\", t, i);\n            },\n            Y = function (t) {\n              for (var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) i[n - 1] = arguments[n];\n              return q.run(\"intersection\", t, i);\n            },\n            X = function (t) {\n              for (var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) i[n - 1] = arguments[n];\n              return q.run(\"xor\", t, i);\n            },\n            Z = function (t) {\n              for (var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) i[n - 1] = arguments[n];\n              return q.run(\"difference\", t, i);\n            };\n          return {\n            union: J,\n            intersection: Y,\n            xor: X,\n            difference: Z\n          };\n        }();\n      },\n      2582: function (t) {\n        t.exports = function () {\n          \"use strict\";\n\n          function t(t, n, r, a, o) {\n            !function s(t, i, n, r, a) {\n              for (; r > n;) {\n                if (r - n > 600) {\n                  var o = r - n + 1,\n                    l = i - n + 1,\n                    h = Math.log(o),\n                    u = .5 * Math.exp(2 * h / 3),\n                    c = .5 * Math.sqrt(h * u * (o - u) / o) * (l - o / 2 < 0 ? -1 : 1);\n                  s(t, i, Math.max(n, Math.floor(i - l * u / o + c)), Math.min(r, Math.floor(i + (o - l) * u / o + c)), a);\n                }\n                var p = t[i],\n                  d = n,\n                  f = r;\n                for (e(t, n, i), a(t[r], p) > 0 && e(t, n, r); d < f;) {\n                  for (e(t, d, f), d++, f--; a(t[d], p) < 0;) d++;\n                  for (; a(t[f], p) > 0;) f--;\n                }\n                0 === a(t[n], p) ? e(t, n, f) : e(t, ++f, r), f <= i && (n = f + 1), i <= f && (r = f - 1);\n              }\n            }(t, n, r || 0, a || t.length - 1, o || i);\n          }\n          function e(t, e, i) {\n            var n = t[e];\n            t[e] = t[i], t[i] = n;\n          }\n          function i(t, e) {\n            return t < e ? -1 : t > e ? 1 : 0;\n          }\n          var n = function (t) {\n            void 0 === t && (t = 9), this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)), this.clear();\n          };\n          function r(t, e, i) {\n            if (!i) return e.indexOf(t);\n            for (var n = 0; n < e.length; n++) if (i(t, e[n])) return n;\n            return -1;\n          }\n          function a(t, e) {\n            o(t, 0, t.children.length, e, t);\n          }\n          function o(t, e, i, n, r) {\n            r || (r = f(null)), r.minX = 1 / 0, r.minY = 1 / 0, r.maxX = -1 / 0, r.maxY = -1 / 0;\n            for (var a = e; a < i; a++) {\n              var o = t.children[a];\n              s(r, t.leaf ? n(o) : o);\n            }\n            return r;\n          }\n          function s(t, e) {\n            return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t;\n          }\n          function l(t, e) {\n            return t.minX - e.minX;\n          }\n          function h(t, e) {\n            return t.minY - e.minY;\n          }\n          function u(t) {\n            return (t.maxX - t.minX) * (t.maxY - t.minY);\n          }\n          function c(t) {\n            return t.maxX - t.minX + (t.maxY - t.minY);\n          }\n          function p(t, e) {\n            return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY;\n          }\n          function d(t, e) {\n            return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY;\n          }\n          function f(t) {\n            return {\n              children: t,\n              height: 1,\n              leaf: !0,\n              minX: 1 / 0,\n              minY: 1 / 0,\n              maxX: -1 / 0,\n              maxY: -1 / 0\n            };\n          }\n          function g(e, i, n, r, a) {\n            for (var o = [i, n]; o.length;) if (!((n = o.pop()) - (i = o.pop()) <= r)) {\n              var s = i + Math.ceil((n - i) / r / 2) * r;\n              t(e, s, i, n, a), o.push(i, s, s, n);\n            }\n          }\n          return n.prototype.all = function () {\n            return this._all(this.data, []);\n          }, n.prototype.search = function (t) {\n            var e = this.data,\n              i = [];\n            if (!d(t, e)) return i;\n            for (var n = this.toBBox, r = []; e;) {\n              for (var a = 0; a < e.children.length; a++) {\n                var o = e.children[a],\n                  s = e.leaf ? n(o) : o;\n                d(t, s) && (e.leaf ? i.push(o) : p(t, s) ? this._all(o, i) : r.push(o));\n              }\n              e = r.pop();\n            }\n            return i;\n          }, n.prototype.collides = function (t) {\n            var e = this.data;\n            if (!d(t, e)) return !1;\n            for (var i = []; e;) {\n              for (var n = 0; n < e.children.length; n++) {\n                var r = e.children[n],\n                  a = e.leaf ? this.toBBox(r) : r;\n                if (d(t, a)) {\n                  if (e.leaf || p(t, a)) return !0;\n                  i.push(r);\n                }\n              }\n              e = i.pop();\n            }\n            return !1;\n          }, n.prototype.load = function (t) {\n            if (!t || !t.length) return this;\n            if (t.length < this._minEntries) {\n              for (var e = 0; e < t.length; e++) this.insert(t[e]);\n              return this;\n            }\n            var i = this._build(t.slice(), 0, t.length - 1, 0);\n            if (this.data.children.length) {\n              if (this.data.height === i.height) this._splitRoot(this.data, i);else {\n                if (this.data.height < i.height) {\n                  var n = this.data;\n                  this.data = i, i = n;\n                }\n                this._insert(i, this.data.height - i.height - 1, !0);\n              }\n            } else this.data = i;\n            return this;\n          }, n.prototype.insert = function (t) {\n            return t && this._insert(t, this.data.height - 1), this;\n          }, n.prototype.clear = function () {\n            return this.data = f([]), this;\n          }, n.prototype.remove = function (t, e) {\n            if (!t) return this;\n            for (var i, n, a, o = this.data, s = this.toBBox(t), l = [], h = []; o || l.length;) {\n              if (o || (o = l.pop(), n = l[l.length - 1], i = h.pop(), a = !0), o.leaf) {\n                var u = r(t, o.children, e);\n                if (-1 !== u) return o.children.splice(u, 1), l.push(o), this._condense(l), this;\n              }\n              a || o.leaf || !p(o, s) ? n ? (i++, o = n.children[i], a = !1) : o = null : (l.push(o), h.push(i), i = 0, n = o, o = o.children[0]);\n            }\n            return this;\n          }, n.prototype.toBBox = function (t) {\n            return t;\n          }, n.prototype.compareMinX = function (t, e) {\n            return t.minX - e.minX;\n          }, n.prototype.compareMinY = function (t, e) {\n            return t.minY - e.minY;\n          }, n.prototype.toJSON = function () {\n            return this.data;\n          }, n.prototype.fromJSON = function (t) {\n            return this.data = t, this;\n          }, n.prototype._all = function (t, e) {\n            for (var i = []; t;) t.leaf ? e.push.apply(e, t.children) : i.push.apply(i, t.children), t = i.pop();\n            return e;\n          }, n.prototype._build = function (t, e, i, n) {\n            var r,\n              o = i - e + 1,\n              s = this._maxEntries;\n            if (o <= s) return a(r = f(t.slice(e, i + 1)), this.toBBox), r;\n            n || (n = Math.ceil(Math.log(o) / Math.log(s)), s = Math.ceil(o / Math.pow(s, n - 1))), (r = f([])).leaf = !1, r.height = n;\n            var l = Math.ceil(o / s),\n              h = l * Math.ceil(Math.sqrt(s));\n            g(t, e, i, h, this.compareMinX);\n            for (var u = e; u <= i; u += h) {\n              var c = Math.min(u + h - 1, i);\n              g(t, u, c, l, this.compareMinY);\n              for (var p = u; p <= c; p += l) {\n                var d = Math.min(p + l - 1, c);\n                r.children.push(this._build(t, p, d, n - 1));\n              }\n            }\n            return a(r, this.toBBox), r;\n          }, n.prototype._chooseSubtree = function (t, e, i, n) {\n            for (; n.push(e), !e.leaf && n.length - 1 !== i;) {\n              for (var r = 1 / 0, a = 1 / 0, o = void 0, s = 0; s < e.children.length; s++) {\n                var l = e.children[s],\n                  h = u(l),\n                  c = (p = t, d = l, (Math.max(d.maxX, p.maxX) - Math.min(d.minX, p.minX)) * (Math.max(d.maxY, p.maxY) - Math.min(d.minY, p.minY)) - h);\n                c < a ? (a = c, r = h < r ? h : r, o = l) : c === a && h < r && (r = h, o = l);\n              }\n              e = o || e.children[0];\n            }\n            var p, d;\n            return e;\n          }, n.prototype._insert = function (t, e, i) {\n            var n = i ? t : this.toBBox(t),\n              r = [],\n              a = this._chooseSubtree(n, this.data, e, r);\n            for (a.children.push(t), s(a, n); e >= 0 && r[e].children.length > this._maxEntries;) this._split(r, e), e--;\n            this._adjustParentBBoxes(n, r, e);\n          }, n.prototype._split = function (t, e) {\n            var i = t[e],\n              n = i.children.length,\n              r = this._minEntries;\n            this._chooseSplitAxis(i, r, n);\n            var o = this._chooseSplitIndex(i, r, n),\n              s = f(i.children.splice(o, i.children.length - o));\n            s.height = i.height, s.leaf = i.leaf, a(i, this.toBBox), a(s, this.toBBox), e ? t[e - 1].children.push(s) : this._splitRoot(i, s);\n          }, n.prototype._splitRoot = function (t, e) {\n            this.data = f([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, a(this.data, this.toBBox);\n          }, n.prototype._chooseSplitIndex = function (t, e, i) {\n            for (var n, r, a, s, l, h, c, p = 1 / 0, d = 1 / 0, f = e; f <= i - e; f++) {\n              var g = o(t, 0, f, this.toBBox),\n                _ = o(t, f, i, this.toBBox),\n                m = (r = g, a = _, s = void 0, l = void 0, h = void 0, c = void 0, s = Math.max(r.minX, a.minX), l = Math.max(r.minY, a.minY), h = Math.min(r.maxX, a.maxX), c = Math.min(r.maxY, a.maxY), Math.max(0, h - s) * Math.max(0, c - l)),\n                y = u(g) + u(_);\n              m < p ? (p = m, n = f, d = y < d ? y : d) : m === p && y < d && (d = y, n = f);\n            }\n            return n || i - e;\n          }, n.prototype._chooseSplitAxis = function (t, e, i) {\n            var n = t.leaf ? this.compareMinX : l,\n              r = t.leaf ? this.compareMinY : h;\n            this._allDistMargin(t, e, i, n) < this._allDistMargin(t, e, i, r) && t.children.sort(n);\n          }, n.prototype._allDistMargin = function (t, e, i, n) {\n            t.children.sort(n);\n            for (var r = this.toBBox, a = o(t, 0, e, r), l = o(t, i - e, i, r), h = c(a) + c(l), u = e; u < i - e; u++) {\n              var p = t.children[u];\n              s(a, t.leaf ? r(p) : p), h += c(a);\n            }\n            for (var d = i - e - 1; d >= e; d--) {\n              var f = t.children[d];\n              s(l, t.leaf ? r(f) : f), h += c(l);\n            }\n            return h;\n          }, n.prototype._adjustParentBBoxes = function (t, e, i) {\n            for (var n = i; n >= 0; n--) s(e[n], t);\n          }, n.prototype._condense = function (t) {\n            for (var e = t.length - 1, i = void 0; e >= 0; e--) 0 === t[e].children.length ? e > 0 ? (i = t[e - 1].children).splice(i.indexOf(t[e]), 1) : this.clear() : a(t[e], this.toBBox);\n          }, n;\n        }();\n      }\n    },\n    e = {};\n  function i(n) {\n    var r = e[n];\n    if (r !== undefined) return r.exports;\n    var a = e[n] = {\n      id: n,\n      loaded: !1,\n      exports: {}\n    };\n    return t[n].call(a.exports, a, a.exports, i), a.loaded = !0, a.exports;\n  }\n  i.n = t => {\n    var e = t && t.__esModule ? () => t[\"default\"] : () => t;\n    return i.d(e, {\n      a: e\n    }), e;\n  }, i.d = (t, e) => {\n    for (var n in e) i.o(e, n) && !i.o(t, n) && Object.defineProperty(t, n, {\n      enumerable: !0,\n      get: e[n]\n    });\n  }, i.g = function () {\n    if (\"object\" == typeof globalThis) return globalThis;\n    try {\n      return this || new Function(\"return this\")();\n    } catch (t) {\n      if (\"object\" == typeof window) return window;\n    }\n  }(), i.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), i.nmd = t => (t.paths = [], t.children || (t.children = []), t);\n  i(5975);\n})();","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}