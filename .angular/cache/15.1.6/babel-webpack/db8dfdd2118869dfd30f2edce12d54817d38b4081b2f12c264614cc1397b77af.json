{"ast":null,"code":"import { LeafletMap } from '@acpaas-ui/ngx-leaflet';\nimport { Subject } from 'rxjs';\nimport { GeometryTypes } from '../types/geometry-types.enum';\nimport { PopupEvents } from '../types/leaflet.types';\nexport class LocationViewerMap extends LeafletMap {\n  constructor(options, mapService) {\n    super(options, mapService);\n    this.filterLayerClicked = new Subject();\n  }\n  // Supporting layer\n  addSupportingLayers(mapserverUrl, layerIds) {\n    if (this.mapService.isAvailable()) {\n      this.removeLayer(this.supportingLayer);\n      this.supportingLayer = new this.mapService.esri.dynamicMapLayer({\n        maxZoom: 20,\n        minZoom: 0,\n        url: mapserverUrl,\n        opacity: 1,\n        layers: layerIds,\n        continuousWorld: true,\n        useCors: false,\n        f: 'image'\n      }).addTo(this.map);\n    }\n    return this.supportingLayer;\n  }\n  // Removes layer\n  removeLayer(layer) {\n    if (this.mapService.isAvailable() && layer) {\n      this.map.removeLayer(layer);\n    }\n  }\n  // Supportinglayer will only show the provided layerids\n  setVisibleLayersSupportingLayer(ids) {\n    if (this.mapService.isAvailable() && this.supportingLayer) {\n      this.supportingLayer.setLayers(ids);\n    }\n  }\n  addOperationalLayer(operationalLayerOptions, layer, defaultDisplayField) {\n    if (this.mapService.isAvailable()) {\n      this.removeLayer(this.operationalLayer);\n      let featureLayerOptions = {\n        url: `${operationalLayerOptions.url}/${operationalLayerOptions.layerId}/query`,\n        minZoom: operationalLayerOptions.minZoom,\n        maxZoom: operationalLayerOptions.maxZoom,\n        style: null,\n        pointToLayer: null,\n        onEachFeature: (feature, layer) => {\n          if (operationalLayerOptions.showTooltip) {\n            layer.bindTooltip(this.mapService.L.Util.template(`{${defaultDisplayField}}`, feature.properties));\n          }\n        }\n      };\n      if (layer.geometryType === GeometryTypes.esriGeometryPolygon || layer.geometryType === GeometryTypes.esriGeometryPolyline) {\n        // style is used to style lines and polygons\n        featureLayerOptions.style = feature => {\n          if (layer.colors && layer.colors.length > 0) {\n            let colorItem = layer.colors[0];\n            // check if more coloritems are avaiable to check for custom style by value\n            if (layer.colors.length > 1) {\n              const colorValue = feature.properties[layer.styleField];\n              colorItem = layer.colors.find(x => x.value === colorValue);\n            }\n            return Object.assign(Object.assign({}, colorItem), operationalLayerOptions.layerColor);\n          }\n        };\n      } else {\n        // point to layer method is used to style points\n        featureLayerOptions.pointToLayer = (feature, latlng) => {\n          const legendValue = feature.properties[layer.styleField];\n          const legendItem = layer.legend.find(x => x.values && x.values.includes(legendValue));\n          let iconUrl = '';\n          if (legendItem) {\n            iconUrl = `data:${legendItem.contentType};base64, ${legendItem.imageData}`;\n          } else {\n            iconUrl = `data:${layer.legend[0].contentType};base64, ${layer.legend[0].imageData}`;\n          }\n          const icon = this.mapService.L.icon({\n            iconUrl,\n            iconAnchor: [10, 10]\n          });\n          return this.mapService.L.marker(latlng, {\n            icon\n          });\n        };\n      }\n      if (operationalLayerOptions.where != null) featureLayerOptions.where = operationalLayerOptions.where;\n      if (operationalLayerOptions.enableClustering) {\n        this.operationalLayer = new this.mapService.esri.Cluster.featureLayer(featureLayerOptions);\n      } else {\n        this.operationalLayer = this.mapService.esri.featureLayer(featureLayerOptions);\n      }\n      //update layer visibility\n      if (operationalLayerOptions.isVisible != null) layer.visible = operationalLayerOptions.isVisible;\n      if (layer.visible) {\n        this.map.addLayer(this.operationalLayer);\n      }\n    }\n  }\n  addOperationalMarkers(markers, enableClustering) {\n    if (this.mapService.isAvailable()) {\n      this.removeLayer(this.operationalLayer);\n      if (enableClustering) {\n        this.operationalLayer = this.mapService.L.markerClusterGroup();\n      } else {\n        this.operationalLayer = this.mapService.L.featureGroup();\n      }\n      markers.forEach(marker => {\n        if (marker.coordinate && marker.coordinate.lat && marker.coordinate.lon) {\n          const htmlIcon = this.getHtmlMarker(marker.color, marker.icon ? `ai-${marker.icon}` : undefined, marker.size, undefined);\n          const icon = this.mapService.L.divIcon({\n            html: htmlIcon,\n            className: 'aui-leaflet__html-icon'\n          });\n          const leafletMarker = this.mapService.L.marker([marker.coordinate.lat, marker.coordinate.lon], {\n            icon\n          });\n          leafletMarker.options.data = marker.data;\n          this.operationalLayer.addLayer(leafletMarker);\n        }\n      });\n      this.map.addLayer(this.operationalLayer);\n    }\n  }\n  setVisibilityOperationalLayer(visible) {\n    if (this.mapService.isAvailable && this.operationalLayer) {\n      this.setVisibilityLayer(this.operationalLayer, visible);\n    }\n  }\n  addFilterLayer(filterLayerOptions) {\n    if (this.mapService.isAvailable()) {\n      this.removeLayer(this.filterLayer);\n      this.filterLayer = this.mapService.esri.featureLayer({\n        url: `${filterLayerOptions.url}/${filterLayerOptions.layerId}/query`,\n        onEachFeature: (feature, layerProp) => {\n          layerProp.on('click', e => {\n            this.filterLayerClicked.next(e);\n          });\n        }\n      }).bindPopup(layerInfo => {\n        return this.mapService.L.Util.template(`<p>${filterLayerOptions.popupLabel}: {${filterLayerOptions.propertyToDisplay}}</p>`, layerInfo.feature.properties);\n      }, {\n        closeButton: false\n      });\n      // removes default click behaviour ==> opening popup\n      this.filterLayer.off('click');\n      this.filterLayer.on('mouseover', e => {\n        this.filterLayer.openPopup(e.layer || e.target);\n      });\n    }\n  }\n  setVisibilityFilterLayer(visible) {\n    if (this.mapService.isAvailable && this.filterLayer) {\n      this.setVisibilityLayer(this.filterLayer, visible);\n      setTimeout(() => {\n        this.filterLayer.closePopup();\n      }, 200);\n    }\n  }\n  // adds Popup to layer\n  addPopupToLayer(layer, popupContent, onCloseRemoveLayer, extraLayer = null) {\n    const popup = layer.bindPopup(() => {\n      return this.mapService.L.Util.template(popupContent);\n    });\n    if (onCloseRemoveLayer) {\n      popup.on(PopupEvents.popupclose, () => {\n        this.map.removeLayer(layer);\n        if (extraLayer) {\n          this.map.removeLayer(extraLayer);\n        }\n      });\n    }\n    layer.openPopup();\n  }\n  /**\n   * Defines the custom marker markup.\n   */\n  getHtmlMarker(color = '#0057b7', icon = 'ai-pin-3', size = '40px', position = {\n    top: '-36px',\n    left: '-5px'\n  }) {\n    const markerStyle = `color: ${color}; font-size: ${size}; top: ${position.top}; left: ${position.left}`;\n    const markerIcon = `<svg aria-hidden=\"true\"><use href=\"#${icon}\" /></svg>`;\n    return `<span style=\"${markerStyle}\" class=\"ai ngx-location-viewer-marker\">${markerIcon}</span>`;\n  }\n  setVisibilityLayer(layer, visible) {\n    if (visible) {\n      if (!this.map.hasLayer(layer)) {\n        this.map.addLayer(layer);\n      }\n    } else {\n      this.map.removeLayer(layer);\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}