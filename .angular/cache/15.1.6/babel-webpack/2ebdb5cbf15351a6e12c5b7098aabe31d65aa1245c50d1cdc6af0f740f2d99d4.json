{"ast":null,"code":"import { Util } from 'leaflet';\nimport { RasterLayer } from './RasterLayer';\nimport { getUrlParams } from '../Util';\nimport imageService from '../Services/ImageService';\nexport var ImageMapLayer = RasterLayer.extend({\n  options: {\n    updateInterval: 150,\n    format: 'jpgpng',\n    transparent: true,\n    f: 'image'\n  },\n  query: function () {\n    return this.service.query();\n  },\n  identify: function () {\n    return this.service.identify();\n  },\n  initialize: function (options) {\n    options = getUrlParams(options);\n    this.service = imageService(options);\n    this.service.addEventParent(this);\n    Util.setOptions(this, options);\n  },\n  setPixelType: function (pixelType) {\n    this.options.pixelType = pixelType;\n    this._update();\n    return this;\n  },\n  getPixelType: function () {\n    return this.options.pixelType;\n  },\n  setBandIds: function (bandIds) {\n    if (Util.isArray(bandIds)) {\n      this.options.bandIds = bandIds.join(',');\n    } else {\n      this.options.bandIds = bandIds.toString();\n    }\n    this._update();\n    return this;\n  },\n  getBandIds: function () {\n    return this.options.bandIds;\n  },\n  setNoData: function (noData, noDataInterpretation) {\n    if (Util.isArray(noData)) {\n      this.options.noData = noData.join(',');\n    } else {\n      this.options.noData = noData.toString();\n    }\n    if (noDataInterpretation) {\n      this.options.noDataInterpretation = noDataInterpretation;\n    }\n    this._update();\n    return this;\n  },\n  getNoData: function () {\n    return this.options.noData;\n  },\n  getNoDataInterpretation: function () {\n    return this.options.noDataInterpretation;\n  },\n  setRenderingRule: function (renderingRule) {\n    this.options.renderingRule = renderingRule;\n    this._update();\n  },\n  getRenderingRule: function () {\n    return this.options.renderingRule;\n  },\n  setMosaicRule: function (mosaicRule) {\n    this.options.mosaicRule = mosaicRule;\n    this._update();\n  },\n  getMosaicRule: function () {\n    return this.options.mosaicRule;\n  },\n  _getPopupData: function (e) {\n    var callback = Util.bind(function (error, results, response) {\n      if (error) {\n        return;\n      } // we really can't do anything here but authenticate or requesterror will fire\n      setTimeout(Util.bind(function () {\n        this._renderPopup(e.latlng, error, results, response);\n      }, this), 300);\n    }, this);\n    var identifyRequest = this.identify().at(e.latlng);\n\n    // set mosaic rule for identify task if it is set for layer\n    if (this.options.mosaicRule) {\n      identifyRequest.setMosaicRule(this.options.mosaicRule);\n      // @TODO: force return catalog items too?\n    }\n\n    // @TODO: set rendering rule? Not sure,\n    // sometimes you want raw pixel values\n    // if (this.options.renderingRule) {\n    //   identifyRequest.setRenderingRule(this.options.renderingRule);\n    // }\n\n    identifyRequest.run(callback);\n\n    // set the flags to show the popup\n    this._shouldRenderPopup = true;\n    this._lastClick = e.latlng;\n  },\n  _buildExportParams: function () {\n    var sr = parseInt(this._map.options.crs.code.split(':')[1], 10);\n    var params = {\n      bbox: this._calculateBbox(),\n      size: this._calculateImageSize(),\n      format: this.options.format,\n      transparent: this.options.transparent,\n      bboxSR: sr,\n      imageSR: sr\n    };\n    if (this.options.from && this.options.to) {\n      params.time = this.options.from.valueOf() + ',' + this.options.to.valueOf();\n    }\n    if (this.options.pixelType) {\n      params.pixelType = this.options.pixelType;\n    }\n    if (this.options.interpolation) {\n      params.interpolation = this.options.interpolation;\n    }\n    if (this.options.compressionQuality) {\n      params.compressionQuality = this.options.compressionQuality;\n    }\n    if (this.options.bandIds) {\n      params.bandIds = this.options.bandIds;\n    }\n\n    // 0 is falsy *and* a valid input parameter\n    if (this.options.noData === 0 || this.options.noData) {\n      params.noData = this.options.noData;\n    }\n    if (this.options.noDataInterpretation) {\n      params.noDataInterpretation = this.options.noDataInterpretation;\n    }\n    if (this.service.options.token) {\n      params.token = this.service.options.token;\n    }\n    if (this.options.renderingRule) {\n      params.renderingRule = JSON.stringify(this.options.renderingRule);\n    }\n    if (this.options.mosaicRule) {\n      params.mosaicRule = JSON.stringify(this.options.mosaicRule);\n    }\n    return params;\n  },\n  _requestExport: function (params, bounds) {\n    if (this.options.f === 'json') {\n      this.service.request('exportImage', params, function (error, response) {\n        if (error) {\n          return;\n        } // we really can't do anything here but authenticate or requesterror will fire\n        if (this.options.token) {\n          response.href += '?token=' + this.options.token;\n        }\n        if (this.options.proxy) {\n          response.href = this.options.proxy + '?' + response.href;\n        }\n        this._renderImage(response.href, bounds);\n      }, this);\n    } else {\n      params.f = 'image';\n      var fullUrl = this.options.url + 'exportImage' + Util.getParamString(params);\n      if (this.options.proxy) {\n        fullUrl = this.options.proxy + '?' + fullUrl;\n      }\n      this._renderImage(fullUrl, bounds);\n    }\n  }\n});\nexport function imageMapLayer(url, options) {\n  return new ImageMapLayer(url, options);\n}\nexport default imageMapLayer;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}