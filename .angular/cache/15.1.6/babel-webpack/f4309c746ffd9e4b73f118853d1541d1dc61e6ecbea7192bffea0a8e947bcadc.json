{"ast":null,"code":"import { Util } from 'leaflet';\nimport featureLayerService from '../../Services/FeatureLayerService';\nimport { getUrlParams, warn, setEsriAttribution, removeEsriAttribution } from '../../Util';\nimport { FeatureGrid } from './FeatureGrid';\nimport BinarySearchIndex from 'tiny-binary-search';\nexport var FeatureManager = FeatureGrid.extend({\n  /**\r\n   * Options\r\n   */\n\n  options: {\n    attribution: null,\n    where: '1=1',\n    fields: ['*'],\n    from: false,\n    to: false,\n    timeField: false,\n    timeFilterMode: 'server',\n    simplifyFactor: 0,\n    precision: 6,\n    fetchAllFeatures: false\n  },\n  /**\r\n   * Constructor\r\n   */\n\n  initialize: function (options) {\n    FeatureGrid.prototype.initialize.call(this, options);\n    options = getUrlParams(options);\n    options = Util.setOptions(this, options);\n    this.service = featureLayerService(options);\n    this.service.addEventParent(this);\n\n    // use case insensitive regex to look for common fieldnames used for indexing\n    if (this.options.fields[0] !== '*') {\n      var oidCheck = false;\n      for (var i = 0; i < this.options.fields.length; i++) {\n        if (this.options.fields[i].match(/^(OBJECTID|FID|OID|ID)$/i)) {\n          oidCheck = true;\n        }\n      }\n      if (oidCheck === false) {\n        warn('no known esriFieldTypeOID field detected in fields Array.  Please add an attribute field containing unique IDs to ensure the layer can be drawn correctly.');\n      }\n    }\n    if (this.options.timeField.start && this.options.timeField.end) {\n      this._startTimeIndex = new BinarySearchIndex();\n      this._endTimeIndex = new BinarySearchIndex();\n    } else if (this.options.timeField) {\n      this._timeIndex = new BinarySearchIndex();\n    }\n    this._cache = {};\n    this._currentSnapshot = []; // cache of what layers should be active\n    this._activeRequests = 0;\n  },\n  /**\r\n   * Layer Interface\r\n   */\n\n  onAdd: function (map) {\n    // include 'Powered by Esri' in map attribution\n    setEsriAttribution(map);\n    this.service.metadata(function (err, metadata) {\n      if (!err) {\n        var supportedFormats = metadata.supportedQueryFormats;\n\n        // Check if someone has requested that we don't use geoJSON, even if it's available\n        var forceJsonFormat = false;\n        if (this.service.options.isModern === false || this.options.fetchAllFeatures) {\n          forceJsonFormat = true;\n        }\n\n        // Unless we've been told otherwise, check to see whether service can emit GeoJSON natively\n        if (!forceJsonFormat && supportedFormats && supportedFormats.indexOf('geoJSON') !== -1) {\n          this.service.options.isModern = true;\n        }\n        if (metadata.objectIdField) {\n          this.service.options.idAttribute = metadata.objectIdField;\n        }\n\n        // add copyright text listed in service metadata\n        if (!this.options.attribution && map.attributionControl && metadata.copyrightText) {\n          this.options.attribution = metadata.copyrightText;\n          map.attributionControl.addAttribution(this.getAttribution());\n        }\n      }\n    }, this);\n    map.on('zoomend', this._handleZoomChange, this);\n    return FeatureGrid.prototype.onAdd.call(this, map);\n  },\n  onRemove: function (map) {\n    removeEsriAttribution(map);\n    map.off('zoomend', this._handleZoomChange, this);\n    return FeatureGrid.prototype.onRemove.call(this, map);\n  },\n  getAttribution: function () {\n    return this.options.attribution;\n  },\n  /**\r\n   * Feature Management\r\n   */\n\n  createCell: function (bounds, coords) {\n    // dont fetch features outside the scale range defined for the layer\n    if (this._visibleZoom()) {\n      this._requestFeatures(bounds, coords);\n    }\n  },\n  _requestFeatures: function (bounds, coords, callback, offset) {\n    this._activeRequests++;\n\n    // default param\n    offset = offset || 0;\n    var originalWhere = this.options.where;\n\n    // our first active request fires loading\n    if (this._activeRequests === 1) {\n      this.fire('loading', {\n        bounds: bounds\n      }, true);\n    }\n    return this._buildQuery(bounds, offset).run(function (error, featureCollection, response) {\n      if (response && response.exceededTransferLimit) {\n        this.fire('drawlimitexceeded');\n      }\n\n      // the where changed while this request was being run so don't it.\n      if (this.options.where !== originalWhere) {\n        return;\n      }\n\n      // no error, features\n      if (!error && featureCollection && featureCollection.features.length) {\n        // schedule adding features until the next animation frame\n        Util.requestAnimFrame(Util.bind(function () {\n          this._addFeatures(featureCollection.features, coords);\n          this._postProcessFeatures(bounds);\n        }, this));\n      }\n\n      // no error, no features\n      if (!error && featureCollection && !featureCollection.features.length) {\n        this._postProcessFeatures(bounds);\n      }\n      if (error) {\n        this._postProcessFeatures(bounds);\n      }\n      if (callback) {\n        callback.call(this, error, featureCollection);\n      }\n      if (response && (response.exceededTransferLimit || response.properties && response.properties.exceededTransferLimit) && this.options.fetchAllFeatures) {\n        this._requestFeatures(bounds, coords, callback, offset + featureCollection.features.length);\n      }\n    }, this);\n  },\n  _postProcessFeatures: function (bounds) {\n    // deincrement the request counter now that we have processed features\n    this._activeRequests--;\n\n    // if there are no more active requests fire a load event for this view\n    if (this._activeRequests <= 0) {\n      this.fire('load', {\n        bounds: bounds\n      });\n    }\n  },\n  _cacheKey: function (coords) {\n    return coords.z + ':' + coords.x + ':' + coords.y;\n  },\n  _addFeatures: function (features, coords) {\n    // coords is optional - will be false if coming from addFeatures() function\n    if (coords) {\n      var key = this._cacheKey(coords);\n      this._cache[key] = this._cache[key] || [];\n    }\n    for (var i = features.length - 1; i >= 0; i--) {\n      var id = features[i].id;\n      if (this._currentSnapshot.indexOf(id) === -1) {\n        this._currentSnapshot.push(id);\n      }\n      if (typeof key !== 'undefined' && this._cache[key].indexOf(id) === -1) {\n        this._cache[key].push(id);\n      }\n    }\n    if (this.options.timeField) {\n      this._buildTimeIndexes(features);\n    }\n    this.createLayers(features);\n  },\n  _buildQuery: function (bounds, offset) {\n    var query = this.service.query().intersects(bounds).where(this.options.where).fields(this.options.fields).precision(this.options.precision);\n    if (this.options.fetchAllFeatures && !isNaN(parseInt(offset))) {\n      query = query.offset(offset);\n    }\n    query.params['resultType'] = 'tile';\n    if (this.options.requestParams) {\n      Util.extend(query.params, this.options.requestParams);\n    }\n    if (this.options.simplifyFactor) {\n      query.simplify(this._map, this.options.simplifyFactor);\n    }\n    if (this.options.timeFilterMode === 'server' && this.options.from && this.options.to) {\n      query.between(this.options.from, this.options.to);\n    }\n    return query;\n  },\n  /**\r\n   * Where Methods\r\n   */\n\n  setWhere: function (where, callback, context) {\n    this.options.where = where && where.length ? where : '1=1';\n    var oldSnapshot = [];\n    var newSnapshot = [];\n    var pendingRequests = 0;\n    var requestError = null;\n    var requestCallback = Util.bind(function (error, featureCollection) {\n      if (error) {\n        requestError = error;\n      }\n      if (featureCollection) {\n        for (var i = featureCollection.features.length - 1; i >= 0; i--) {\n          newSnapshot.push(featureCollection.features[i].id);\n        }\n      }\n      pendingRequests--;\n      if (pendingRequests <= 0 && this._visibleZoom() && where === this.options.where // the where is still the same so use this one\n      ) {\n        this._currentSnapshot = newSnapshot;\n        // schedule adding features for the next animation frame\n        Util.requestAnimFrame(Util.bind(function () {\n          this.removeLayers(oldSnapshot);\n          this.addLayers(newSnapshot);\n          if (callback) {\n            callback.call(context, requestError);\n          }\n        }, this));\n      }\n    }, this);\n    for (var i = this._currentSnapshot.length - 1; i >= 0; i--) {\n      oldSnapshot.push(this._currentSnapshot[i]);\n    }\n    this._cache = {};\n    for (var key in this._cells) {\n      pendingRequests++;\n      var coords = this._keyToCellCoords(key);\n      var bounds = this._cellCoordsToBounds(coords);\n      this._requestFeatures(bounds, coords, requestCallback);\n    }\n    return this;\n  },\n  getWhere: function () {\n    return this.options.where;\n  },\n  /**\r\n   * Time Range Methods\r\n   */\n\n  getTimeRange: function () {\n    return [this.options.from, this.options.to];\n  },\n  setTimeRange: function (from, to, callback, context) {\n    var oldFrom = this.options.from;\n    var oldTo = this.options.to;\n    var pendingRequests = 0;\n    var requestError = null;\n    var requestCallback = Util.bind(function (error) {\n      if (error) {\n        requestError = error;\n      }\n      this._filterExistingFeatures(oldFrom, oldTo, from, to);\n      pendingRequests--;\n      if (callback && pendingRequests <= 0) {\n        callback.call(context, requestError);\n      }\n    }, this);\n    this.options.from = from;\n    this.options.to = to;\n    this._filterExistingFeatures(oldFrom, oldTo, from, to);\n    if (this.options.timeFilterMode === 'server') {\n      for (var key in this._cells) {\n        pendingRequests++;\n        var coords = this._keyToCellCoords(key);\n        var bounds = this._cellCoordsToBounds(coords);\n        this._requestFeatures(bounds, coords, requestCallback);\n      }\n    }\n    return this;\n  },\n  refresh: function () {\n    this.setWhere(this.options.where);\n  },\n  _filterExistingFeatures: function (oldFrom, oldTo, newFrom, newTo) {\n    var layersToRemove = oldFrom && oldTo ? this._getFeaturesInTimeRange(oldFrom, oldTo) : this._currentSnapshot;\n    var layersToAdd = this._getFeaturesInTimeRange(newFrom, newTo);\n    if (layersToAdd.indexOf) {\n      for (var i = 0; i < layersToAdd.length; i++) {\n        var shouldRemoveLayer = layersToRemove.indexOf(layersToAdd[i]);\n        if (shouldRemoveLayer >= 0) {\n          layersToRemove.splice(shouldRemoveLayer, 1);\n        }\n      }\n    }\n\n    // schedule adding features until the next animation frame\n    Util.requestAnimFrame(Util.bind(function () {\n      this.removeLayers(layersToRemove);\n      this.addLayers(layersToAdd);\n    }, this));\n  },\n  _getFeaturesInTimeRange: function (start, end) {\n    var ids = [];\n    var search;\n    if (this.options.timeField.start && this.options.timeField.end) {\n      var startTimes = this._startTimeIndex.between(start, end);\n      var endTimes = this._endTimeIndex.between(start, end);\n      search = startTimes.concat(endTimes);\n    } else if (this._timeIndex) {\n      search = this._timeIndex.between(start, end);\n    } else {\n      warn('You must set timeField in the layer constructor in order to manipulate the start and end time filter.');\n      return [];\n    }\n    for (var i = search.length - 1; i >= 0; i--) {\n      ids.push(search[i].id);\n    }\n    return ids;\n  },\n  _buildTimeIndexes: function (geojson) {\n    var i;\n    var feature;\n    if (this.options.timeField.start && this.options.timeField.end) {\n      var startTimeEntries = [];\n      var endTimeEntries = [];\n      for (i = geojson.length - 1; i >= 0; i--) {\n        feature = geojson[i];\n        startTimeEntries.push({\n          id: feature.id,\n          value: new Date(feature.properties[this.options.timeField.start])\n        });\n        endTimeEntries.push({\n          id: feature.id,\n          value: new Date(feature.properties[this.options.timeField.end])\n        });\n      }\n      this._startTimeIndex.bulkAdd(startTimeEntries);\n      this._endTimeIndex.bulkAdd(endTimeEntries);\n    } else {\n      var timeEntries = [];\n      for (i = geojson.length - 1; i >= 0; i--) {\n        feature = geojson[i];\n        timeEntries.push({\n          id: feature.id,\n          value: new Date(feature.properties[this.options.timeField])\n        });\n      }\n      this._timeIndex.bulkAdd(timeEntries);\n    }\n  },\n  _featureWithinTimeRange: function (feature) {\n    if (!this.options.from || !this.options.to) {\n      return true;\n    }\n    var from = +this.options.from.valueOf();\n    var to = +this.options.to.valueOf();\n    if (typeof this.options.timeField === 'string') {\n      var date = +feature.properties[this.options.timeField];\n      return date >= from && date <= to;\n    }\n    if (this.options.timeField.start && this.options.timeField.end) {\n      var startDate = +feature.properties[this.options.timeField.start];\n      var endDate = +feature.properties[this.options.timeField.end];\n      return startDate >= from && startDate <= to || endDate >= from && endDate <= to || startDate <= from && endDate >= to;\n    }\n  },\n  _visibleZoom: function () {\n    // check to see whether the current zoom level of the map is within the optional limit defined for the FeatureLayer\n    if (!this._map) {\n      return false;\n    }\n    var zoom = this._map.getZoom();\n    if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n      return false;\n    } else {\n      return true;\n    }\n  },\n  _handleZoomChange: function () {\n    if (!this._visibleZoom()) {\n      // if we have moved outside the visible zoom range clear the current snapshot, no layers should be active\n      this.removeLayers(this._currentSnapshot);\n      this._currentSnapshot = [];\n    } else {\n      /*\r\n      for every cell in this._cells\r\n        1. Get the cache key for the coords of the cell\r\n        2. If this._cache[key] exists it will be an array of feature IDs.\r\n        3. Call this.addLayers(this._cache[key]) to instruct the feature layer to add the layers back.\r\n      */\n      for (var i in this._cells) {\n        var coords = this._cells[i].coords;\n        var key = this._cacheKey(coords);\n        if (this._cache[key]) {\n          this.addLayers(this._cache[key]);\n        }\n      }\n    }\n  },\n  /**\r\n   * Service Methods\r\n   */\n\n  authenticate: function (token) {\n    this.service.authenticate(token);\n    return this;\n  },\n  metadata: function (callback, context) {\n    this.service.metadata(callback, context);\n    return this;\n  },\n  query: function () {\n    return this.service.query();\n  },\n  _getMetadata: function (callback) {\n    if (this._metadata) {\n      var error;\n      callback(error, this._metadata);\n    } else {\n      this.metadata(Util.bind(function (error, response) {\n        this._metadata = response;\n        callback(error, this._metadata);\n      }, this));\n    }\n  },\n  addFeature: function (feature, callback, context) {\n    this.addFeatures(feature, callback, context);\n  },\n  addFeatures: function (features, callback, context) {\n    this._getMetadata(Util.bind(function (error, metadata) {\n      if (error) {\n        if (callback) {\n          callback.call(this, error, null);\n        }\n        return;\n      }\n      // GeoJSON featureCollection or simple feature\n      var featuresArray = features.features ? features.features : [features];\n      this.service.addFeatures(features, Util.bind(function (error, response) {\n        if (!error) {\n          for (var i = featuresArray.length - 1; i >= 0; i--) {\n            // assign ID from result to appropriate objectid field from service metadata\n            featuresArray[i].properties[metadata.objectIdField] = featuresArray.length > 1 ? response[i].objectId : response.objectId;\n            // we also need to update the geojson id for createLayers() to function\n            featuresArray[i].id = featuresArray.length > 1 ? response[i].objectId : response.objectId;\n          }\n          this._addFeatures(featuresArray);\n        }\n        if (callback) {\n          callback.call(context, error, response);\n        }\n      }, this));\n    }, this));\n  },\n  updateFeature: function (feature, callback, context) {\n    this.updateFeatures(feature, callback, context);\n  },\n  updateFeatures: function (features, callback, context) {\n    // GeoJSON featureCollection or simple feature\n    var featuresArray = features.features ? features.features : [features];\n    this.service.updateFeatures(features, function (error, response) {\n      if (!error) {\n        for (var i = featuresArray.length - 1; i >= 0; i--) {\n          this.removeLayers([featuresArray[i].id], true);\n        }\n        this._addFeatures(featuresArray);\n      }\n      if (callback) {\n        callback.call(context, error, response);\n      }\n    }, this);\n  },\n  deleteFeature: function (id, callback, context) {\n    this.deleteFeatures(id, callback, context);\n  },\n  deleteFeatures: function (ids, callback, context) {\n    return this.service.deleteFeatures(ids, function (error, response) {\n      var responseArray = response.length ? response : [response];\n      if (!error && responseArray.length > 0) {\n        for (var i = responseArray.length - 1; i >= 0; i--) {\n          this.removeLayers([responseArray[i].objectId], true);\n        }\n      }\n      if (callback) {\n        callback.call(context, error, response);\n      }\n    }, this);\n  }\n});","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}