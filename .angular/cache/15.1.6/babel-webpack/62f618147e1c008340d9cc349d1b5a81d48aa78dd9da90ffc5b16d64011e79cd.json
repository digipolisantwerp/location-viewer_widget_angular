{"ast":null,"code":"import * as i0 from \"@angular/core\";\n/**\n * Provide helper functions\n */\nexport let LocationViewerHelper = /*#__PURE__*/(() => {\n  class LocationViewerHelper {\n    /**\n     *\n     */\n    constructor() {}\n    /**\n     * Calculates the distance between multiple LatLng objects\n     *\n     * @param arrayOfPoints (array containing LatLng to calculate distance between)\n     *\n     * @return number\n     */\n    calculateDistance(arrayOfPoints) {\n      let totalDistance = 0;\n      for (let i = 0; i < arrayOfPoints.length - 1; i++) {\n        const currPoint = arrayOfPoints[i];\n        const nextPoint = arrayOfPoints[i + 1];\n        totalDistance += currPoint.distanceTo(nextPoint);\n      }\n      return totalDistance;\n    }\n    /**\n     * Calculates the perimeter multiple LatLng objects\n     *\n     * @param arrayOfPoints (array containing LatLng to calculate perimeter)\n     *\n     * @return number\n     */\n    calculatePerimeter(arrayOfPoints) {\n      let totalDistance = 0;\n      for (let i = 0; i < arrayOfPoints.length; i++) {\n        const currPoint = arrayOfPoints[i];\n        // if it is the last point calculate distance to the first point\n        if (i === arrayOfPoints.length - 1) {\n          totalDistance += currPoint.distanceTo(arrayOfPoints[0]);\n        } else {\n          totalDistance += currPoint.distanceTo(arrayOfPoints[i + 1]);\n        }\n      }\n      return totalDistance;\n    }\n    /**\n     * Builds the html for area popup\n     *\n     * @param perimeter the calculated perimeter\n     * @param area the calculated area\n     *\n     * @return string\n     */\n    getAreaPopupContent(perimeter, area) {\n      return `<p>Omtrek(m): ${perimeter.toFixed(2)}</p><p>Opp(m²): ${area.toFixed(2)}</p>`;\n    }\n    /**\n     * Check if required settings are provided in OperationalLayerOptions to build operational layer as esri feature layer\n     * @param operationalLayerOptions\n     *\n     * @return boolean\n     */\n    isValidOperationalFeatureLayerConfiguration(operationalLayerOptions) {\n      return operationalLayerOptions.url && (operationalLayerOptions.layerId || operationalLayerOptions.layerId === 0) && this.isValidMapServer(operationalLayerOptions.url);\n    }\n    /**\n     * Check if required settings are provided in OperationalLayerOptions to build operational layer as custom marker layer\n     * @param operationalLayerOptions\n     *\n     * @return boolean\n     */\n    isValidOpertionalMarkerLayerConfiguration(operationalLayerOptions) {\n      return operationalLayerOptions.markers && operationalLayerOptions.markers.length > 0 && operationalLayerOptions.name && operationalLayerOptions.isVisible;\n    }\n    /**\n     * Builds the html for the distance popup\n     *\n     * @param distance the calculated distance\n     *\n     * @return string\n     */\n    getDistancePopupContent(distance) {\n      return `<p>Afstand(m): ${distance.toFixed(2)}</p>`;\n    }\n    /**\n     * Builds the html for the whatishere popup\n     *\n     * @param address AddressDetail object with address info\n     *\n     * @return string\n     */\n    getWhatisherePopupContent(address) {\n      return `<div class=\"whatishere-wrapper\">\n        <div class=\"whatishere-title\"><b>${address.formattedAddress}</b></div>\n        <div class=\"whatishere-content\">\n        <div class=\"whatishere-type\">WGS84:</div>\n        <div>${address.addressPosition.wgs84.lat}, ${address.addressPosition.wgs84.lon}</div>\n        <div class=\"whatishere-type\">Lambert:</div>\n        <div>${address.addressPosition.lambert72.x}, ${address.addressPosition.lambert72.y}</div>\n        </div><div class=\"whatishere-image\">\n        <a href=\"https://maps.google.com/maps?q=&layer=c&cbll=${address.addressPosition.wgs84.lat},${address.addressPosition.wgs84.lon}\"\n        target=\"_blank\" ><img title=\"Ga naar streetview\"\n        src=\"https://seeklogo.com/images/G/google-street-view-logo-665165D1A8-seeklogo.com.png\"\n        style=\"max-width: 100%; max-height: 100%;\"/></a></div></div>`;\n    }\n    /**\n     * Check for valid mapserver url\n     *\n     * @param url mapserver url\n     *\n     * @return boolean\n     */\n    isValidMapServer(url) {\n      let validUrl;\n      // first check for valid url\n      try {\n        validUrl = new URL(url);\n      } catch (error) {\n        throw new Error(`Provided url is not a valid url: ${url}`);\n      }\n      // check if url is http or https protocol\n      if (validUrl.protocol !== 'http:' && validUrl.protocol !== 'https:') {\n        throw new Error(`Provided url does not follow http(s) protocol: ${url}`);\n      }\n      // we expect mapserver url to end with 'mapserver' this is to build the correct urls\n      if (!validUrl.href.toLowerCase().endsWith('mapserver')) {\n        throw new Error(`Provided mapserver url has to end with \\'mapserver\\': ${url}`);\n      }\n      return true;\n    }\n    /**\n     * Filter markers by geometry\n     *\n     * @param markers Operationalmarker array to filter\n     * @param geometries Array of polygons\n     *\n     * @returns OperationalMarker[]\n     */\n    filterOperationalMarkersByGeometries(markers, geometries) {\n      let filteredMarkers = [];\n      // flatten geometries to polygons, geometry could be polygon or collection of polygons\n      const polygons = geometries.map(g => {\n        if (g[0] && g[0][0] && isNaN(g[0][0])) {\n          return g.reduce((a, b) => a.concat(b)).map(([y, x]) => [x, y]);\n        } else {\n          return g.map(([y, x]) => [x, y]);\n        }\n      });\n      polygons.forEach(polygon => {\n        const polyMarkers = markers.filter(marker => {\n          return this.isCoordinateInsideGeometry(marker.coordinate.lat, marker.coordinate.lon, polygon);\n        });\n        filteredMarkers.push(...polyMarkers);\n      });\n      return filteredMarkers;\n    }\n    /**\n     * Check if coordinate is inside geometry, based on ray casting algorithm\n     * Code is based on: https://github.com/substack/point-in-polygon\n     *\n     * @param lattitude lattitude\n     * @param longitude longitude\n     * @param geometry Array of 2 based number arrays, check if markers are inside this geometry\n     *\n     * @returns boolean\n     */\n    isCoordinateInsideGeometry(lattitude, longitude, geometry) {\n      let inside = false;\n      for (let i = 0, j = geometry.length - 1; i < geometry.length; j = i++) {\n        const currentPointX = geometry[i][0];\n        const currentPointY = geometry[i][1];\n        const lastPointX = geometry[j][0];\n        const lastPointY = geometry[j][1];\n        const intersect = currentPointY > longitude != lastPointY > longitude && lattitude < (lastPointX - currentPointX) * (longitude - currentPointY) / (lastPointY - currentPointY) + currentPointX;\n        if (intersect) {\n          inside = !inside;\n        }\n      }\n      return inside;\n    }\n  }\n  LocationViewerHelper.ɵfac = function LocationViewerHelper_Factory(t) {\n    return new (t || LocationViewerHelper)();\n  };\n  LocationViewerHelper.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: LocationViewerHelper,\n    factory: LocationViewerHelper.ɵfac\n  });\n  return LocationViewerHelper;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}