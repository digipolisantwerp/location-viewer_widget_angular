{"ast":null,"code":"import { LatLngBounds, toLatLngBounds as latLngBounds, Layer, Browser, Util, Point, Bounds } from 'leaflet';\nexport var FeatureGrid = Layer.extend({\n  // @section\n  // @aka GridLayer options\n  options: {\n    // @option cellSize: Number|Point = 256\n    // Width and height of cells in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.\n    cellSize: 512,\n    // @option updateWhenIdle: Boolean = (depends)\n    // Load new cells only when panning ends.\n    // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.\n    // `false` otherwise in order to display new cells _during_ panning, since it is easy to pan outside the\n    // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.\n    updateWhenIdle: Browser.mobile,\n    // @option updateInterval: Number = 150\n    // Cells will not update more than once every `updateInterval` milliseconds when panning.\n    updateInterval: 150,\n    // @option noWrap: Boolean = false\n    // Whether the layer is wrapped around the antimeridian. If `true`, the\n    // GridLayer will only be displayed once at low zoom levels. Has no\n    // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used\n    // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting\n    // cells outside the CRS limits.\n    noWrap: false,\n    // @option keepBuffer: Number = 1.5\n    // When panning the map, keep this many rows and columns of cells before unloading them.\n    keepBuffer: 1.5\n  },\n  initialize: function (options) {\n    Util.setOptions(this, options);\n  },\n  onAdd: function (map) {\n    this._cells = {};\n    this._activeCells = {};\n    this._resetView();\n    this._update();\n  },\n  onRemove: function (map) {\n    this._removeAllCells();\n    this._cellZoom = undefined;\n  },\n  // @method isLoading: Boolean\n  // Returns `true` if any cell in the grid layer has not finished loading.\n  isLoading: function () {\n    return this._loading;\n  },\n  // @method redraw: this\n  // Causes the layer to clear all the cells and request them again.\n  redraw: function () {\n    if (this._map) {\n      this._removeAllCells();\n      this._update();\n    }\n    return this;\n  },\n  getEvents: function () {\n    var events = {\n      viewprereset: this._invalidateAll,\n      viewreset: this._resetView,\n      zoom: this._resetView,\n      moveend: this._onMoveEnd\n    };\n    if (!this.options.updateWhenIdle) {\n      // update cells on move, but not more often than once per given interval\n      if (!this._onMove) {\n        this._onMove = Util.throttle(this._onMoveEnd, this.options.updateInterval, this);\n      }\n      events.move = this._onMove;\n    }\n    return events;\n  },\n  // @section Extension methods\n  // Layers extending `GridLayer` shall reimplement the following method.\n  // @method createCell(coords: Object, done?: Function): HTMLElement\n  // Called only internally, must be overridden by classes extending `GridLayer`.\n  // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback\n  // is specified, it must be called when the cell has finished loading and drawing.\n  createCell: function () {\n    return document.createElement('div');\n  },\n  removeCell: function () {},\n  reuseCell: function () {},\n  cellLeave: function () {},\n  cellEnter: function () {},\n  // @section\n  // @method getCellSize: Point\n  // Normalizes the [cellSize option](#gridlayer-cellsize) into a point. Used by the `createCell()` method.\n  getCellSize: function () {\n    var s = this.options.cellSize;\n    return s instanceof Point ? s : new Point(s, s);\n  },\n  _pruneCells: function () {\n    if (!this._map) {\n      return;\n    }\n    var key, cell;\n    for (key in this._cells) {\n      cell = this._cells[key];\n      cell.retain = cell.current;\n    }\n    for (key in this._cells) {\n      cell = this._cells[key];\n      if (cell.current && !cell.active) {\n        var coords = cell.coords;\n        if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {\n          this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);\n        }\n      }\n    }\n    for (key in this._cells) {\n      if (!this._cells[key].retain) {\n        this._removeCell(key);\n      }\n    }\n  },\n  _removeAllCells: function () {\n    for (var key in this._cells) {\n      this._removeCell(key);\n    }\n  },\n  _invalidateAll: function () {\n    this._removeAllCells();\n    this._cellZoom = undefined;\n  },\n  _retainParent: function (x, y, z, minZoom) {\n    var x2 = Math.floor(x / 2);\n    var y2 = Math.floor(y / 2);\n    var z2 = z - 1;\n    var coords2 = new Point(+x2, +y2);\n    coords2.z = +z2;\n    var key = this._cellCoordsToKey(coords2);\n    var cell = this._cells[key];\n    if (cell && cell.active) {\n      cell.retain = true;\n      return true;\n    } else if (cell && cell.loaded) {\n      cell.retain = true;\n    }\n    if (z2 > minZoom) {\n      return this._retainParent(x2, y2, z2, minZoom);\n    }\n    return false;\n  },\n  _retainChildren: function (x, y, z, maxZoom) {\n    for (var i = 2 * x; i < 2 * x + 2; i++) {\n      for (var j = 2 * y; j < 2 * y + 2; j++) {\n        var coords = new Point(i, j);\n        coords.z = z + 1;\n        var key = this._cellCoordsToKey(coords);\n        var cell = this._cells[key];\n        if (cell && cell.active) {\n          cell.retain = true;\n          continue;\n        } else if (cell && cell.loaded) {\n          cell.retain = true;\n        }\n        if (z + 1 < maxZoom) {\n          this._retainChildren(i, j, z + 1, maxZoom);\n        }\n      }\n    }\n  },\n  _resetView: function (e) {\n    var animating = e && (e.pinch || e.flyTo);\n    if (animating) {\n      return;\n    }\n    this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);\n  },\n  _setView: function (center, zoom, noPrune, noUpdate) {\n    var cellZoom = Math.round(zoom);\n    if (!noUpdate) {\n      this._cellZoom = cellZoom;\n      if (this._abortLoading) {\n        this._abortLoading();\n      }\n      this._resetGrid();\n      if (cellZoom !== undefined) {\n        this._update(center);\n      }\n      if (!noPrune) {\n        this._pruneCells();\n      }\n\n      // Flag to prevent _updateOpacity from pruning cells during\n      // a zoom anim or a pinch gesture\n      this._noPrune = !!noPrune;\n    }\n  },\n  _resetGrid: function () {\n    var map = this._map;\n    var crs = map.options.crs;\n    var cellSize = this._cellSize = this.getCellSize();\n    var cellZoom = this._cellZoom;\n    var bounds = this._map.getPixelWorldBounds(this._cellZoom);\n    if (bounds) {\n      this._globalCellRange = this._pxBoundsToCellRange(bounds);\n    }\n    this._wrapX = crs.wrapLng && !this.options.noWrap && [Math.floor(map.project([0, crs.wrapLng[0]], cellZoom).x / cellSize.x), Math.ceil(map.project([0, crs.wrapLng[1]], cellZoom).x / cellSize.y)];\n    this._wrapY = crs.wrapLat && !this.options.noWrap && [Math.floor(map.project([crs.wrapLat[0], 0], cellZoom).y / cellSize.x), Math.ceil(map.project([crs.wrapLat[1], 0], cellZoom).y / cellSize.y)];\n  },\n  _onMoveEnd: function (e) {\n    var animating = e && (e.pinch || e.flyTo);\n    if (animating || !this._map || this._map._animatingZoom) {\n      return;\n    }\n    this._update();\n  },\n  _getCelldPixelBounds: function (center) {\n    var map = this._map;\n    var mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom();\n    var scale = map.getZoomScale(mapZoom, this._cellZoom);\n    var pixelCenter = map.project(center, this._cellZoom).floor();\n    var halfSize = map.getSize().divideBy(scale * 2);\n    return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\n  },\n  // Private method to load cells in the grid's active zoom level according to map bounds\n  _update: function (center) {\n    var map = this._map;\n    if (!map) {\n      return;\n    }\n    var zoom = Math.round(map.getZoom());\n    if (center === undefined) {\n      center = map.getCenter();\n    }\n    var pixelBounds = this._getCelldPixelBounds(center);\n    var cellRange = this._pxBoundsToCellRange(pixelBounds);\n    var cellCenter = cellRange.getCenter();\n    var queue = [];\n    var margin = this.options.keepBuffer;\n    var noPruneRange = new Bounds(cellRange.getBottomLeft().subtract([margin, -margin]), cellRange.getTopRight().add([margin, -margin]));\n\n    // Sanity check: panic if the cell range contains Infinity somewhere.\n    if (!(isFinite(cellRange.min.x) && isFinite(cellRange.min.y) && isFinite(cellRange.max.x) && isFinite(cellRange.max.y))) {\n      throw new Error('Attempted to load an infinite number of cells');\n    }\n    for (var key in this._cells) {\n      var c = this._cells[key].coords;\n      if (c.z !== this._cellZoom || !noPruneRange.contains(new Point(c.x, c.y))) {\n        this._cells[key].current = false;\n      }\n    }\n\n    // _update just loads more cells. If the cell zoom level differs too much\n    // from the map's, let _setView reset levels and prune old cells.\n    if (Math.abs(zoom - this._cellZoom) > 1) {\n      this._setView(center, zoom);\n      return;\n    }\n\n    // create a queue of coordinates to load cells from\n    for (var j = cellRange.min.y; j <= cellRange.max.y; j++) {\n      for (var i = cellRange.min.x; i <= cellRange.max.x; i++) {\n        var coords = new Point(i, j);\n        coords.z = this._cellZoom;\n        if (!this._isValidCell(coords)) {\n          continue;\n        }\n        var cell = this._cells[this._cellCoordsToKey(coords)];\n        if (cell) {\n          cell.current = true;\n        } else {\n          queue.push(coords);\n        }\n      }\n    }\n\n    // sort cell queue to load cells in order of their distance to center\n    queue.sort(function (a, b) {\n      return a.distanceTo(cellCenter) - b.distanceTo(cellCenter);\n    });\n    if (queue.length !== 0) {\n      // if it's the first batch of cells to load\n      if (!this._loading) {\n        this._loading = true;\n      }\n      for (i = 0; i < queue.length; i++) {\n        var _key = this._cellCoordsToKey(queue[i]);\n        var _coords = this._keyToCellCoords(_key);\n        if (this._activeCells[_coords]) {\n          this._reuseCell(queue[i]);\n        } else {\n          this._createCell(queue[i]);\n        }\n      }\n    }\n  },\n  _isValidCell: function (coords) {\n    var crs = this._map.options.crs;\n    if (!crs.infinite) {\n      // don't load cell if it's out of bounds and not wrapped\n      var bounds = this._globalCellRange;\n      if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {\n        return false;\n      }\n    }\n    if (!this.options.bounds) {\n      return true;\n    }\n\n    // don't load cell if it doesn't intersect the bounds in options\n    var cellBounds = this._cellCoordsToBounds(coords);\n    return latLngBounds(this.options.bounds).overlaps(cellBounds);\n  },\n  _keyToBounds: function (key) {\n    return this._cellCoordsToBounds(this._keyToCellCoords(key));\n  },\n  _cellCoordsToNwSe: function (coords) {\n    var map = this._map;\n    var cellSize = this.getCellSize();\n    var nwPoint = coords.scaleBy(cellSize);\n    var sePoint = nwPoint.add(cellSize);\n    var nw = map.unproject(nwPoint, coords.z);\n    var se = map.unproject(sePoint, coords.z);\n    return [nw, se];\n  },\n  // converts cell coordinates to its geographical bounds\n  _cellCoordsToBounds: function (coords) {\n    var bp = this._cellCoordsToNwSe(coords);\n    var bounds = new LatLngBounds(bp[0], bp[1]);\n    if (!this.options.noWrap) {\n      bounds = this._map.wrapLatLngBounds(bounds);\n    }\n    return bounds;\n  },\n  // converts cell coordinates to key for the cell cache\n  _cellCoordsToKey: function (coords) {\n    return coords.x + ':' + coords.y + ':' + coords.z;\n  },\n  // converts cell cache key to coordinates\n  _keyToCellCoords: function (key) {\n    var k = key.split(':');\n    var coords = new Point(+k[0], +k[1]);\n    coords.z = +k[2];\n    return coords;\n  },\n  _removeCell: function (key) {\n    var cell = this._cells[key];\n    if (!cell) {\n      return;\n    }\n    var coords = this._keyToCellCoords(key);\n    var wrappedCoords = this._wrapCoords(coords);\n    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));\n    cell.current = false;\n    delete this._cells[key];\n    this._activeCells[key] = cell;\n    this.cellLeave(cellBounds, wrappedCoords, key);\n    this.fire('cellleave', {\n      key: key,\n      coords: wrappedCoords,\n      bounds: cellBounds\n    });\n  },\n  _reuseCell: function (coords) {\n    var key = this._cellCoordsToKey(coords);\n\n    // save cell in cache\n    this._cells[key] = this._activeCells[key];\n    this._cells[key].current = true;\n    var wrappedCoords = this._wrapCoords(coords);\n    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));\n    this.cellEnter(cellBounds, wrappedCoords, key);\n    this.fire('cellenter', {\n      key: key,\n      coords: wrappedCoords,\n      bounds: cellBounds\n    });\n  },\n  _createCell: function (coords) {\n    var key = this._cellCoordsToKey(coords);\n    var wrappedCoords = this._wrapCoords(coords);\n    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));\n    this.createCell(cellBounds, wrappedCoords, key);\n    this.fire('cellcreate', {\n      key: key,\n      coords: wrappedCoords,\n      bounds: cellBounds\n    });\n\n    // save cell in cache\n    this._cells[key] = {\n      coords: coords,\n      current: true\n    };\n    Util.requestAnimFrame(this._pruneCells, this);\n  },\n  _cellReady: function (coords, err, cell) {\n    var key = this._cellCoordsToKey(coords);\n    cell = this._cells[key];\n    if (!cell) {\n      return;\n    }\n    cell.loaded = +new Date();\n    cell.active = true;\n  },\n  _getCellPos: function (coords) {\n    return coords.scaleBy(this.getCellSize());\n  },\n  _wrapCoords: function (coords) {\n    var newCoords = new Point(this._wrapX ? Util.wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? Util.wrapNum(coords.y, this._wrapY) : coords.y);\n    newCoords.z = coords.z;\n    return newCoords;\n  },\n  _pxBoundsToCellRange: function (bounds) {\n    var cellSize = this.getCellSize();\n    return new Bounds(bounds.min.unscaleBy(cellSize).floor(), bounds.max.unscaleBy(cellSize).ceil().subtract([1, 1]));\n  }\n});","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}